
uipws.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002aa  00800100  00006572  00006606  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006572  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000842  008003aa  008003aa  000068b0  2**0
                  ALLOC
  3 .stab         00002dcc  00000000  00000000  000068b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001191  00000000  00000000  0000967c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  0000a80d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000ae1  00000000  00000000  0000a96d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005698  00000000  00000000  0000b44e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000015ec  00000000  00000000  00010ae6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000367d  00000000  00000000  000120d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000680  00000000  00000000  00015750  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000107f  00000000  00000000  00015dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001af7  00000000  00000000  00016e4f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000298  00000000  00000000  00018946  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d6 0f 	jmp	0x1fac	; 0x1fac <__ctors_end>
       4:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
       8:	0c 94 22 10 	jmp	0x2044	; 0x2044 <__vector_2>
       c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      10:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      14:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      18:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      1c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      20:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      24:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      28:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      2c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      30:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      34:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      38:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      3c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      40:	0c 94 f5 0f 	jmp	0x1fea	; 0x1fea <__vector_16>
      44:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      48:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      4c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      50:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      54:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      58:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      5c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      60:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      64:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      68:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      6c:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      70:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      74:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>
      78:	0c 94 f3 0f 	jmp	0x1fe6	; 0x1fe6 <__bad_interrupt>

0000007c <__c.2231>:
      7c:	1b 5b 50 00                                         .[P.

00000080 <__c.2229>:
      80:	23 00                                               #.

00000082 <__c.2224>:
      82:	0d 0a 72 65 61 64 79 2e 20 0d 0a 00                 ..ready. ...

0000008e <__c.2222>:
      8e:	69 6e 69 74 20 43 50 32 32 30 30 20 2e 2e 2e 00     init CP2200 ....

0000009e <__c.2194>:
      9e:	48 45 4c 50 00                                      HELP.

000000a3 <__c.2192>:
      a3:	64 6f 6e 65 20 0a 0d 00                             done ...

000000ab <__c.2190>:
      ab:	43 50 32 32 30 30 20 72 65 73 65 74 20 2e 2e 2e     CP2200 reset ...
	...

000000bc <__c.2188>:
      bc:	43 50 52 45 53 45 54 00                             CPRESET.

000000c4 <__c.2186>:
      c4:	4e 45 54 4d 41 53 4b 00                             NETMASK.

000000cc <__c.2184>:
      cc:	49 50 00                                            IP.

000000cf <__c.2165>:
      cf:	20 20 0d 0a 00                                        ...

000000d4 <__c.2163>:
      d4:	20 20 4e 45 54 4d 41 53 4b 20 3c 78 78 78 2e 78       NETMASK <xxx.x
      e4:	78 78 2e 78 78 78 2e 78 78 78 3e 20 20 20 2f 2f     xx.xxx.xxx>   //
      f4:	20 64 69 73 70 6c 61 79 20 2f 20 73 65 74 20 6e      display / set n
     104:	65 74 6d 61 73 6b 0d 0a 00                          etmask...

0000010d <__c.2161>:
     10d:	20 20 49 50 20 3c 78 78 78 2e 78 78 78 2e 78 78       IP <xxx.xxx.xx
     11d:	78 2e 78 78 78 3e 20 20 20 20 20 20 20 20 2f 2f     x.xxx>        //
     12d:	20 64 69 73 70 6c 61 79 20 2f 20 73 65 74 20 49      display / set I
     13d:	50 20 61 64 64 72 65 73 73 0d 0a 00                 P address...

00000149 <__c.2159>:
     149:	20 20 43 50 52 45 53 45 54 20 20 20 20 20 20 20       CPRESET       
     159:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 2f 2f                   //
     169:	20 72 65 69 6e 69 74 69 61 6c 69 7a 65 20 65 74      reinitialize et
     179:	68 65 72 6e 65 74 20 63 6f 6e 74 72 6f 6c 6c 65     hernet controlle
     189:	72 20 0d 0a 00                                      r ...

0000018e <__c.2157>:
     18e:	20 43 6f 6d 6d 61 6e 64 73 3a 20 0d 0a 00            Commands: ...

0000019c <__c.2155>:
     19c:	20 73 65 72 69 61 6c 3a 20 31 39 32 30 30 20 62      serial: 19200 b
     1ac:	61 75 64 20 38 4e 31 20 0d 0a 00                    aud 8N1 ...

000001b7 <__c.2153>:
     1b7:	20 2a 2a 2a 20 65 6d 61 69 6c 3a 20 73 74 65 66      *** email: stef
     1c7:	61 6e 40 70 65 72 7a 62 6f 72 6e 2e 6e 65 74 20     an@perzborn.net 
     1d7:	0d 0a 00                                            ...

000001da <__c.2151>:
     1da:	20 2a 2a 2a 20 77 65 62 3a 20 77 77 77 2e 70 65      *** web: www.pe
     1ea:	72 7a 62 6f 72 6e 2e 6e 65 74 20 0d 0a 00           rzborn.net ...

000001f8 <__c.2149>:
     1f8:	20 2a 2a 2a 20 76 65 72 73 69 6f 6e 20 31 2e 20      *** version 1. 
     208:	61 64 61 70 74 65 64 20 62 79 20 53 2e 50 65 72     adapted by S.Per
     218:	7a 62 6f 72 6e 20 5b 32 33 2e 30 31 2e 32 30 30     zborn [23.01.200
     228:	39 5d 20 2a 2a 2a 20 0d 0a 00                       9] *** ...

00000232 <__c.2147>:
     232:	0d 0a 41 64 61 6d 20 44 75 6e 6b 65 6c 73 20 75     ..Adam Dunkels u
     242:	49 50 20 77 65 62 73 65 72 76 65 72 20 65 78 61     IP webserver exa
     252:	6d 70 6c 65 20 66 6f 72 20 43 72 75 6d 62 36 34     mple for Crumb64
     262:	34 2d 4e 45 54 0d 0a 00                             4-NET...

0000026a <__c.2103>:
     26a:	0d 0a 00                                            ...

0000026d <__c.2098>:
     26d:	2e 00                                               ..

0000026f <__c.2049>:
     26f:	0d 0a 00                                            ...

00000272 <__c.2044>:
     272:	2e 00                                               ..

00000274 <__c.2031>:
     274:	20 62 79 74 65 73 20 0d 0a 00                        bytes ...

0000027e <__c.2029>:
     27e:	61 76 61 69 6c 61 62 6c 65 20 52 41 4d 20 6d 65     available RAM me
     28e:	6d 6f 72 79 3a 00                                   mory:.

00000294 <__c.1936>:
     294:	74 69 6d 65 6f 75 74 0d 0a 00                       timeout...

0000029e <__c.1931>:
     29e:	74 69 6d 65 6f 75 74 0d 0a 00                       timeout...

000002a8 <__c.1901>:
     2a8:	0a 0d 00                                            ...

000002ab <__c.1896>:
     2ab:	0a 0d 4d 41 43 3a 00                                ..MAC:.

000002b2 <__c.1798>:
     2b2:	43 50 32 32 30 30 20 62 75 66 66 65 72 20 66 75     CP2200 buffer fu
     2c2:	6c 6c 0d 0a 00                                      ll...

000002c7 <__c.1957>:
     2c7:	4c 45 44 3d 30 0d 0a 00                             LED=0...

000002cf <__c.1955>:
     2cf:	4c 45 44 3d 31 0d 0a 00                             LED=1...

000002d7 <__c.1953>:
     2d7:	66 6f 75 6e 64 20 69 6f 2e 73 68 74 6d 6c 0d 0a     found io.shtml..
	...

000002e8 <__c.1951>:
     2e8:	66 6f 75 6e 64 20 3f 0d 0a 00                       found ?...

000002f2 <__c.1815>:
     2f2:	0d 0a 53 43 52 49 50 54 00                          ..SCRIPT.

000002fb <http_http>:
     2fb:	68 74 74 70 3a 2f 2f 00                             http://.

00000303 <http_200>:
     303:	32 30 30 20 00                                      200 .

00000308 <http_301>:
     308:	33 30 31 20 00                                      301 .

0000030d <http_302>:
     30d:	33 30 32 20 00                                      302 .

00000312 <http_get>:
     312:	47 45 54 20 00                                      GET .

00000317 <http_10>:
     317:	48 54 54 50 2f 31 2e 30 00                          HTTP/1.0.

00000320 <http_11>:
     320:	48 54 54 50 2f 31 2e 31 00                          HTTP/1.1.

00000329 <http_content_type>:
     329:	63 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 00        content-type: .

00000338 <http_texthtml>:
     338:	74 65 78 74 2f 68 74 6d 6c 00                       text/html.

00000342 <http_location>:
     342:	6c 6f 63 61 74 69 6f 6e 3a 20 00                    location: .

0000034d <http_host>:
     34d:	68 6f 73 74 3a 20 00                                host: .

00000354 <http_crnl>:
     354:	0d 0a 00                                            ...

00000357 <http_index_html>:
     357:	2f 69 6e 64 65 78 2e 68 74 6d 6c 00                 /index.html.

00000363 <http_404_html>:
     363:	2f 34 30 34 2e 68 74 6d 6c 00                       /404.html.

0000036d <http_referer>:
     36d:	52 65 66 65 72 65 72 3a 00                          Referer:.

00000376 <http_header_200>:
     376:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     386:	0a 53 65 72 76 65 72 3a 20 75 49 50 2f 31 2e 30     .Server: uIP/1.0
     396:	20 68 74 74 70 3a 2f 2f 77 77 77 2e 73 69 63 73      http://www.sics
     3a6:	2e 73 65 2f 7e 61 64 61 6d 2f 75 69 70 2f 0d 0a     .se/~adam/uip/..
     3b6:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
     3c6:	65 0d 0a 00                                         e...

000003ca <http_header_404>:
     3ca:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
     3da:	20 66 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      found..Server: 
     3ea:	75 49 50 2f 31 2e 30 20 68 74 74 70 3a 2f 2f 77     uIP/1.0 http://w
     3fa:	77 77 2e 73 69 63 73 2e 73 65 2f 7e 61 64 61 6d     ww.sics.se/~adam
     40a:	2f 75 69 70 2f 0d 0a 43 6f 6e 6e 65 63 74 69 6f     /uip/..Connectio
     41a:	6e 3a 20 63 6c 6f 73 65 0d 0a 00                    n: close...

00000425 <http_content_type_plain>:
     425:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     435:	78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 00              xt/plain.....

00000442 <http_content_type_html>:
     442:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     452:	78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00                 xt/html.....

0000045e <http_content_type_css>:
     45e:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     46e:	78 74 2f 63 73 73 0d 0a 0d 0a 00                    xt/css.....

00000479 <http_content_type_text>:
     479:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     489:	78 74 2f 74 65 78 74 0d 0a 0d 0a 00                 xt/text.....

00000495 <http_content_type_png>:
     495:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
     4a5:	61 67 65 2f 70 6e 67 0d 0a 0d 0a 00                 age/png.....

000004b1 <http_content_type_gif>:
     4b1:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
     4c1:	61 67 65 2f 67 69 66 0d 0a 0d 0a 00                 age/gif.....

000004cd <http_content_type_jpg>:
     4cd:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
     4dd:	61 67 65 2f 6a 70 65 67 0d 0a 0d 0a 00              age/jpeg.....

000004ea <http_content_type_binary>:
     4ea:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 61 70     Content-type: ap
     4fa:	70 6c 69 63 61 74 69 6f 6e 2f 6f 63 74 65 74 2d     plication/octet-
     50a:	73 74 72 65 61 6d 0d 0a 0d 0a 00                    stream.....

00000515 <http_html>:
     515:	2e 68 74 6d 6c 00                                   .html.

0000051b <http_shtml>:
     51b:	2e 73 68 74 6d 6c 00                                .shtml.

00000522 <http_htm>:
     522:	2e 68 74 6d 00                                      .htm.

00000527 <http_css>:
     527:	2e 63 73 73 00                                      .css.

0000052c <http_png>:
     52c:	2e 70 6e 67 00                                      .png.

00000531 <http_gif>:
     531:	2e 67 69 66 00                                      .gif.

00000536 <http_jpg>:
     536:	2e 6a 70 67 00                                      .jpg.

0000053b <http_text>:
     53b:	2e 74 78 74 00                                      .txt.

00000540 <http_txt>:
     540:	2e 74 78 74 00                                      .txt.

00000545 <data_processes_shtml>:
     545:	2f 70 72 6f 63 65 73 73 65 73 2e 73 68 74 6d 6c     /processes.shtml
     555:	00 25 21 3a 20 2f 68 65 61 64 65 72 2e 68 74 6d     .%!: /header.htm
     565:	6c 0a 3c 68 31 3e 53 79 73 74 65 6d 20 70 72 6f     l.<h1>System pro
     575:	63 65 73 73 65 73 3c 2f 68 31 3e 3c 62 72 3e 3c     cesses</h1><br><
     585:	74 61 62 6c 65 20 77 69 64 74 68 3d 22 31 30 30     table width="100
     595:	25 22 3e 0a 3c 74 72 3e 3c 74 68 3e 49 44 3c 2f     %">.<tr><th>ID</
     5a5:	74 68 3e 3c 74 68 3e 4e 61 6d 65 3c 2f 74 68 3e     th><th>Name</th>
     5b5:	3c 74 68 3e 50 72 69 6f 72 69 74 79 3c 2f 74 68     <th>Priority</th
     5c5:	3e 3c 74 68 3e 50 6f 6c 6c 20 68 61 6e 64 6c 65     ><th>Poll handle
     5d5:	72 3c 2f 74 68 3e 3c 74 68 3e 45 76 65 6e 74 20     r</th><th>Event 
     5e5:	68 61 6e 64 6c 65 72 3c 2f 74 68 3e 3c 74 68 3e     handler</th><th>
     5f5:	50 72 6f 63 73 74 61 74 65 3c 2f 74 68 3e 3c 2f     Procstate</th></
     605:	74 72 3e 0a 25 21 20 70 72 6f 63 65 73 73 65 73     tr>.%! processes
     615:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
     625:	6c 00                                               l.

00000627 <data_404_html>:
     627:	2f 34 30 34 2e 68 74 6d 6c 00 3c 68 74 6d 6c 3e     /404.html.<html>
     637:	0a 20 20 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72     .  <body bgcolor
     647:	3d 22 77 68 69 74 65 22 3e 0a 20 20 20 20 3c 63     ="white">.    <c
     657:	65 6e 74 65 72 3e 0a 20 20 20 20 20 20 3c 68 31     enter>.      <h1
     667:	3e 34 30 34 20 2d 20 66 69 6c 65 20 6e 6f 74 20     >404 - file not 
     677:	66 6f 75 6e 64 3c 2f 68 31 3e 0a 20 20 20 20 20     found</h1>.     
     687:	20 3c 68 33 3e 47 6f 20 3c 61 20 68 72 65 66 3d      <h3>Go <a href=
     697:	22 2f 22 3e 68 65 72 65 3c 2f 61 3e 20 69 6e 73     "/">here</a> ins
     6a7:	74 65 61 64 2e 3c 2f 68 33 3e 0a 20 20 20 20 3c     tead.</h3>.    <
     6b7:	2f 63 65 6e 74 65 72 3e 0a 20 20 3c 2f 62 6f 64     /center>.  </bod
     6c7:	79 3e 0a 3c 2f 68 74 6d 6c 3e 00                    y>.</html>.

000006d2 <data_files_shtml>:
     6d2:	2f 66 69 6c 65 73 2e 73 68 74 6d 6c 00 25 21 3a     /files.shtml.%!:
     6e2:	20 2f 68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68      /header.html.<h
     6f2:	31 3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63     1>File statistic
     702:	73 3c 2f 68 31 3e 0a 3c 63 65 6e 74 65 72 3e 0a     s</h1>.<center>.
     712:	3c 74 61 62 6c 65 20 77 69 64 74 68 3d 22 33 30     <table width="30
     722:	30 22 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68     0">.<tr><td><a h
     732:	72 65 66 3d 22 2f 69 6e 64 65 78 2e 68 74 6d 6c     ref="/index.html
     742:	22 3e 2f 69 6e 64 65 78 2e 68 74 6d 6c 3c 2f 61     ">/index.html</a
     752:	3e 3c 2f 74 64 3e 0a 3c 74 64 3e 25 21 20 66 69     ></td>.<td>%! fi
     762:	6c 65 2d 73 74 61 74 73 20 2f 69 6e 64 65 78 2e     le-stats /index.
     772:	68 74 6d 6c 0a 3c 2f 74 64 3e 3c 74 64 3e 3c 69     html.</td><td><i
     782:	6d 67 20 73 72 63 3d 22 2f 66 61 64 65 2e 70 6e     mg src="/fade.pn
     792:	67 22 20 68 65 69 67 68 74 3d 31 30 20 77 69 64     g" height=10 wid
     7a2:	74 68 3d 25 21 20 66 69 6c 65 2d 73 74 61 74 73     th=%! file-stats
     7b2:	20 2f 69 6e 64 65 78 2e 68 74 6d 6c 0a 3e 20 3c      /index.html.> <
     7c2:	2f 74 64 3e 3c 2f 74 72 3e 0a 3c 74 72 3e 3c 74     /td></tr>.<tr><t
     7d2:	64 3e 3c 61 20 68 72 65 66 3d 22 2f 66 69 6c 65     d><a href="/file
     7e2:	73 2e 73 68 74 6d 6c 22 3e 2f 66 69 6c 65 73 2e     s.shtml">/files.
     7f2:	73 68 74 6d 6c 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c     shtml</a></td>.<
     802:	74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61 74 73     td>%! file-stats
     812:	20 2f 66 69 6c 65 73 2e 73 68 74 6d 6c 0a 3c 2f      /files.shtml.</
     822:	74 64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d     td><td><img src=
     832:	22 2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67     "/fade.png" heig
     842:	68 74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66     ht=10 width=%! f
     852:	69 6c 65 2d 73 74 61 74 73 20 2f 66 69 6c 65 73     ile-stats /files
     862:	2e 73 68 74 6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f     .shtml.> </td></
     872:	74 72 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68     tr>.<tr><td><a h
     882:	72 65 66 3d 22 2f 74 63 70 2e 73 68 74 6d 6c 22     ref="/tcp.shtml"
     892:	3e 2f 74 63 70 2e 73 68 74 6d 6c 3c 2f 61 3e 3c     >/tcp.shtml</a><
     8a2:	2f 74 64 3e 0a 3c 74 64 3e 25 21 20 66 69 6c 65     /td>.<td>%! file
     8b2:	2d 73 74 61 74 73 20 2f 74 63 70 2e 73 68 74 6d     -stats /tcp.shtm
     8c2:	6c 0a 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6d 67 20     l.</td><td><img 
     8d2:	73 72 63 3d 22 2f 66 61 64 65 2e 70 6e 67 22 20     src="/fade.png" 
     8e2:	68 65 69 67 68 74 3d 31 30 20 77 69 64 74 68 3d     height=10 width=
     8f2:	25 21 20 66 69 6c 65 2d 73 74 61 74 73 20 2f 74     %! file-stats /t
     902:	63 70 2e 73 68 74 6d 6c 0a 3e 20 3c 2f 74 64 3e     cp.shtml.> </td>
     912:	3c 2f 74 72 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61     </tr>.<tr><td><a
     922:	20 68 72 65 66 3d 22 2f 73 74 61 74 73 2e 73 68      href="/stats.sh
     932:	74 6d 6c 22 3e 2f 73 74 61 74 73 2e 73 68 74 6d     tml">/stats.shtm
     942:	6c 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c 74 64 3e 25     l</a></td>.<td>%
     952:	21 20 66 69 6c 65 2d 73 74 61 74 73 20 2f 73 74     ! file-stats /st
     962:	61 74 73 2e 73 68 74 6d 6c 0a 3c 2f 74 64 3e 3c     ats.shtml.</td><
     972:	74 64 3e 3c 69 6d 67 20 73 72 63 3d 22 2f 66 61     td><img src="/fa
     982:	64 65 2e 70 6e 67 22 20 68 65 69 67 68 74 3d 31     de.png" height=1
     992:	30 20 77 69 64 74 68 3d 25 21 20 66 69 6c 65 2d     0 width=%! file-
     9a2:	73 74 61 74 73 20 2f 73 74 61 74 73 2e 73 68 74     stats /stats.sht
     9b2:	6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a     ml.> </td></tr>.
     9c2:	3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65 66 3d     <tr><td><a href=
     9d2:	22 2f 73 74 79 6c 65 2e 63 73 73 22 3e 2f 73 74     "/style.css">/st
     9e2:	79 6c 65 2e 63 73 73 3c 2f 61 3e 3c 2f 74 64 3e     yle.css</a></td>
     9f2:	0a 3c 74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61     .<td>%! file-sta
     a02:	74 73 20 2f 73 74 79 6c 65 2e 63 73 73 0a 3c 2f     ts /style.css.</
     a12:	74 64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d     td><td><img src=
     a22:	22 2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67     "/fade.png" heig
     a32:	68 74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66     ht=10 width=%! f
     a42:	69 6c 65 2d 73 74 61 74 73 20 2f 73 74 79 6c 65     ile-stats /style
     a52:	2e 63 73 73 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72     .css.> </td></tr
     a62:	3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65     >.<tr><td><a hre
     a72:	66 3d 22 2f 34 30 34 2e 68 74 6d 6c 22 3e 2f 34     f="/404.html">/4
     a82:	30 34 2e 68 74 6d 6c 3c 2f 61 3e 3c 2f 74 64 3e     04.html</a></td>
     a92:	0a 3c 74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61     .<td>%! file-sta
     aa2:	74 73 20 2f 34 30 34 2e 68 74 6d 6c 0a 3c 2f 74     ts /404.html.</t
     ab2:	64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d 22     d><td><img src="
     ac2:	2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67 68     /fade.png" heigh
     ad2:	74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66 69     t=10 width=%! fi
     ae2:	6c 65 2d 73 74 61 74 73 20 2f 34 30 34 2e 68 74     le-stats /404.ht
     af2:	6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a     ml.> </td></tr>.
     b02:	3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65 66 3d     <tr><td><a href=
     b12:	22 2f 66 61 64 65 2e 70 6e 67 22 3e 2f 66 61 64     "/fade.png">/fad
     b22:	65 2e 70 6e 67 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c     e.png</a></td>.<
     b32:	74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61 74 73     td>%! file-stats
     b42:	20 2f 66 61 64 65 2e 70 6e 67 0a 3c 2f 74 64 3e      /fade.png.</td>
     b52:	3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d 22 2f 66     <td><img src="/f
     b62:	61 64 65 2e 70 6e 67 22 20 68 65 69 67 68 74 3d     ade.png" height=
     b72:	31 30 20 77 69 64 74 68 3d 25 21 20 66 69 6c 65     10 width=%! file
     b82:	2d 73 74 61 74 73 20 2f 66 61 64 65 2e 70 6e 67     -stats /fade.png
     b92:	0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a 3c 2f     .> </td></tr>.</
     ba2:	74 61 62 6c 65 3e 0a 3c 2f 63 65 6e 74 65 72 3e     table>.</center>
     bb2:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
     bc2:	6c 0a 00                                            l..

00000bc5 <data_footer_html>:
     bc5:	2f 66 6f 6f 74 65 72 2e 68 74 6d 6c 00 20 20 3c     /footer.html.  <
     bd5:	2f 62 6f 64 79 3e 0a 3c 2f 68 74 6d 6c 3e 00        /body>.</html>.

00000be4 <data_header_html>:
     be4:	2f 68 65 61 64 65 72 2e 68 74 6d 6c 00 3c 21 44     /header.html.<!D
     bf4:	4f 43 54 59 50 45 20 48 54 4d 4c 20 50 55 42 4c     OCTYPE HTML PUBL
     c04:	49 43 20 22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20     IC "-//W3C//DTD 
     c14:	48 54 4d 4c 20 34 2e 30 31 20 54 72 61 6e 73 69     HTML 4.01 Transi
     c24:	74 69 6f 6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74     tional//EN" "htt
     c34:	70 3a 2f 2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54     p://www.w3.org/T
     c44:	52 2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74     R/html4/loose.dt
     c54:	64 22 3e 0a 3c 68 74 6d 6c 3e 0a 20 20 3c 68 65     d">.<html>.  <he
     c64:	61 64 3e 0a 20 20 20 20 3c 74 69 74 6c 65 3e 57     ad>.    <title>W
     c74:	65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 75 49     elcome to the uI
     c84:	50 20 77 65 62 20 73 65 72 76 65 72 21 3c 2f 74     P web server!</t
     c94:	69 74 6c 65 3e 0a 20 20 20 20 3c 6c 69 6e 6b 20     itle>.    <link 
     ca4:	72 65 6c 3d 22 73 74 79 6c 65 73 68 65 65 74 22     rel="stylesheet"
     cb4:	20 74 79 70 65 3d 22 74 65 78 74 2f 63 73 73 22      type="text/css"
     cc4:	20 68 72 65 66 3d 22 73 74 79 6c 65 2e 63 73 73      href="style.css
     cd4:	22 3e 20 20 0a 20 20 3c 2f 68 65 61 64 3e 0a 20     ">  .  </head>. 
     ce4:	20 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72 3d 22      <body bgcolor="
     cf4:	23 66 66 66 65 65 63 22 20 74 65 78 74 3d 22 62     #fffeec" text="b
     d04:	6c 61 63 6b 22 3e 0a 0a 20 20 3c 64 69 76 20 63     lack">..  <div c
     d14:	6c 61 73 73 3d 22 6d 65 6e 75 22 3e 0a 20 20 3c     lass="menu">.  <
     d24:	64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62     div class="menub
     d34:	6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 2f 22 3e     ox"><a href="/">
     d44:	46 72 6f 6e 74 20 70 61 67 65 3c 2f 61 3e 3c 2f     Front page</a></
     d54:	64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73     div>.  <div clas
     d64:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
     d74:	72 65 66 3d 22 66 69 6c 65 73 2e 73 68 74 6d 6c     ref="files.shtml
     d84:	22 3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63     ">File statistic
     d94:	73 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20 3c 64     s</a></div>.  <d
     da4:	69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f     iv class="menubo
     db4:	78 22 3e 3c 61 20 68 72 65 66 3d 22 73 74 61 74     x"><a href="stat
     dc4:	73 2e 73 68 74 6d 6c 22 3e 4e 65 74 77 6f 72 6b     s.shtml">Network
     dd4:	20 73 74 61 74 69 73 74 69 63 73 3c 2f 61 3e 3c      statistics</a><
     de4:	2f 64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61     /div>.  <div cla
     df4:	73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20     ss="menubox"><a 
     e04:	68 72 65 66 3d 22 74 63 70 2e 73 68 74 6d 6c 22     href="tcp.shtml"
     e14:	3e 4e 65 74 77 6f 72 6b 0a 20 20 63 6f 6e 6e 65     >Network.  conne
     e24:	63 74 69 6f 6e 73 3c 2f 61 3e 3c 2f 64 69 76 3e     ctions</a></div>
     e34:	0a 20 20 3c 62 72 3e 0a 20 20 3c 2f 64 69 76 3e     .  <br>.  </div>
     e44:	0a 20 20 0a 20 20 3c 64 69 76 20 63 6c 61 73 73     .  .  <div class
     e54:	3d 22 63 6f 6e 74 65 6e 74 62 6c 6f 63 6b 22 3e     ="contentblock">
     e64:	0a 00                                               ..

00000e66 <data_index_html>:
     e66:	2f 69 6e 64 65 78 2e 68 74 6d 6c 00 3c 21 44 4f     /index.html.<!DO
     e76:	43 54 59 50 45 20 48 54 4d 4c 20 50 55 42 4c 49     CTYPE HTML PUBLI
     e86:	43 20 22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20 48     C "-//W3C//DTD H
     e96:	54 4d 4c 20 34 2e 30 31 20 54 72 61 6e 73 69 74     TML 4.01 Transit
     ea6:	69 6f 6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74 70     ional//EN" "http
     eb6:	3a 2f 2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54 52     ://www.w3.org/TR
     ec6:	2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74 64     /html4/loose.dtd
     ed6:	22 3e 0d 0a 3c 68 74 6d 6c 3e 0d 0a 20 20 3c 68     ">..<html>..  <h
     ee6:	65 61 64 3e 0d 0a 20 20 20 20 3c 74 69 74 6c 65     ead>..    <title
     ef6:	3e 57 65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20     >Welcome to the 
     f06:	75 49 50 20 77 65 62 20 73 65 72 76 65 72 21 3c     uIP web server!<
     f16:	2f 74 69 74 6c 65 3e 0d 0a 20 20 20 20 3c 6c 69     /title>..    <li
     f26:	6e 6b 20 72 65 6c 3d 22 73 74 79 6c 65 73 68 65     nk rel="styleshe
     f36:	65 74 22 20 74 79 70 65 3d 22 74 65 78 74 2f 63     et" type="text/c
     f46:	73 73 22 20 68 72 65 66 3d 22 73 74 79 6c 65 2e     ss" href="style.
     f56:	63 73 73 22 3e 20 20 0d 0a 20 20 3c 2f 68 65 61     css">  ..  </hea
     f66:	64 3e 0d 0a 20 20 3c 62 6f 64 79 20 62 67 63 6f     d>..  <body bgco
     f76:	6c 6f 72 3d 22 23 66 66 66 65 65 63 22 20 74 65     lor="#fffeec" te
     f86:	78 74 3d 22 62 6c 61 63 6b 22 3e 0d 0a 0d 0a 20     xt="black">.... 
     f96:	20 3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e      <div class="men
     fa6:	75 22 3e 0d 0a 20 20 3c 64 69 76 20 63 6c 61 73     u">..  <div clas
     fb6:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
     fc6:	72 65 66 3d 22 2f 22 3e 46 72 6f 6e 74 20 70 61     ref="/">Front pa
     fd6:	67 65 3c 2f 61 3e 3c 2f 64 69 76 3e 0d 0a 0d 0a     ge</a></div>....
     fe6:	20 20 3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65       <div class="me
     ff6:	6e 75 62 6f 78 22 3e 3c 61 20 68 72 65 66 3d 22     nubox"><a href="
    1006:	66 69 6c 65 73 2e 73 68 74 6d 6c 22 3e 46 69 6c     files.shtml">Fil
    1016:	65 20 73 74 61 74 69 73 74 69 63 73 3c 2f 61 3e     e statistics</a>
    1026:	3c 2f 64 69 76 3e 0d 0a 20 20 3c 64 69 76 20 63     </div>..  <div c
    1036:	6c 61 73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c     lass="menubox"><
    1046:	61 20 68 72 65 66 3d 22 73 74 61 74 73 2e 73 68     a href="stats.sh
    1056:	74 6d 6c 22 3e 4e 65 74 77 6f 72 6b 20 73 74 61     tml">Network sta
    1066:	74 69 73 74 69 63 73 3c 2f 61 3e 3c 2f 64 69 76     tistics</a></div
    1076:	3e 0d 0a 20 20 3c 64 69 76 20 63 6c 61 73 73 3d     >..  <div class=
    1086:	22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68 72 65     "menubox"><a hre
    1096:	66 3d 22 74 63 70 2e 73 68 74 6d 6c 22 3e 4e 65     f="tcp.shtml">Ne
    10a6:	74 77 6f 72 6b 20 63 6f 6e 6e 65 63 74 69 6f 6e     twork connection
    10b6:	73 3c 2f 61 3e 3c 2f 64 69 76 3e 0d 0a 09 3c 64     s</a></div>...<d
    10c6:	69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f     iv class="menubo
    10d6:	78 22 3e 3c 61 20 68 72 65 66 3d 22 69 6f 2e 73     x"><a href="io.s
    10e6:	68 74 6d 6c 22 3e 49 4f 3c 2f 61 3e 3c 2f 64 69     html">IO</a></di
    10f6:	76 3e 0d 0a 20 20 3c 62 72 3e 0d 0a 20 20 3c 2f     v>..  <br>..  </
    1106:	64 69 76 3e 0d 0a 0d 0a 20 20 3c 64 69 76 20 63     div>....  <div c
    1116:	6c 61 73 73 3d 22 63 6f 6e 74 65 6e 74 62 6c 6f     lass="contentblo
    1126:	63 6b 22 3e 0d 0a 20 20 3c 70 3e 0d 0a 53 74 65     ck">..  <p>..Ste
    1136:	66 61 6e 20 50 65 72 7a 62 6f 72 6e 27 73 20 43     fan Perzborn's C
    1146:	72 75 6d 62 36 34 34 2d 4e 45 54 20 57 65 62 73     rumb644-NET Webs
    1156:	65 72 76 65 72 20 65 78 61 6d 70 6c 65 20 76 31     erver example v1
    1166:	2e 33 2e 3c 62 72 3e 54 68 65 73 65 20 77 65 62     .3.<br>These web
    1176:	20 70 61 67 65 73 20 61 72 65 20 73 65 72 76 65      pages are serve
    1186:	64 20 62 79 20 61 20 73 6d 61 6c 6c 20 77 65 62     d by a small web
    1196:	20 73 65 72 76 65 72 20 72 75 6e 6e 69 6e 67 20      server running 
    11a6:	6f 6e 20 74 6f 70 20 6f 66 20 74 68 65 20 3c 61     on top of the <a
    11b6:	20 68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77      href="http://ww
    11c6:	77 2e 73 69 63 73 2e 73 65 2f 7e 61 64 61 6d 2f     w.sics.se/~adam/
    11d6:	75 69 70 2f 22 3e 75 49 50 20 65 6d 62 65 64 64     uip/">uIP embedd
    11e6:	65 64 20 54 43 50 2f 49 50 20 73 74 61 63 6b 3c     ed TCP/IP stack<
    11f6:	2f 61 3e 2e 3c 62 72 3e 0d 0a 50 6f 72 74 65 64     /a>.<br>..Ported
    1206:	20 74 6f 20 43 72 75 6d 62 36 34 34 2d 4e 45 54      to Crumb644-NET
    1216:	20 6d 6f 64 75 6c 65 20 62 79 20 53 74 65 66 61      module by Stefa
    1226:	6e 20 50 65 72 7a 62 6f 72 6e 20 3c 61 20 68 72     n Perzborn <a hr
    1236:	65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77 2e 70     ef="http://www.p
    1246:	65 72 7a 62 6f 72 6e 2e 6e 65 74 22 3e 28 77 77     erzborn.net">(ww
    1256:	77 2e 70 65 72 7a 62 6f 72 6e 2e 6e 65 74 29 3c     w.perzborn.net)<
    1266:	2f 61 0d 0a 20 20 3c 2f 70 3e 0d 0a 20 20 3c 70     /a..  </p>..  <p
    1276:	3e 0d 0a 20 20 43 6c 69 63 6b 20 6f 6e 20 74 68     >..  Click on th
    1286:	65 20 6c 69 6e 6b 73 20 61 62 6f 76 65 20 66 6f     e links above fo
    1296:	72 20 77 65 62 20 73 65 72 76 65 72 20 73 65 72     r web server ser
    12a6:	76 69 63 65 20 61 6e 64 20 73 74 61 74 69 73 74     vice and statist
    12b6:	69 63 73 2e 0d 0a 20 20 3c 2f 70 3e 0d 0a 20 20     ics...  </p>..  
    12c6:	3c 2f 62 6f 64 79 3e 0d 0a 3c 2f 68 74 6d 6c 3e     </body>..</html>
    12d6:	0d 0a 00                                            ...

000012d9 <data_style_css>:
    12d9:	2f 73 74 79 6c 65 2e 63 73 73 00 68 31 20 0a 7b     /style.css.h1 .{
    12e9:	0a 20 20 74 65 78 74 2d 61 6c 69 67 6e 3a 20 63     .  text-align: c
    12f9:	65 6e 74 65 72 3b 0a 20 20 66 6f 6e 74 2d 73 69     enter;.  font-si
    1309:	7a 65 3a 31 34 70 74 3b 0a 20 20 66 6f 6e 74 2d     ze:14pt;.  font-
    1319:	66 61 6d 69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c     family:arial,hel
    1329:	76 65 74 69 63 61 3b 0a 20 20 66 6f 6e 74 2d 77     vetica;.  font-w
    1339:	65 69 67 68 74 3a 62 6f 6c 64 3b 0a 20 20 70 61     eight:bold;.  pa
    1349:	64 64 69 6e 67 3a 31 30 70 78 3b 20 0a 7d 0a 0a     dding:10px; .}..
    1359:	62 6f 64 79 0a 7b 0a 0a 20 20 62 61 63 6b 67 72     body.{..  backgr
    1369:	6f 75 6e 64 2d 63 6f 6c 6f 72 3a 20 23 66 66 66     ound-color: #fff
    1379:	65 65 63 3b 0a 20 20 63 6f 6c 6f 72 3a 62 6c 61     eec;.  color:bla
    1389:	63 6b 3b 0a 0a 20 20 66 6f 6e 74 2d 73 69 7a 65     ck;..  font-size
    1399:	3a 38 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61 6d     :8pt;.  font-fam
    13a9:	69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c 76 65 74     ily:arial,helvet
    13b9:	69 63 61 3b 0a 7d 0a 0a 2e 6d 65 6e 75 0a 7b 0a     ica;.}...menu.{.
    13c9:	20 20 6d 61 72 67 69 6e 3a 20 34 70 78 3b 0a 20       margin: 4px;. 
    13d9:	20 77 69 64 74 68 3a 37 30 25 3b 0a 09 0a 20 20      width:70%;...  
    13e9:	70 61 64 64 69 6e 67 3a 32 30 70 78 3b 0a 09 0a     padding:20px;...
    13f9:	20 20 62 6f 72 64 65 72 3a 20 73 6f 6c 69 64 20       border: solid 
    1409:	31 70 78 3b 0a 20 20 62 61 63 6b 67 72 6f 75 6e     1px;.  backgroun
    1419:	64 2d 63 6f 6c 6f 72 3a 20 23 66 66 66 63 64 32     d-color: #fffcd2
    1429:	3b 0a 20 20 74 65 78 74 2d 61 6c 69 67 6e 3a 6c     ;.  text-align:l
    1439:	65 66 74 3b 0a 20 20 0a 20 20 66 6f 6e 74 2d 73     eft;.  .  font-s
    1449:	69 7a 65 3a 39 70 74 3b 0a 20 20 66 6f 6e 74 2d     ize:9pt;.  font-
    1459:	66 61 6d 69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c     family:arial,hel
    1469:	76 65 74 69 63 61 3b 20 20 0a 7d 0a 0a 64 69 76     vetica;  .}..div
    1479:	2e 6d 65 6e 75 62 6f 78 0a 7b 0a 20 20 77 69 64     .menubox.{.  wid
    1489:	74 68 3a 20 32 30 25 3b 0a 09 0a 20 20 62 6f 72     th: 20%;...  bor
    1499:	64 65 72 3a 20 30 3b 0a 20 20 66 6c 6f 61 74 3a     der: 0;.  float:
    14a9:	20 6c 65 66 74 3b 0a 74 65 78 74 2d 61 6c 69 67      left;.text-alig
    14b9:	6e 3a 20 63 65 6e 74 65 72 3b 0a 7d 0a 0a 2e 63     n: center;.}...c
    14c9:	6f 6e 74 65 6e 74 62 6c 6f 63 6b 0a 7b 20 20 0a     ontentblock.{  .
    14d9:	20 20 6d 61 72 67 69 6e 3a 20 34 70 78 3b 0a 20       margin: 4px;. 
    14e9:	20 77 69 64 74 68 3a 37 30 25 3b 0a 0a 20 20 70      width:70%;..  p
    14f9:	61 64 64 69 6e 67 3a 32 30 70 78 3b 0a 0a 20 20     adding:20px;..  
    1509:	62 6f 72 64 65 72 3a 20 31 70 78 20 64 6f 74 74     border: 1px dott
    1519:	65 64 3b 0a 20 20 62 61 63 6b 67 72 6f 75 6e 64     ed;.  background
    1529:	2d 63 6f 6c 6f 72 3a 20 77 68 69 74 65 3b 0a 0a     -color: white;..
    1539:	20 20 66 6f 6e 74 2d 73 69 7a 65 3a 38 70 74 3b       font-size:8pt;
    1549:	0a 20 20 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a 61     .  font-family:a
    1559:	72 69 61 6c 2c 68 65 6c 76 65 74 69 63 61 3b 20     rial,helvetica; 
    1569:	20 0a 0a 7d 0a 0a 70 2e 69 6e 74 72 6f 0a 7b 0a      ..}..p.intro.{.
    1579:	20 20 6d 61 72 67 69 6e 2d 6c 65 66 74 3a 32 30       margin-left:20
    1589:	70 78 3b 0a 20 20 6d 61 72 67 69 6e 2d 72 69 67     px;.  margin-rig
    1599:	68 74 3a 32 30 70 78 3b 0a 0a 20 20 66 6f 6e 74     ht:20px;..  font
    15a9:	2d 73 69 7a 65 3a 31 30 70 74 3b 0a 2f 2a 20 20     -size:10pt;./*  
    15b9:	66 6f 6e 74 2d 77 65 69 67 68 74 3a 62 6f 6c 64     font-weight:bold
    15c9:	3b 20 2a 2f 0a 20 20 66 6f 6e 74 2d 66 61 6d 69     ; */.  font-fami
    15d9:	6c 79 3a 61 72 69 61 6c 2c 68 65 6c 76 65 74 69     ly:arial,helveti
    15e9:	63 61 3b 20 20 0a 7d 0a 0a 70 2e 63 6c 69 6e 6b     ca;  .}..p.clink
    15f9:	0a 7b 0a 20 20 66 6f 6e 74 2d 73 69 7a 65 3a 31     .{.  font-size:1
    1609:	32 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61 6d 69     2pt;.  font-fami
    1619:	6c 79 3a 63 6f 75 72 69 65 72 2c 6d 6f 6e 6f 73     ly:courier,monos
    1629:	70 61 63 65 3b 20 20 0a 20 20 74 65 78 74 2d 61     pace;  .  text-a
    1639:	6c 69 67 6e 3a 63 65 6e 74 65 72 3b 0a 7d 0a 0a     lign:center;.}..
    1649:	70 2e 63 6c 69 6e 6b 39 0a 7b 0a 20 20 66 6f 6e     p.clink9.{.  fon
    1659:	74 2d 73 69 7a 65 3a 39 70 74 3b 0a 20 20 66 6f     t-size:9pt;.  fo
    1669:	6e 74 2d 66 61 6d 69 6c 79 3a 63 6f 75 72 69 65     nt-family:courie
    1679:	72 2c 6d 6f 6e 6f 73 70 61 63 65 3b 20 20 0a 20     r,monospace;  . 
    1689:	20 74 65 78 74 2d 61 6c 69 67 6e 3a 63 65 6e 74      text-align:cent
    1699:	65 72 3b 0a 7d 0a 0a 0a 70 0a 7b 0a 20 20 70 61     er;.}...p.{.  pa
    16a9:	64 64 69 6e 67 2d 6c 65 66 74 3a 31 30 70 78 3b     dding-left:10px;
    16b9:	0a 7d 0a 0a 70 2e 72 69 67 68 74 0a 7b 0a 20 20     .}..p.right.{.  
    16c9:	74 65 78 74 2d 61 6c 69 67 6e 3a 72 69 67 68 74     text-align:right
    16d9:	3b 20 0a 7d 0a 00                                   ; .}..

000016df <data_tcp_shtml>:
    16df:	2f 74 63 70 2e 73 68 74 6d 6c 00 25 21 3a 20 2f     /tcp.shtml.%!: /
    16ef:	68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68 31 3e     header.html.<h1>
    16ff:	43 75 72 72 65 6e 74 20 63 6f 6e 6e 65 63 74 69     Current connecti
    170f:	6f 6e 73 3c 2f 68 31 3e 3c 62 72 3e 3c 74 61 62     ons</h1><br><tab
    171f:	6c 65 20 77 69 64 74 68 3d 22 31 30 30 25 22 3e     le width="100%">
    172f:	0a 3c 74 72 3e 3c 74 68 3e 4c 6f 63 61 6c 3c 2f     .<tr><th>Local</
    173f:	74 68 3e 3c 74 68 3e 52 65 6d 6f 74 65 3c 2f 74     th><th>Remote</t
    174f:	68 3e 3c 74 68 3e 53 74 61 74 65 3c 2f 74 68 3e     h><th>State</th>
    175f:	3c 74 68 3e 52 65 74 72 61 6e 73 6d 69 73 73 69     <th>Retransmissi
    176f:	6f 6e 73 3c 2f 74 68 3e 3c 74 68 3e 54 69 6d 65     ons</th><th>Time
    177f:	72 3c 2f 74 68 3e 3c 74 68 3e 46 6c 61 67 73 3c     r</th><th>Flags<
    178f:	2f 74 68 3e 3c 2f 74 72 3e 0a 25 21 20 74 63 70     /th></tr>.%! tcp
    179f:	2d 63 6f 6e 6e 65 63 74 69 6f 6e 73 0a 25 21 3a     -connections.%!:
    17af:	20 2f 66 6f 6f 74 65 72 2e 68 74 6d 6c 0a 0a 00      /footer.html...

000017bf <data_fade_png>:
    17bf:	2f 66 61 64 65 2e 70 6e 67 00 89 50 4e 47 0d 0a     /fade.png..PNG..
    17cf:	1a 0a 00 00 00 0d 49 48 44 52 00 00 00 04 00 00     ......IHDR......
    17df:	00 0a 08 02 00 00 00 1c 99 68 59 00 00 00 09 70     .........hY....p
    17ef:	48 59 73 00 00 0b 13 00 00 0b 13 01 00 9a 9c 18     HYs.............
    17ff:	00 00 00 07 74 49 4d 45 07 d6 06 08 14 1b 39 af     ....tIME......9.
    180f:	5b c0 e3 00 00 00 1d 74 45 58 74 43 6f 6d 6d 65     [......tEXtComme
    181f:	6e 74 00 43 72 65 61 74 65 64 20 77 69 74 68 20     nt.Created with 
    182f:	54 68 65 20 47 49 4d 50 ef 64 25 6e 00 00 00 3a     The GIMP.d%n...:
    183f:	49 44 41 54 08 d7 75 8c 31 12 00 10 10 c4 2e 37     IDAT..u.1......7
    184f:	9e 40 65 fd ff 83 f4 0a 1c 8d 54 9b c9 cc 9a 3d     .@e.......T....=
    185f:	90 73 71 67 91 d4 74 36 a9 55 01 f8 29 58 c8 bf     .sqg..t6.U..)X..
    186f:	48 c4 81 74 0b a3 0f 7c db 04 e8 40 05 df a1 f3     H..t...|...@....
    187f:	fc 73 00 00 00 00 49 45 4e 44 ae 42 60 82 00        .s....IEND.B`..

0000188e <data_stats_shtml>:
    188e:	2f 73 74 61 74 73 2e 73 68 74 6d 6c 00 25 21 3a     /stats.shtml.%!:
    189e:	20 2f 68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68      /header.html.<h
    18ae:	31 3e 4e 65 74 77 6f 72 6b 20 73 74 61 74 69 73     1>Network statis
    18be:	74 69 63 73 3c 2f 68 31 3e 0a 3c 63 65 6e 74 65     tics</h1>.<cente
    18ce:	72 3e 0a 3c 74 61 62 6c 65 20 77 69 64 74 68 3d     r>.<table width=
    18de:	22 33 30 30 22 20 62 6f 72 64 65 72 3d 22 30 22     "300" border="0"
    18ee:	3e 0a 3c 74 72 3e 3c 74 64 3e 3c 70 72 65 3e 0a     >.<tr><td><pre>.
    18fe:	49 50 20 20 20 20 20 20 20 20 20 20 20 50 61 63     IP           Pac
    190e:	6b 65 74 73 20 72 65 63 65 69 76 65 64 0a 20 20     kets received.  
    191e:	20 20 20 20 20 20 20 20 20 20 20 50 61 63 6b 65                Packe
    192e:	74 73 20 73 65 6e 74 0a 09 20 20 20 20 20 50 61     ts sent..     Pa
    193e:	63 6b 65 74 73 20 64 72 6f 70 70 65 64 0a 49 50     ckets dropped.IP
    194e:	20 65 72 72 6f 72 73 20 20 20 20 49 50 20 76 65      errors    IP ve
    195e:	72 73 69 6f 6e 2f 68 65 61 64 65 72 20 6c 65 6e     rsion/header len
    196e:	67 74 68 0a 20 20 20 20 20 20 20 20 20 20 20 20     gth.            
    197e:	20 49 50 20 6c 65 6e 67 74 68 2c 20 68 69 67 68      IP length, high
    198e:	20 62 79 74 65 0a 20 20 20 20 20 20 20 20 20 20      byte.          
    199e:	20 20 20 49 50 20 6c 65 6e 67 74 68 2c 20 6c 6f        IP length, lo
    19ae:	77 20 62 79 74 65 0a 20 20 20 20 20 20 20 20 20     w byte.         
    19be:	20 20 20 20 49 50 20 66 72 61 67 6d 65 6e 74 73         IP fragments
    19ce:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 48 65     .             He
    19de:	61 64 65 72 20 63 68 65 63 6b 73 75 6d 0a 20 20     ader checksum.  
    19ee:	20 20 20 20 20 20 20 20 20 20 20 57 72 6f 6e 67                Wrong
    19fe:	20 70 72 6f 74 6f 63 6f 6c 0a 49 43 4d 50 09 20      protocol.ICMP. 
    1a0e:	20 20 20 20 50 61 63 6b 65 74 73 20 72 65 63 65         Packets rece
    1a1e:	69 76 65 64 0a 20 20 20 20 20 20 20 20 20 20 20     ived.           
    1a2e:	20 20 50 61 63 6b 65 74 73 20 73 65 6e 74 0a 20       Packets sent. 
    1a3e:	20 20 20 20 20 20 20 20 20 20 20 20 50 61 63 6b                 Pack
    1a4e:	65 74 73 20 64 72 6f 70 70 65 64 0a 20 20 20 20     ets dropped.    
    1a5e:	20 20 20 20 20 20 20 20 20 54 79 70 65 20 65 72              Type er
    1a6e:	72 6f 72 73 0a 54 43 50 20 20 20 20 20 20 20 20     rors.TCP        
    1a7e:	20 20 50 61 63 6b 65 74 73 20 72 65 63 65 69 76       Packets receiv
    1a8e:	65 64 0a 20 20 20 20 20 20 20 20 20 20 20 20 20     ed.             
    1a9e:	50 61 63 6b 65 74 73 20 73 65 6e 74 0a 20 20 20     Packets sent.   
    1aae:	20 20 20 20 20 20 20 20 20 20 50 61 63 6b 65 74               Packet
    1abe:	73 20 64 72 6f 70 70 65 64 0a 20 20 20 20 20 20     s dropped.      
    1ace:	20 20 20 20 20 20 20 43 68 65 63 6b 73 75 6d 20            Checksum 
    1ade:	65 72 72 6f 72 73 0a 20 20 20 20 20 20 20 20 20     errors.         
    1aee:	20 20 20 20 44 61 74 61 20 70 61 63 6b 65 74 73         Data packets
    1afe:	20 77 69 74 68 6f 75 74 20 41 43 4b 73 0a 20 20      without ACKs.  
    1b0e:	20 20 20 20 20 20 20 20 20 20 20 52 65 73 65 74                Reset
    1b1e:	73 0a 20 20 20 20 20 20 20 20 20 20 20 20 20 52     s.             R
    1b2e:	65 74 72 61 6e 73 6d 69 73 73 69 6f 6e 73 0a 09     etransmissions..
    1b3e:	20 20 20 20 20 4e 6f 20 63 6f 6e 6e 65 63 74 69          No connecti
    1b4e:	6f 6e 20 61 76 61 6c 69 61 62 6c 65 0a 09 20 20     on avaliable..  
    1b5e:	20 20 20 43 6f 6e 6e 65 63 74 69 6f 6e 20 61 74        Connection at
    1b6e:	74 65 6d 70 74 73 20 74 6f 20 63 6c 6f 73 65 64     tempts to closed
    1b7e:	20 70 6f 72 74 73 0a 3c 2f 70 72 65 3e 3c 2f 74      ports.</pre></t
    1b8e:	64 3e 3c 74 64 3e 3c 70 72 65 3e 25 21 20 6e 65     d><td><pre>%! ne
    1b9e:	74 2d 73 74 61 74 73 0a 3c 2f 70 72 65 3e 3c 2f     t-stats.</pre></
    1bae:	74 61 62 6c 65 3e 0a 3c 2f 63 65 6e 74 65 72 3e     table>.</center>
    1bbe:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
    1bce:	6c 0a 00                                            l..

00001bd1 <data_io_shtml>:
    1bd1:	2f 69 6f 2e 73 68 74 6d 6c 00 3c 21 44 4f 43 54     /io.shtml.<!DOCT
    1be1:	59 50 45 20 48 54 4d 4c 20 50 55 42 4c 49 43 20     YPE HTML PUBLIC 
    1bf1:	22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20 48 54 4d     "-//W3C//DTD HTM
    1c01:	4c 20 34 2e 30 31 20 54 72 61 6e 73 69 74 69 6f     L 4.01 Transitio
    1c11:	6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74 70 3a 2f     nal//EN" "http:/
    1c21:	2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54 52 2f 68     /www.w3.org/TR/h
    1c31:	74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74 64 22 3e     tml4/loose.dtd">
    1c41:	0a 3c 68 74 6d 6c 3e 0a 20 20 3c 68 65 61 64 3e     .<html>.  <head>
    1c51:	0a 20 20 20 20 3c 74 69 74 6c 65 3e 55 69 70 20     .    <title>Uip 
    1c61:	57 65 62 73 65 72 76 65 72 20 6f 75 74 70 75 74     Webserver output
    1c71:	20 64 65 6d 6f 3c 2f 74 69 74 6c 65 3e 0a 20 20      demo</title>.  
    1c81:	20 20 3c 6c 69 6e 6b 20 72 65 6c 3d 22 73 74 79       <link rel="sty
    1c91:	6c 65 73 68 65 65 74 22 20 74 79 70 65 3d 22 74     lesheet" type="t
    1ca1:	65 78 74 2f 63 73 73 22 20 68 72 65 66 3d 22 73     ext/css" href="s
    1cb1:	74 79 6c 65 2e 63 73 73 22 3e 20 20 0a 20 20 3c     tyle.css">  .  <
    1cc1:	2f 68 65 61 64 3e 0a 20 20 3c 62 6f 64 79 20 62     /head>.  <body b
    1cd1:	67 63 6f 6c 6f 72 3d 22 23 66 66 66 65 65 63 22     gcolor="#fffeec"
    1ce1:	20 74 65 78 74 3d 22 62 6c 61 63 6b 22 3e 0a 0a      text="black">..
    1cf1:	20 20 3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65       <div class="me
    1d01:	6e 75 22 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73     nu">.  <div clas
    1d11:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
    1d21:	72 65 66 3d 22 2f 22 3e 46 72 6f 6e 74 20 70 61     ref="/">Front pa
    1d31:	67 65 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20 3c     ge</a></div>.  <
    1d41:	64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62     div class="menub
    1d51:	6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 66 69 6c     ox"><a href="fil
    1d61:	65 73 2e 73 68 74 6d 6c 22 3e 46 69 6c 65 20 73     es.shtml">File s
    1d71:	74 61 74 69 73 74 69 63 73 3c 2f 61 3e 3c 2f 64     tatistics</a></d
    1d81:	69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73 73     iv>.  <div class
    1d91:	3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68 72     ="menubox"><a hr
    1da1:	65 66 3d 22 73 74 61 74 73 2e 73 68 74 6d 6c 22     ef="stats.shtml"
    1db1:	3e 4e 65 74 77 6f 72 6b 20 73 74 61 74 69 73 74     >Network statist
    1dc1:	69 63 73 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20     ics</a></div>.  
    1dd1:	3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75     <div class="menu
    1de1:	62 6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 74 63     box"><a href="tc
    1df1:	70 2e 73 68 74 6d 6c 22 3e 4e 65 74 77 6f 72 6b     p.shtml">Network
    1e01:	20 63 6f 6e 6e 65 63 74 69 6f 6e 73 3c 2f 61 3e      connections</a>
    1e11:	3c 2f 64 69 76 3e 0a 09 3c 64 69 76 20 63 6c 61     </div>..<div cla
    1e21:	73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20     ss="menubox"><a 
    1e31:	68 72 65 66 3d 22 69 6f 2e 73 68 74 6d 6c 22 3e     href="io.shtml">
    1e41:	49 4f 20 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20     IO </a></div>.  
    1e51:	3c 62 72 3e 0a 20 20 3c 2f 64 69 76 3e 0a 20 20     <br>.  </div>.  
    1e61:	3c 64 69 76 20 63 6c 61 73 73 3d 22 63 6f 6e 74     <div class="cont
    1e71:	65 6e 74 62 6c 6f 63 6b 22 3e 0a 09 3c 68 31 3e     entblock">..<h1>
    1e81:	53 77 69 74 63 68 20 4c 45 44 3c 2f 68 31 3e 0a     Switch LED</h1>.
    1e91:	09 3c 70 20 73 74 79 6c 65 3d 22 66 6f 6e 74 2d     .<p style="font-
    1ea1:	66 61 6d 69 6c 79 3a 41 72 69 61 6c 2c 73 61 6e     family:Arial,san
    1eb1:	73 2d 73 65 72 69 66 3b 20 66 6f 6e 74 2d 73 69     s-serif; font-si
    1ec1:	7a 65 3a 31 35 70 78 3b 20 63 6f 6c 6f 72 3a 62     ze:15px; color:b
    1ed1:	6c 75 65 22 3e 0a 09 09 5b 3c 61 20 68 72 65 66     lue">...[<a href
    1ee1:	3d 22 2f 69 6f 2e 73 68 74 6d 6c 3f 4c 45 44 31     ="/io.shtml?LED1
    1ef1:	3d 31 22 3e 67 72 65 65 6e 20 4c 45 44 20 4f 4e     =1">green LED ON
    1f01:	3c 2f 61 3e 5d 3c 62 72 3e 0a 09 3c 2f 70 3e 0a     </a>]<br>..</p>.
    1f11:	09 3c 70 3e 0a 09 09 3c 70 20 73 74 79 6c 65 3d     .<p>...<p style=
    1f21:	22 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a 41 72 69     "font-family:Ari
    1f31:	61 6c 2c 73 61 6e 73 2d 73 65 72 69 66 3b 20 66     al,sans-serif; f
    1f41:	6f 6e 74 2d 73 69 7a 65 3a 31 35 70 78 3b 20 63     ont-size:15px; c
    1f51:	6f 6c 6f 72 3a 62 6c 75 65 22 3e 0a 09 09 5b 3c     olor:blue">...[<
    1f61:	61 20 68 72 65 66 3d 22 2f 69 6f 2e 73 68 74 6d     a href="/io.shtm
    1f71:	6c 3f 4c 45 44 31 3d 30 22 3e 67 72 65 65 6e 20     l?LED1=0">green 
    1f81:	4c 45 44 20 4f 46 46 3c 2f 61 3e 5d 3c 62 72 3e     LED OFF</a>]<br>
    1f91:	0a 20 20 3c 2f 70 3e 0a 20 20 3c 2f 62 6f 64 79     .  </p>.  </body
    1fa1:	3e 0a 3c 2f 68 74 6d 6c 3e 0a 00                    >.</html>..

00001fac <__ctors_end>:
    1fac:	11 24       	eor	r1, r1
    1fae:	1f be       	out	0x3f, r1	; 63
    1fb0:	cf ef       	ldi	r28, 0xFF	; 255
    1fb2:	d0 e1       	ldi	r29, 0x10	; 16
    1fb4:	de bf       	out	0x3e, r29	; 62
    1fb6:	cd bf       	out	0x3d, r28	; 61

00001fb8 <__do_copy_data>:
    1fb8:	13 e0       	ldi	r17, 0x03	; 3
    1fba:	a0 e0       	ldi	r26, 0x00	; 0
    1fbc:	b1 e0       	ldi	r27, 0x01	; 1
    1fbe:	e2 e7       	ldi	r30, 0x72	; 114
    1fc0:	f5 e6       	ldi	r31, 0x65	; 101
    1fc2:	02 c0       	rjmp	.+4      	; 0x1fc8 <.do_copy_data_start>

00001fc4 <.do_copy_data_loop>:
    1fc4:	05 90       	lpm	r0, Z+
    1fc6:	0d 92       	st	X+, r0

00001fc8 <.do_copy_data_start>:
    1fc8:	aa 3a       	cpi	r26, 0xAA	; 170
    1fca:	b1 07       	cpc	r27, r17
    1fcc:	d9 f7       	brne	.-10     	; 0x1fc4 <.do_copy_data_loop>

00001fce <__do_clear_bss>:
    1fce:	1b e0       	ldi	r17, 0x0B	; 11
    1fd0:	aa ea       	ldi	r26, 0xAA	; 170
    1fd2:	b3 e0       	ldi	r27, 0x03	; 3
    1fd4:	01 c0       	rjmp	.+2      	; 0x1fd8 <.do_clear_bss_start>

00001fd6 <.do_clear_bss_loop>:
    1fd6:	1d 92       	st	X+, r1

00001fd8 <.do_clear_bss_start>:
    1fd8:	ac 3e       	cpi	r26, 0xEC	; 236
    1fda:	b1 07       	cpc	r27, r17
    1fdc:	e1 f7       	brne	.-8      	; 0x1fd6 <.do_clear_bss_loop>
    1fde:	0e 94 2d 13 	call	0x265a	; 0x265a <main>
    1fe2:	0c 94 b7 32 	jmp	0x656e	; 0x656e <_exit>

00001fe6 <__bad_interrupt>:
    1fe6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001fea <__vector_16>:
static char time;
//static char CP2200_status=0;
clock_time_t  sec_counter;

ISR(TIMER0_COMPA_vect)
{
    1fea:	1f 92       	push	r1
    1fec:	0f 92       	push	r0
    1fee:	0f b6       	in	r0, 0x3f	; 63
    1ff0:	0f 92       	push	r0
    1ff2:	11 24       	eor	r1, r1
    1ff4:	8f 93       	push	r24
    1ff6:	9f 93       	push	r25
	if (--time == 0)
    1ff8:	80 91 ab 03 	lds	r24, 0x03AB
    1ffc:	81 50       	subi	r24, 0x01	; 1
    1ffe:	80 93 ab 03 	sts	0x03AB, r24
    2002:	88 23       	and	r24, r24
    2004:	c1 f4       	brne	.+48     	; 0x2036 <__vector_16+0x4c>
	{
		// 1 Sekunden Timer
		time=75;
    2006:	8b e4       	ldi	r24, 0x4B	; 75
    2008:	80 93 ab 03 	sts	0x03AB, r24
		sec_counter++;
    200c:	80 91 63 04 	lds	r24, 0x0463
    2010:	90 91 64 04 	lds	r25, 0x0464
    2014:	01 96       	adiw	r24, 0x01	; 1
    2016:	90 93 64 04 	sts	0x0464, r25
    201a:	80 93 63 04 	sts	0x0463, r24
		if (toggle==0)
    201e:	80 91 aa 03 	lds	r24, 0x03AA
    2022:	88 23       	and	r24, r24
    2024:	29 f4       	brne	.+10     	; 0x2030 <__vector_16+0x46>
		{
			PORTC &= ~(1<<PC1); // clear PC1 = LED ON
    2026:	41 98       	cbi	0x08, 1	; 8
			toggle=1;
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	80 93 aa 03 	sts	0x03AA, r24
    202e:	03 c0       	rjmp	.+6      	; 0x2036 <__vector_16+0x4c>
		}
		else
		{
			PORTC |= (1<<PC1); // set PC1 = LED OFF
    2030:	41 9a       	sbi	0x08, 1	; 8
			toggle=0;	
    2032:	10 92 aa 03 	sts	0x03AA, r1
		}
	}
}
    2036:	9f 91       	pop	r25
    2038:	8f 91       	pop	r24
    203a:	0f 90       	pop	r0
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	0f 90       	pop	r0
    2040:	1f 90       	pop	r1
    2042:	18 95       	reti

00002044 <__vector_2>:



ISR(INT1_vect)
{
    2044:	1f 92       	push	r1
    2046:	0f 92       	push	r0
    2048:	0f b6       	in	r0, 0x3f	; 63
    204a:	0f 92       	push	r0
    204c:	11 24       	eor	r1, r1
	PORTB &= ~(1<<PB0); // clear PB0 = LED ON
    204e:	28 98       	cbi	0x05, 0	; 5
}
    2050:	0f 90       	pop	r0
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	0f 90       	pop	r0
    2056:	1f 90       	pop	r1
    2058:	18 95       	reti

0000205a <InitUART>:


void InitUART(void)
{
	UBRR0H = 0;
    205a:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = 64;
    205e:	80 e4       	ldi	r24, 0x40	; 64
    2060:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0) | (1<<TXEN0); // transmit & receive enable 
    2064:	88 e1       	ldi	r24, 0x18	; 24
    2066:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = 0x06; // init RS232: 8,N,1
    206a:	86 e0       	ldi	r24, 0x06	; 6
    206c:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0A = 0x00; 
    2070:	10 92 c0 00 	sts	0x00C0, r1
}
    2074:	08 95       	ret

00002076 <uart_putc_P>:
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    2076:	fc 01       	movw	r30, r24
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2078:	80 91 c0 00 	lds	r24, 0x00C0
    207c:	85 ff       	sbrs	r24, 5
    207e:	fc cf       	rjmp	.-8      	; 0x2078 <uart_putc_P+0x2>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2080:	84 91       	lpm	r24, Z+
    2082:	80 93 c6 00 	sts	0x00C6, r24
    return 0;
}
    2086:	80 e0       	ldi	r24, 0x00	; 0
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	08 95       	ret

0000208c <uart_putc>:

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
    208c:	98 2f       	mov	r25, r24
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    208e:	80 91 c0 00 	lds	r24, 0x00C0
    2092:	85 ff       	sbrs	r24, 5
    2094:	fc cf       	rjmp	.-8      	; 0x208e <uart_putc+0x2>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2096:	90 93 c6 00 	sts	0x00C6, r25
    return 0;
}
    209a:	80 e0       	ldi	r24, 0x00	; 0
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	08 95       	ret

000020a0 <uart_puts>:
 
void uart_puts (char *s)
{
    20a0:	fc 01       	movw	r30, r24
    20a2:	07 c0       	rjmp	.+14     	; 0x20b2 <uart_puts+0x12>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    20a4:	80 91 c0 00 	lds	r24, 0x00C0
    20a8:	85 ff       	sbrs	r24, 5
    20aa:	fc cf       	rjmp	.-8      	; 0x20a4 <uart_puts+0x4>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    20ac:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    20b0:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    20b2:	90 81       	ld	r25, Z
    20b4:	99 23       	and	r25, r25
    20b6:	b1 f7       	brne	.-20     	; 0x20a4 <uart_puts+0x4>
    {   
        uart_putc(*s);
        s++;
    }
} 
    20b8:	08 95       	ret

000020ba <uart_puts_P>:

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    20ba:	fc 01       	movw	r30, r24
    20bc:	08 c0       	rjmp	.+16     	; 0x20ce <uart_puts_P+0x14>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    20be:	80 91 c0 00 	lds	r24, 0x00C0
    20c2:	85 ff       	sbrs	r24, 5
    20c4:	fc cf       	rjmp	.-8      	; 0x20be <uart_puts_P+0x4>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    20c6:	84 91       	lpm	r24, Z+
    20c8:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    20cc:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    20ce:	84 91       	lpm	r24, Z+
    20d0:	88 23       	and	r24, r24
    20d2:	a9 f7       	brne	.-22     	; 0x20be <uart_puts_P+0x4>
    {   
        uart_putc_P(s);
        s++;
    }
} 
    20d4:	08 95       	ret

000020d6 <uart_getc>:

char uart_getc(void)
{
  while (!(UCSR0A & (1<<RXC0)));  // warten bis Zeichen verfuegbar
    20d6:	80 91 c0 00 	lds	r24, 0x00C0
    20da:	87 ff       	sbrs	r24, 7
    20dc:	fc cf       	rjmp	.-8      	; 0x20d6 <uart_getc>
    return UDR0;                   // Zeichen aus UDR an Aufrufer zurueckgeben
    20de:	80 91 c6 00 	lds	r24, 0x00C6
}
    20e2:	08 95       	ret

000020e4 <itohex>:



// itohex( hexstring, dezimalwert, anzahl der Stellen
void itohex(char *hexstr, int dez, char length)
{
    20e4:	dc 01       	movw	r26, r24
	char i=0;
	char tmp=0;
	if (length > 3)
    20e6:	44 30       	cpi	r20, 0x04	; 4
    20e8:	10 f4       	brcc	.+4      	; 0x20ee <itohex+0xa>
    20ea:	20 e0       	ldi	r18, 0x00	; 0
    20ec:	0a c0       	rjmp	.+20     	; 0x2102 <itohex+0x1e>
	{
		tmp=(dez & 0xF000) >> 12;
    20ee:	87 2f       	mov	r24, r23
    20f0:	82 95       	swap	r24
    20f2:	8f 70       	andi	r24, 0x0F	; 15
		if (tmp > 9)
    20f4:	8a 30       	cpi	r24, 0x0A	; 10
    20f6:	10 f0       	brcs	.+4      	; 0x20fc <itohex+0x18>
			hexstr[(int)i] = tmp + 'A' - 10;
    20f8:	89 5c       	subi	r24, 0xC9	; 201
    20fa:	01 c0       	rjmp	.+2      	; 0x20fe <itohex+0x1a>
		else
			hexstr[(int)i] = tmp + '0';
    20fc:	80 5d       	subi	r24, 0xD0	; 208
    20fe:	8c 93       	st	X, r24
    2100:	21 e0       	ldi	r18, 0x01	; 1
		i++;
	}
	if (length > 2)
    2102:	43 30       	cpi	r20, 0x03	; 3
    2104:	78 f0       	brcs	.+30     	; 0x2124 <itohex+0x40>
	{
		tmp=(dez & 0x0F00) >> 8;
    2106:	87 2f       	mov	r24, r23
    2108:	8f 70       	andi	r24, 0x0F	; 15
    210a:	e2 2f       	mov	r30, r18
    210c:	f0 e0       	ldi	r31, 0x00	; 0
		if (tmp > 9)
    210e:	8a 30       	cpi	r24, 0x0A	; 10
    2110:	20 f0       	brcs	.+8      	; 0x211a <itohex+0x36>
			hexstr[(int)i] = tmp + 'A' - 10;
    2112:	ea 0f       	add	r30, r26
    2114:	fb 1f       	adc	r31, r27
    2116:	89 5c       	subi	r24, 0xC9	; 201
    2118:	03 c0       	rjmp	.+6      	; 0x2120 <itohex+0x3c>
		else
			hexstr[(int)i] = tmp + '0';
    211a:	ea 0f       	add	r30, r26
    211c:	fb 1f       	adc	r31, r27
    211e:	80 5d       	subi	r24, 0xD0	; 208
    2120:	80 83       	st	Z, r24
		i++;
    2122:	2f 5f       	subi	r18, 0xFF	; 255
	}
	if (length > 1)
    2124:	42 30       	cpi	r20, 0x02	; 2
    2126:	a8 f0       	brcs	.+42     	; 0x2152 <itohex+0x6e>
	{
		tmp=(dez & 0x00F0) >> 4;
    2128:	cb 01       	movw	r24, r22
    212a:	80 7f       	andi	r24, 0xF0	; 240
    212c:	90 70       	andi	r25, 0x00	; 0
    212e:	34 e0       	ldi	r19, 0x04	; 4
    2130:	95 95       	asr	r25
    2132:	87 95       	ror	r24
    2134:	3a 95       	dec	r19
    2136:	e1 f7       	brne	.-8      	; 0x2130 <itohex+0x4c>
    2138:	e2 2f       	mov	r30, r18
    213a:	f0 e0       	ldi	r31, 0x00	; 0
		if (tmp > 9)
    213c:	8a 30       	cpi	r24, 0x0A	; 10
    213e:	20 f0       	brcs	.+8      	; 0x2148 <itohex+0x64>
			hexstr[(int)i] = tmp + 'A' - 10;		
    2140:	ea 0f       	add	r30, r26
    2142:	fb 1f       	adc	r31, r27
    2144:	89 5c       	subi	r24, 0xC9	; 201
    2146:	03 c0       	rjmp	.+6      	; 0x214e <itohex+0x6a>
		else
			hexstr[(int)i] = tmp + '0';
    2148:	ea 0f       	add	r30, r26
    214a:	fb 1f       	adc	r31, r27
    214c:	80 5d       	subi	r24, 0xD0	; 208
    214e:	80 83       	st	Z, r24
			
		i++;
    2150:	2f 5f       	subi	r18, 0xFF	; 255
	}
	if (length > 0)
    2152:	44 23       	and	r20, r20
    2154:	71 f0       	breq	.+28     	; 0x2172 <itohex+0x8e>
	{
		tmp=dez & 0x000F;
    2156:	6f 70       	andi	r22, 0x0F	; 15
    2158:	e2 2f       	mov	r30, r18
    215a:	f0 e0       	ldi	r31, 0x00	; 0
		if (tmp > 9)
    215c:	6a 30       	cpi	r22, 0x0A	; 10
    215e:	20 f0       	brcs	.+8      	; 0x2168 <itohex+0x84>
			hexstr[(int)i] = tmp + 'A' - 10;			
    2160:	ea 0f       	add	r30, r26
    2162:	fb 1f       	adc	r31, r27
    2164:	69 5c       	subi	r22, 0xC9	; 201
    2166:	03 c0       	rjmp	.+6      	; 0x216e <itohex+0x8a>
		else
			hexstr[(int)i] = tmp + '0';
    2168:	ea 0f       	add	r30, r26
    216a:	fb 1f       	adc	r31, r27
    216c:	60 5d       	subi	r22, 0xD0	; 208
    216e:	60 83       	st	Z, r22
		i++;
    2170:	2f 5f       	subi	r18, 0xFF	; 255
	} 
	hexstr[(int)i]=0;
    2172:	a2 0f       	add	r26, r18
    2174:	b1 1d       	adc	r27, r1
    2176:	1c 92       	st	X, r1
}
    2178:	08 95       	ret

0000217a <clock_init>:
}
*/

void clock_init(void)
{
	cli();
    217a:	f8 94       	cli
	// Timer0 init
	TCCR0A = 0x02;
    217c:	82 e0       	ldi	r24, 0x02	; 2
    217e:	84 bd       	out	0x24, r24	; 36
	TCCR0B = 0x05;
    2180:	95 e0       	ldi	r25, 0x05	; 5
    2182:	95 bd       	out	0x25, r25	; 37
	OCR0A = 0x80; // compare value
    2184:	90 e8       	ldi	r25, 0x80	; 128
    2186:	97 bd       	out	0x27, r25	; 39
	TIMSK0 = 0x02;
    2188:	80 93 6e 00 	sts	0x006E, r24
	sei();
    218c:	78 94       	sei
}
    218e:	08 95       	ret

00002190 <clock_time>:
	
clock_time_t clock_time(void)
{
	return(sec_counter);
}
    2190:	80 91 63 04 	lds	r24, 0x0463
    2194:	90 91 64 04 	lds	r25, 0x0464
    2198:	08 95       	ret

0000219a <uip_log>:

void uip_log(char *text)
{
	uart_puts(text);
    219a:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
}
    219e:	08 95       	ret

000021a0 <cmd_help>:
	}
} // cmd_netmask

void cmd_help(void)
{
	uart_puts_P(PSTR("\r\nAdam Dunkels uIP webserver example for Crumb644-NET\r\n"));
    21a0:	82 e3       	ldi	r24, 0x32	; 50
    21a2:	92 e0       	ldi	r25, 0x02	; 2
    21a4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
    21a8:	88 ef       	ldi	r24, 0xF8	; 248
    21aa:	91 e0       	ldi	r25, 0x01	; 1
    21ac:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
    21b0:	8a ed       	ldi	r24, 0xDA	; 218
    21b2:	91 e0       	ldi	r25, 0x01	; 1
    21b4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
    21b8:	87 eb       	ldi	r24, 0xB7	; 183
    21ba:	91 e0       	ldi	r25, 0x01	; 1
    21bc:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
    21c0:	8c e9       	ldi	r24, 0x9C	; 156
    21c2:	91 e0       	ldi	r25, 0x01	; 1
    21c4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR(" Commands: \r\n"));
    21c8:	8e e8       	ldi	r24, 0x8E	; 142
    21ca:	91 e0       	ldi	r25, 0x01	; 1
    21cc:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR("  CPRESET                     // reinitialize ethernet controller \r\n"));
    21d0:	89 e4       	ldi	r24, 0x49	; 73
    21d2:	91 e0       	ldi	r25, 0x01	; 1
    21d4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR("  IP <xxx.xxx.xxx.xxx>        // display / set IP address\r\n"));
    21d8:	8d e0       	ldi	r24, 0x0D	; 13
    21da:	91 e0       	ldi	r25, 0x01	; 1
    21dc:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR("  NETMASK <xxx.xxx.xxx.xxx>   // display / set netmask\r\n"));
    21e0:	84 ed       	ldi	r24, 0xD4	; 212
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	uart_puts_P(PSTR("  \r\n"));
    21e8:	8f ec       	ldi	r24, 0xCF	; 207
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    21f0:	84 ef       	ldi	r24, 0xF4	; 244
    21f2:	91 e0       	ldi	r25, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    21f4:	24 ef       	ldi	r18, 0xF4	; 244
    21f6:	31 e0       	ldi	r19, 0x01	; 1
    21f8:	f9 01       	movw	r30, r18
    21fa:	31 97       	sbiw	r30, 0x01	; 1
    21fc:	f1 f7       	brne	.-4      	; 0x21fa <cmd_help+0x5a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    21fe:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2200:	d9 f7       	brne	.-10     	; 0x21f8 <cmd_help+0x58>
	_delay_ms(50);
}
    2202:	08 95       	ret

00002204 <cmd_netmask>:
		uip_sethostaddr(ipaddr);			
	}
} // cmd_ip

void cmd_netmask(char *ipstr)
{
    2204:	cf 92       	push	r12
    2206:	df 92       	push	r13
    2208:	ef 92       	push	r14
    220a:	ff 92       	push	r15
    220c:	0f 93       	push	r16
    220e:	1f 93       	push	r17
    2210:	df 93       	push	r29
    2212:	cf 93       	push	r28
    2214:	cd b7       	in	r28, 0x3d	; 61
    2216:	de b7       	in	r29, 0x3e	; 62
    2218:	2e 97       	sbiw	r28, 0x0e	; 14
    221a:	0f b6       	in	r0, 0x3f	; 63
    221c:	f8 94       	cli
    221e:	de bf       	out	0x3e, r29	; 62
    2220:	0f be       	out	0x3f, r0	; 63
    2222:	cd bf       	out	0x3d, r28	; 61
    2224:	8c 01       	movw	r16, r24
	char *tmp=0;
	unsigned char i=0;
	uip_ipaddr_t ipaddr;
	//struct uip_eth_addr eaddr;
	i=0;
	uip_getnetmask(&ipaddr);
    2226:	80 91 00 06 	lds	r24, 0x0600
    222a:	90 91 01 06 	lds	r25, 0x0601
    222e:	9a 83       	std	Y+2, r25	; 0x02
    2230:	89 83       	std	Y+1, r24	; 0x01
    2232:	80 91 02 06 	lds	r24, 0x0602
    2236:	90 91 03 06 	lds	r25, 0x0603
    223a:	9c 83       	std	Y+4, r25	; 0x04
    223c:	8b 83       	std	Y+3, r24	; 0x03
	ip = (char *) &ipaddr;
    223e:	6e 01       	movw	r12, r28
    2240:	08 94       	sec
    2242:	c1 1c       	adc	r12, r1
    2244:	d1 1c       	adc	r13, r1
	
	if (*ipstr == 0)
    2246:	f8 01       	movw	r30, r16
    2248:	80 81       	ld	r24, Z
    224a:	88 23       	and	r24, r24
    224c:	19 f0       	breq	.+6      	; 0x2254 <cmd_netmask+0x50>
    224e:	c8 01       	movw	r24, r16
    2250:	ff 24       	eor	r15, r15
    2252:	39 c0       	rjmp	.+114    	; 0x22c6 <cmd_netmask+0xc2>
	{
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
    2254:	8e 01       	movw	r16, r28
    2256:	0b 5f       	subi	r16, 0xFB	; 251
    2258:	1f 4f       	sbci	r17, 0xFF	; 255
    225a:	89 81       	ldd	r24, Y+1	; 0x01
    225c:	90 e0       	ldi	r25, 0x00	; 0
    225e:	b8 01       	movw	r22, r16
    2260:	4a e0       	ldi	r20, 0x0A	; 10
    2262:	50 e0       	ldi	r21, 0x00	; 0
    2264:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <itoa>
    2268:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
    226c:	76 01       	movw	r14, r12
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa(ip[i],tmpstr,10));
    226e:	68 01       	movw	r12, r16
	if (*ipstr == 0)
	{
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    2270:	8e 01       	movw	r16, r28
    2272:	0c 5f       	subi	r16, 0xFC	; 252
    2274:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			uart_puts_P(PSTR("."));
    2276:	8d e6       	ldi	r24, 0x6D	; 109
    2278:	92 e0       	ldi	r25, 0x02	; 2
    227a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
			uart_puts(itoa(ip[i],tmpstr,10));
    227e:	f7 01       	movw	r30, r14
    2280:	81 81       	ldd	r24, Z+1	; 0x01
    2282:	90 e0       	ldi	r25, 0x00	; 0
    2284:	b6 01       	movw	r22, r12
    2286:	4a e0       	ldi	r20, 0x0A	; 10
    2288:	50 e0       	ldi	r21, 0x00	; 0
    228a:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <itoa>
    228e:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
    2292:	08 94       	sec
    2294:	e1 1c       	adc	r14, r1
    2296:	f1 1c       	adc	r15, r1
	if (*ipstr == 0)
	{
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    2298:	e0 16       	cp	r14, r16
    229a:	f1 06       	cpc	r15, r17
    229c:	61 f7       	brne	.-40     	; 0x2276 <cmd_netmask+0x72>
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa(ip[i],tmpstr,10));
		}
		uart_puts_P(PSTR("\r\n"));
    229e:	8a e6       	ldi	r24, 0x6A	; 106
    22a0:	92 e0       	ldi	r25, 0x02	; 2
    22a2:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    22a6:	33 c0       	rjmp	.+102    	; 0x230e <cmd_netmask+0x10a>
		// set netmask
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
		{
			if (*ipstr=='.') 
    22a8:	2e 32       	cpi	r18, 0x2E	; 46
    22aa:	59 f4       	brne	.+22     	; 0x22c2 <cmd_netmask+0xbe>
			{	
				*ipstr=0;
    22ac:	f8 01       	movw	r30, r16
    22ae:	10 82       	st	Z, r1
				ip[i++]=atoi(tmp);
    22b0:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <atoi>
    22b4:	f6 01       	movw	r30, r12
    22b6:	ef 0d       	add	r30, r15
    22b8:	f1 1d       	adc	r31, r1
    22ba:	80 83       	st	Z, r24
    22bc:	f3 94       	inc	r15
    22be:	c8 01       	movw	r24, r16
    22c0:	01 96       	adiw	r24, 0x01	; 1
	else
	{
		// set netmask
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
    22c2:	0f 5f       	subi	r16, 0xFF	; 255
    22c4:	1f 4f       	sbci	r17, 0xFF	; 255
    22c6:	f8 01       	movw	r30, r16
    22c8:	20 81       	ld	r18, Z
    22ca:	22 23       	and	r18, r18
    22cc:	19 f0       	breq	.+6      	; 0x22d4 <cmd_netmask+0xd0>
    22ce:	f3 e0       	ldi	r31, 0x03	; 3
    22d0:	ff 15       	cp	r31, r15
    22d2:	50 f7       	brcc	.-44     	; 0x22a8 <cmd_netmask+0xa4>
				*ipstr=0;
				ip[i++]=atoi(tmp);
				tmp = ipstr + 1;
			}
		}
		*ipstr=0;
    22d4:	f8 01       	movw	r30, r16
    22d6:	10 82       	st	Z, r1
		ip[i]=atoi(tmp);
    22d8:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <atoi>
    22dc:	f6 01       	movw	r30, r12
    22de:	ef 0d       	add	r30, r15
    22e0:	f1 1d       	adc	r31, r1
    22e2:	80 83       	st	Z, r24
		uip_ipaddr(ipaddr, ip[0],ip[1],ip[2],ip[3]);
    22e4:	f6 01       	movw	r30, r12
    22e6:	92 81       	ldd	r25, Z+2	; 0x02
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	43 81       	ldd	r20, Z+3	; 0x03
    22ec:	50 e0       	ldi	r21, 0x00	; 0
    22ee:	48 2b       	or	r20, r24
    22f0:	59 2b       	or	r21, r25
		uip_setnetmask(ipaddr);			
    22f2:	21 81       	ldd	r18, Z+1	; 0x01
    22f4:	30 e0       	ldi	r19, 0x00	; 0
    22f6:	90 81       	ld	r25, Z
    22f8:	80 e0       	ldi	r24, 0x00	; 0
    22fa:	28 2b       	or	r18, r24
    22fc:	39 2b       	or	r19, r25
    22fe:	30 93 00 06 	sts	0x0600, r19
    2302:	20 93 01 06 	sts	0x0601, r18
    2306:	50 93 02 06 	sts	0x0602, r21
    230a:	40 93 03 06 	sts	0x0603, r20
	}
} // cmd_netmask
    230e:	2e 96       	adiw	r28, 0x0e	; 14
    2310:	0f b6       	in	r0, 0x3f	; 63
    2312:	f8 94       	cli
    2314:	de bf       	out	0x3e, r29	; 62
    2316:	0f be       	out	0x3f, r0	; 63
    2318:	cd bf       	out	0x3d, r28	; 61
    231a:	cf 91       	pop	r28
    231c:	df 91       	pop	r29
    231e:	1f 91       	pop	r17
    2320:	0f 91       	pop	r16
    2322:	ff 90       	pop	r15
    2324:	ef 90       	pop	r14
    2326:	df 90       	pop	r13
    2328:	cf 90       	pop	r12
    232a:	08 95       	ret

0000232c <cmd_ip>:
	return(i);
}


void cmd_ip(char *ipstr)
{
    232c:	cf 92       	push	r12
    232e:	df 92       	push	r13
    2330:	ef 92       	push	r14
    2332:	ff 92       	push	r15
    2334:	0f 93       	push	r16
    2336:	1f 93       	push	r17
    2338:	df 93       	push	r29
    233a:	cf 93       	push	r28
    233c:	cd b7       	in	r28, 0x3d	; 61
    233e:	de b7       	in	r29, 0x3e	; 62
    2340:	2e 97       	sbiw	r28, 0x0e	; 14
    2342:	0f b6       	in	r0, 0x3f	; 63
    2344:	f8 94       	cli
    2346:	de bf       	out	0x3e, r29	; 62
    2348:	0f be       	out	0x3f, r0	; 63
    234a:	cd bf       	out	0x3d, r28	; 61
    234c:	8c 01       	movw	r16, r24
	char *tmp=0;
	unsigned char i=0;
	uip_ipaddr_t ipaddr;
	//		struct uip_eth_addr eaddr;
	i=0;
	uip_gethostaddr(&ipaddr);
    234e:	80 91 04 06 	lds	r24, 0x0604
    2352:	90 91 05 06 	lds	r25, 0x0605
    2356:	9a 83       	std	Y+2, r25	; 0x02
    2358:	89 83       	std	Y+1, r24	; 0x01
    235a:	80 91 06 06 	lds	r24, 0x0606
    235e:	90 91 07 06 	lds	r25, 0x0607
    2362:	9c 83       	std	Y+4, r25	; 0x04
    2364:	8b 83       	std	Y+3, r24	; 0x03
	ip = (char *) &ipaddr;
    2366:	6e 01       	movw	r12, r28
    2368:	08 94       	sec
    236a:	c1 1c       	adc	r12, r1
    236c:	d1 1c       	adc	r13, r1

	if (*ipstr == 0)
    236e:	f8 01       	movw	r30, r16
    2370:	80 81       	ld	r24, Z
    2372:	88 23       	and	r24, r24
    2374:	19 f0       	breq	.+6      	; 0x237c <cmd_ip+0x50>
    2376:	c8 01       	movw	r24, r16
    2378:	ff 24       	eor	r15, r15
    237a:	39 c0       	rjmp	.+114    	; 0x23ee <cmd_ip+0xc2>
	{
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
    237c:	8e 01       	movw	r16, r28
    237e:	0b 5f       	subi	r16, 0xFB	; 251
    2380:	1f 4f       	sbci	r17, 0xFF	; 255
    2382:	89 81       	ldd	r24, Y+1	; 0x01
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	b8 01       	movw	r22, r16
    2388:	4a e0       	ldi	r20, 0x0A	; 10
    238a:	50 e0       	ldi	r21, 0x00	; 0
    238c:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <itoa>
    2390:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
    2394:	76 01       	movw	r14, r12
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa((unsigned char) ip[i],tmpstr,10));
    2396:	68 01       	movw	r12, r16
	if (*ipstr == 0)
	{
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    2398:	8e 01       	movw	r16, r28
    239a:	0c 5f       	subi	r16, 0xFC	; 252
    239c:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			uart_puts_P(PSTR("."));
    239e:	82 e7       	ldi	r24, 0x72	; 114
    23a0:	92 e0       	ldi	r25, 0x02	; 2
    23a2:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
			uart_puts(itoa((unsigned char) ip[i],tmpstr,10));
    23a6:	f7 01       	movw	r30, r14
    23a8:	81 81       	ldd	r24, Z+1	; 0x01
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	b6 01       	movw	r22, r12
    23ae:	4a e0       	ldi	r20, 0x0A	; 10
    23b0:	50 e0       	ldi	r21, 0x00	; 0
    23b2:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <itoa>
    23b6:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
    23ba:	08 94       	sec
    23bc:	e1 1c       	adc	r14, r1
    23be:	f1 1c       	adc	r15, r1
	if (*ipstr == 0)
	{
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    23c0:	e0 16       	cp	r14, r16
    23c2:	f1 06       	cpc	r15, r17
    23c4:	61 f7       	brne	.-40     	; 0x239e <cmd_ip+0x72>
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa((unsigned char) ip[i],tmpstr,10));
		}
		uart_puts_P(PSTR("\r\n"));
    23c6:	8f e6       	ldi	r24, 0x6F	; 111
    23c8:	92 e0       	ldi	r25, 0x02	; 2
    23ca:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    23ce:	33 c0       	rjmp	.+102    	; 0x2436 <cmd_ip+0x10a>
		// set ip address
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
		{
			if (*ipstr=='.') 
    23d0:	2e 32       	cpi	r18, 0x2E	; 46
    23d2:	59 f4       	brne	.+22     	; 0x23ea <cmd_ip+0xbe>
			{	
				*ipstr=0;
    23d4:	f8 01       	movw	r30, r16
    23d6:	10 82       	st	Z, r1
				ip[i++]=atoi(tmp);
    23d8:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <atoi>
    23dc:	f6 01       	movw	r30, r12
    23de:	ef 0d       	add	r30, r15
    23e0:	f1 1d       	adc	r31, r1
    23e2:	80 83       	st	Z, r24
    23e4:	f3 94       	inc	r15
    23e6:	c8 01       	movw	r24, r16
    23e8:	01 96       	adiw	r24, 0x01	; 1
	else
	{
		// set ip address
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
    23ea:	0f 5f       	subi	r16, 0xFF	; 255
    23ec:	1f 4f       	sbci	r17, 0xFF	; 255
    23ee:	f8 01       	movw	r30, r16
    23f0:	20 81       	ld	r18, Z
    23f2:	22 23       	and	r18, r18
    23f4:	19 f0       	breq	.+6      	; 0x23fc <cmd_ip+0xd0>
    23f6:	f3 e0       	ldi	r31, 0x03	; 3
    23f8:	ff 15       	cp	r31, r15
    23fa:	50 f7       	brcc	.-44     	; 0x23d0 <cmd_ip+0xa4>
				*ipstr=0;
				ip[i++]=atoi(tmp);
				tmp = ipstr + 1;
			}
		}
		*ipstr=0;
    23fc:	f8 01       	movw	r30, r16
    23fe:	10 82       	st	Z, r1
		ip[i]=atoi(tmp);
    2400:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <atoi>
    2404:	f6 01       	movw	r30, r12
    2406:	ef 0d       	add	r30, r15
    2408:	f1 1d       	adc	r31, r1
    240a:	80 83       	st	Z, r24
		uip_ipaddr(ipaddr, ip[0],ip[1],ip[2],ip[3]);
    240c:	f6 01       	movw	r30, r12
    240e:	92 81       	ldd	r25, Z+2	; 0x02
    2410:	80 e0       	ldi	r24, 0x00	; 0
    2412:	43 81       	ldd	r20, Z+3	; 0x03
    2414:	50 e0       	ldi	r21, 0x00	; 0
    2416:	48 2b       	or	r20, r24
    2418:	59 2b       	or	r21, r25
		uip_sethostaddr(ipaddr);			
    241a:	21 81       	ldd	r18, Z+1	; 0x01
    241c:	30 e0       	ldi	r19, 0x00	; 0
    241e:	90 81       	ld	r25, Z
    2420:	80 e0       	ldi	r24, 0x00	; 0
    2422:	28 2b       	or	r18, r24
    2424:	39 2b       	or	r19, r25
    2426:	30 93 04 06 	sts	0x0604, r19
    242a:	20 93 05 06 	sts	0x0605, r18
    242e:	50 93 06 06 	sts	0x0606, r21
    2432:	40 93 07 06 	sts	0x0607, r20
	}
} // cmd_ip
    2436:	2e 96       	adiw	r28, 0x0e	; 14
    2438:	0f b6       	in	r0, 0x3f	; 63
    243a:	f8 94       	cli
    243c:	de bf       	out	0x3e, r29	; 62
    243e:	0f be       	out	0x3f, r0	; 63
    2440:	cd bf       	out	0x3d, r28	; 61
    2442:	cf 91       	pop	r28
    2444:	df 91       	pop	r29
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	ff 90       	pop	r15
    244c:	ef 90       	pop	r14
    244e:	df 90       	pop	r13
    2450:	cf 90       	pop	r12
    2452:	08 95       	ret

00002454 <parse>:
	uart_puts_P(PSTR("  \r\n"));
	_delay_ms(50);
}

void parse(char *zeile)
{
    2454:	ef 92       	push	r14
    2456:	ff 92       	push	r15
    2458:	0f 93       	push	r16
    245a:	1f 93       	push	r17
    245c:	df 93       	push	r29
    245e:	cf 93       	push	r28
    2460:	cd b7       	in	r28, 0x3d	; 61
    2462:	de b7       	in	r29, 0x3e	; 62
    2464:	c0 5a       	subi	r28, 0xA0	; 160
    2466:	d0 40       	sbci	r29, 0x00	; 0
    2468:	0f b6       	in	r0, 0x3f	; 63
    246a:	f8 94       	cli
    246c:	de bf       	out	0x3e, r29	; 62
    246e:	0f be       	out	0x3f, r0	; 63
    2470:	cd bf       	out	0x3d, r28	; 61
    2472:	ac 01       	movw	r20, r24
    2474:	de 01       	movw	r26, r28
    2476:	11 96       	adiw	r26, 0x01	; 1
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	ee 24       	eor	r14, r14
    247c:	ff 24       	eor	r15, r15
    247e:	01 c0       	rjmp	.+2      	; 0x2482 <parse+0x2e>
	// argc = Anzahl der Teilstrings (1..10) 
	// Bei keiner Eingabe (nur Enter) ist argc = 1
	for(;argc<10;)
	{
		// fhrende Leerzeichen berlesen (oder Ende)
		for(;((*(zeile+i) <=' ')&&(*(zeile+i) !=0));i++);
    2480:	9f 5f       	subi	r25, 0xFF	; 255
    2482:	fa 01       	movw	r30, r20
    2484:	e9 0f       	add	r30, r25
    2486:	f1 1d       	adc	r31, r1
    2488:	20 81       	ld	r18, Z
    248a:	82 2f       	mov	r24, r18
    248c:	81 50       	subi	r24, 0x01	; 1
    248e:	80 32       	cpi	r24, 0x20	; 32
    2490:	b8 f3       	brcs	.-18     	; 0x2480 <parse+0x2c>
		argv[argc++]=zeile+i;  // pointer auf Teilstring
    2492:	11 96       	adiw	r26, 0x01	; 1
    2494:	fc 93       	st	X, r31
    2496:	ee 93       	st	-X, r30
    2498:	08 94       	sec
    249a:	e1 1c       	adc	r14, r1
    249c:	f1 1c       	adc	r15, r1
		if (*(zeile+i) ==0) break;
    249e:	22 23       	and	r18, r18
    24a0:	11 f4       	brne	.+4      	; 0x24a6 <parse+0x52>
    24a2:	1a c0       	rjmp	.+52     	; 0x24d8 <parse+0x84>
		// bis nchsten Leerzeichen lesen (oder Ende)
		for(;((*(zeile+i) >' ')&&(*zeile+i !=0));i++);
    24a4:	9f 5f       	subi	r25, 0xFF	; 255
    24a6:	29 2f       	mov	r18, r25
    24a8:	30 e0       	ldi	r19, 0x00	; 0
    24aa:	ba 01       	movw	r22, r20
    24ac:	62 0f       	add	r22, r18
    24ae:	73 1f       	adc	r23, r19
    24b0:	fb 01       	movw	r30, r22
    24b2:	80 81       	ld	r24, Z
    24b4:	81 32       	cpi	r24, 0x21	; 33
    24b6:	18 f4       	brcc	.+6      	; 0x24be <parse+0x6a>
		if (*(zeile+i)==0) break;
    24b8:	88 23       	and	r24, r24
    24ba:	39 f4       	brne	.+14     	; 0x24ca <parse+0x76>
    24bc:	0d c0       	rjmp	.+26     	; 0x24d8 <parse+0x84>
		// fhrende Leerzeichen berlesen (oder Ende)
		for(;((*(zeile+i) <=' ')&&(*(zeile+i) !=0));i++);
		argv[argc++]=zeile+i;  // pointer auf Teilstring
		if (*(zeile+i) ==0) break;
		// bis nchsten Leerzeichen lesen (oder Ende)
		for(;((*(zeile+i) >' ')&&(*zeile+i !=0));i++);
    24be:	fa 01       	movw	r30, r20
    24c0:	80 81       	ld	r24, Z
    24c2:	28 0f       	add	r18, r24
    24c4:	31 1d       	adc	r19, r1
    24c6:	23 2b       	or	r18, r19
    24c8:	69 f7       	brne	.-38     	; 0x24a4 <parse+0x50>
		if (*(zeile+i)==0) break;
		*(zeile+i) =0; // Teilsstring terminieren
    24ca:	fb 01       	movw	r30, r22
    24cc:	10 82       	st	Z, r1
    24ce:	12 96       	adiw	r26, 0x02	; 2
	// Eingabestrings in Teilstrings wandeln
	// Trennzeichen = Leerzeichen
	// argv[0..9] = Teilstrings (Nullterminiert) 
	// argc = Anzahl der Teilstrings (1..10) 
	// Bei keiner Eingabe (nur Enter) ist argc = 1
	for(;argc<10;)
    24d0:	fa e0       	ldi	r31, 0x0A	; 10
    24d2:	ef 16       	cp	r14, r31
    24d4:	f1 04       	cpc	r15, r1
    24d6:	a1 f6       	brne	.-88     	; 0x2480 <parse+0x2c>
		if (*(zeile+i)==0) break;
		*(zeile+i) =0; // Teilsstring terminieren
		i++;
  }
		
	pcmd=argv[0];
    24d8:	19 81       	ldd	r17, Y+1	; 0x01
    24da:	0a 81       	ldd	r16, Y+2	; 0x02
	strupr(pcmd);
    24dc:	81 2f       	mov	r24, r17
    24de:	90 2f       	mov	r25, r16
    24e0:	0e 94 7b 2f 	call	0x5ef6	; 0x5ef6 <strupr>
	if ((strcmp_P(pcmd,PSTR("IP"))==0) && (strlen(pcmd) == 2))
    24e4:	81 2f       	mov	r24, r17
    24e6:	90 2f       	mov	r25, r16
    24e8:	6c ec       	ldi	r22, 0xCC	; 204
    24ea:	70 e0       	ldi	r23, 0x00	; 0
    24ec:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <strcmp_P>
    24f0:	89 2b       	or	r24, r25
    24f2:	a9 f4       	brne	.+42     	; 0x251e <parse+0xca>
    24f4:	a1 2f       	mov	r26, r17
    24f6:	b0 2f       	mov	r27, r16
    24f8:	fd 01       	movw	r30, r26
    24fa:	01 90       	ld	r0, Z+
    24fc:	00 20       	and	r0, r0
    24fe:	e9 f7       	brne	.-6      	; 0x24fa <parse+0xa6>
    2500:	33 97       	sbiw	r30, 0x03	; 3
    2502:	ea 17       	cp	r30, r26
    2504:	fb 07       	cpc	r31, r27
    2506:	59 f4       	brne	.+22     	; 0x251e <parse+0xca>
	{
		if (argc>1)
    2508:	81 e0       	ldi	r24, 0x01	; 1
    250a:	e8 16       	cp	r14, r24
    250c:	f1 04       	cpc	r15, r1
    250e:	19 f0       	breq	.+6      	; 0x2516 <parse+0xc2>
			cmd_ip(argv[1]);
    2510:	8b 81       	ldd	r24, Y+3	; 0x03
    2512:	9c 81       	ldd	r25, Y+4	; 0x04
    2514:	02 c0       	rjmp	.+4      	; 0x251a <parse+0xc6>
		else
			cmd_ip("");
    2516:	80 e0       	ldi	r24, 0x00	; 0
    2518:	91 e0       	ldi	r25, 0x01	; 1
    251a:	0e 94 96 11 	call	0x232c	; 0x232c <cmd_ip>
		unknown=0;
	}
	if ((strcmp_P(pcmd,PSTR("NETMASK"))==0) && (strlen(pcmd) == 7))
    251e:	81 2f       	mov	r24, r17
    2520:	90 2f       	mov	r25, r16
    2522:	64 ec       	ldi	r22, 0xC4	; 196
    2524:	70 e0       	ldi	r23, 0x00	; 0
    2526:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <strcmp_P>
    252a:	89 2b       	or	r24, r25
    252c:	a9 f4       	brne	.+42     	; 0x2558 <parse+0x104>
    252e:	a1 2f       	mov	r26, r17
    2530:	b0 2f       	mov	r27, r16
    2532:	fd 01       	movw	r30, r26
    2534:	01 90       	ld	r0, Z+
    2536:	00 20       	and	r0, r0
    2538:	e9 f7       	brne	.-6      	; 0x2534 <parse+0xe0>
    253a:	38 97       	sbiw	r30, 0x08	; 8
    253c:	ea 17       	cp	r30, r26
    253e:	fb 07       	cpc	r31, r27
    2540:	59 f4       	brne	.+22     	; 0x2558 <parse+0x104>
	{
		if (argc>1)
    2542:	e1 e0       	ldi	r30, 0x01	; 1
    2544:	ee 16       	cp	r14, r30
    2546:	f1 04       	cpc	r15, r1
    2548:	19 f0       	breq	.+6      	; 0x2550 <parse+0xfc>
			cmd_netmask(argv[1]);
    254a:	8b 81       	ldd	r24, Y+3	; 0x03
    254c:	9c 81       	ldd	r25, Y+4	; 0x04
    254e:	02 c0       	rjmp	.+4      	; 0x2554 <parse+0x100>
		else
			cmd_netmask("");
    2550:	80 e0       	ldi	r24, 0x00	; 0
    2552:	91 e0       	ldi	r25, 0x01	; 1
    2554:	0e 94 02 11 	call	0x2204	; 0x2204 <cmd_netmask>
		unknown=0;
	}
	if ((strcmp_P(pcmd,PSTR("CPRESET"))==0) && (strlen(pcmd) == 7))
    2558:	81 2f       	mov	r24, r17
    255a:	90 2f       	mov	r25, r16
    255c:	6c eb       	ldi	r22, 0xBC	; 188
    255e:	70 e0       	ldi	r23, 0x00	; 0
    2560:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <strcmp_P>
    2564:	89 2b       	or	r24, r25
    2566:	a1 f4       	brne	.+40     	; 0x2590 <parse+0x13c>
    2568:	a1 2f       	mov	r26, r17
    256a:	b0 2f       	mov	r27, r16
    256c:	fd 01       	movw	r30, r26
    256e:	01 90       	ld	r0, Z+
    2570:	00 20       	and	r0, r0
    2572:	e9 f7       	brne	.-6      	; 0x256e <parse+0x11a>
    2574:	38 97       	sbiw	r30, 0x08	; 8
    2576:	ea 17       	cp	r30, r26
    2578:	fb 07       	cpc	r31, r27
    257a:	51 f4       	brne	.+20     	; 0x2590 <parse+0x13c>
	{
		unknown=0;
		uart_puts_P(PSTR("CP2200 reset ..."));
    257c:	8b ea       	ldi	r24, 0xAB	; 171
    257e:	90 e0       	ldi	r25, 0x00	; 0
    2580:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
		network_device_init();
    2584:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <network_device_init>
		uart_puts_P(PSTR("done \n\r"));
    2588:	83 ea       	ldi	r24, 0xA3	; 163
    258a:	90 e0       	ldi	r25, 0x00	; 0
    258c:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	}
	if ((strcmp_P(pcmd,PSTR("HELP"))==0) && (strlen(pcmd) == 4))
    2590:	81 2f       	mov	r24, r17
    2592:	90 2f       	mov	r25, r16
    2594:	6e e9       	ldi	r22, 0x9E	; 158
    2596:	70 e0       	ldi	r23, 0x00	; 0
    2598:	0e 94 02 2f 	call	0x5e04	; 0x5e04 <strcmp_P>
    259c:	89 2b       	or	r24, r25
    259e:	61 f4       	brne	.+24     	; 0x25b8 <parse+0x164>
    25a0:	a1 2f       	mov	r26, r17
    25a2:	b0 2f       	mov	r27, r16
    25a4:	fd 01       	movw	r30, r26
    25a6:	01 90       	ld	r0, Z+
    25a8:	00 20       	and	r0, r0
    25aa:	e9 f7       	brne	.-6      	; 0x25a6 <parse+0x152>
    25ac:	35 97       	sbiw	r30, 0x05	; 5
    25ae:	ea 17       	cp	r30, r26
    25b0:	fb 07       	cpc	r31, r27
    25b2:	11 f4       	brne	.+4      	; 0x25b8 <parse+0x164>
	{
		unknown=0;
		cmd_help();
    25b4:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <cmd_help>
	}


} // parse
    25b8:	c0 56       	subi	r28, 0x60	; 96
    25ba:	df 4f       	sbci	r29, 0xFF	; 255
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	f8 94       	cli
    25c0:	de bf       	out	0x3e, r29	; 62
    25c2:	0f be       	out	0x3f, r0	; 63
    25c4:	cd bf       	out	0x3d, r28	; 61
    25c6:	cf 91       	pop	r28
    25c8:	df 91       	pop	r29
    25ca:	1f 91       	pop	r17
    25cc:	0f 91       	pop	r16
    25ce:	ff 90       	pop	r15
    25d0:	ef 90       	pop	r14
    25d2:	08 95       	ret

000025d4 <AvailRAM>:
	uart_puts(text);
}

// Groesse des freien RAM Speicher ermitteln
unsigned int AvailRAM(void)
{
    25d4:	ef 92       	push	r14
    25d6:	ff 92       	push	r15
    25d8:	0f 93       	push	r16
    25da:	1f 93       	push	r17
    25dc:	df 93       	push	r29
    25de:	cf 93       	push	r28
    25e0:	cd b7       	in	r28, 0x3d	; 61
    25e2:	de b7       	in	r29, 0x3e	; 62
    25e4:	2a 97       	sbiw	r28, 0x0a	; 10
    25e6:	0f b6       	in	r0, 0x3f	; 63
    25e8:	f8 94       	cli
    25ea:	de bf       	out	0x3e, r29	; 62
    25ec:	0f be       	out	0x3f, r0	; 63
    25ee:	cd bf       	out	0x3d, r28	; 61
    25f0:	40 ea       	ldi	r20, 0xA0	; 160
    25f2:	e4 2e       	mov	r14, r20
    25f4:	4f e0       	ldi	r20, 0x0F	; 15
    25f6:	f4 2e       	mov	r15, r20
	char tmpstr[10];
	unsigned int *p=0;
	size_t i;
	for (i=4000;i>1; i-=10)
	{
		p = (unsigned int *) malloc(i);
    25f8:	c7 01       	movw	r24, r14
    25fa:	0e 94 cb 2d 	call	0x5b96	; 0x5b96 <malloc>
		if (p != 0) break;
    25fe:	00 97       	sbiw	r24, 0x00	; 0
    2600:	41 f4       	brne	.+16     	; 0x2612 <AvailRAM+0x3e>
unsigned int AvailRAM(void)
{
	char tmpstr[10];
	unsigned int *p=0;
	size_t i;
	for (i=4000;i>1; i-=10)
    2602:	86 ef       	ldi	r24, 0xF6	; 246
    2604:	9f ef       	ldi	r25, 0xFF	; 255
    2606:	e8 0e       	add	r14, r24
    2608:	f9 1e       	adc	r15, r25
    260a:	e1 14       	cp	r14, r1
    260c:	f1 04       	cpc	r15, r1
    260e:	a1 f7       	brne	.-24     	; 0x25f8 <AvailRAM+0x24>
    2610:	02 c0       	rjmp	.+4      	; 0x2616 <AvailRAM+0x42>
	{
		p = (unsigned int *) malloc(i);
		if (p != 0) break;
	}
	if (p != 0) free(p);
    2612:	0e 94 78 2e 	call	0x5cf0	; 0x5cf0 <free>
	uart_puts_P(PSTR("available RAM memory:"));
    2616:	8e e7       	ldi	r24, 0x7E	; 126
    2618:	92 e0       	ldi	r25, 0x02	; 2
    261a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	itoa(i,tmpstr,10);
    261e:	c7 01       	movw	r24, r14
    2620:	8e 01       	movw	r16, r28
    2622:	0f 5f       	subi	r16, 0xFF	; 255
    2624:	1f 4f       	sbci	r17, 0xFF	; 255
    2626:	b8 01       	movw	r22, r16
    2628:	4a e0       	ldi	r20, 0x0A	; 10
    262a:	50 e0       	ldi	r21, 0x00	; 0
    262c:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <itoa>
	uart_puts(tmpstr);
    2630:	c8 01       	movw	r24, r16
    2632:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
	uart_puts_P(PSTR(" bytes \r\n"));
    2636:	84 e7       	ldi	r24, 0x74	; 116
    2638:	92 e0       	ldi	r25, 0x02	; 2
    263a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	
	return(i);
}
    263e:	c7 01       	movw	r24, r14
    2640:	2a 96       	adiw	r28, 0x0a	; 10
    2642:	0f b6       	in	r0, 0x3f	; 63
    2644:	f8 94       	cli
    2646:	de bf       	out	0x3e, r29	; 62
    2648:	0f be       	out	0x3f, r0	; 63
    264a:	cd bf       	out	0x3d, r28	; 61
    264c:	cf 91       	pop	r28
    264e:	df 91       	pop	r29
    2650:	1f 91       	pop	r17
    2652:	0f 91       	pop	r16
    2654:	ff 90       	pop	r15
    2656:	ef 90       	pop	r14
    2658:	08 95       	ret

0000265a <main>:

} // parse


int main(void)
{
    265a:	2f 92       	push	r2
    265c:	3f 92       	push	r3
    265e:	4f 92       	push	r4
    2660:	5f 92       	push	r5
    2662:	6f 92       	push	r6
    2664:	7f 92       	push	r7
    2666:	8f 92       	push	r8
    2668:	9f 92       	push	r9
    266a:	af 92       	push	r10
    266c:	bf 92       	push	r11
    266e:	cf 92       	push	r12
    2670:	df 92       	push	r13
    2672:	ef 92       	push	r14
    2674:	ff 92       	push	r15
    2676:	0f 93       	push	r16
    2678:	1f 93       	push	r17
    267a:	df 93       	push	r29
    267c:	cf 93       	push	r28
    267e:	cd b7       	in	r28, 0x3d	; 61
    2680:	de b7       	in	r29, 0x3e	; 62
    2682:	c8 55       	subi	r28, 0x58	; 88
    2684:	d0 40       	sbci	r29, 0x00	; 0
    2686:	0f b6       	in	r0, 0x3f	; 63
    2688:	f8 94       	cli
    268a:	de bf       	out	0x3e, r29	; 62
    268c:	0f be       	out	0x3f, r0	; 63
    268e:	cd bf       	out	0x3d, r28	; 61
	char taste=0;
	char zeile[80];
	int i=0;
	struct timer periodic_timer, arp_timer;
	DDRA = 0x00;    
    2690:	11 b8       	out	0x01, r1	; 1
  DDRB = 0xFF;    
    2692:	8f ef       	ldi	r24, 0xFF	; 255
    2694:	84 b9       	out	0x04, r24	; 4
	DDRC = 0xFF;
    2696:	87 b9       	out	0x07, r24	; 7
	PORTA = 0x00;
    2698:	12 b8       	out	0x02, r1	; 2
	PORTB = 0x00;
    269a:	15 b8       	out	0x05, r1	; 5
	PORTC = 0xF7;
    269c:	87 ef       	ldi	r24, 0xF7	; 247
    269e:	88 b9       	out	0x08, r24	; 8
	PORTC |= (1 << nRD); // set RD#
    26a0:	45 9a       	sbi	0x08, 5	; 8
	PORTC |= (1 << nWR); // set WR#
    26a2:	44 9a       	sbi	0x08, 4	; 8
	PORTC &= ~(1 << ALE); // clear ALE
    26a4:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nCS); // clear CS
    26a6:	46 98       	cbi	0x08, 6	; 8
	PORTC |= (1 << nLRST); // reset aus, CP2200 wieder laufen lassen
    26a8:	47 9a       	sbi	0x08, 7	; 8
}


void InitUART(void)
{
	UBRR0H = 0;
    26aa:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = 64;
    26ae:	80 e4       	ldi	r24, 0x40	; 64
    26b0:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0) | (1<<TXEN0); // transmit & receive enable 
    26b4:	88 e1       	ldi	r24, 0x18	; 24
    26b6:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = 0x06; // init RS232: 8,N,1
    26ba:	86 e0       	ldi	r24, 0x06	; 6
    26bc:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0A = 0x00; 
    26c0:	10 92 c0 00 	sts	0x00C0, r1
	PORTC &= ~(1 << ALE); // clear ALE
	PORTC &= ~(1 << nCS); // clear CS
	PORTC |= (1 << nLRST); // reset aus, CP2200 wieder laufen lassen
	
	InitUART();
	cmd_help();
    26c4:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <cmd_help>
	AvailRAM();
    26c8:	0e 94 ea 12 	call	0x25d4	; 0x25d4 <AvailRAM>
    26cc:	84 ef       	ldi	r24, 0xF4	; 244
    26ce:	91 e0       	ldi	r25, 0x01	; 1
    26d0:	24 ef       	ldi	r18, 0xF4	; 244
    26d2:	31 e0       	ldi	r19, 0x01	; 1
    26d4:	f9 01       	movw	r30, r18
    26d6:	31 97       	sbiw	r30, 0x01	; 1
    26d8:	f1 f7       	brne	.-4      	; 0x26d6 <main+0x7c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26da:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26dc:	d9 f7       	brne	.-10     	; 0x26d4 <main+0x7a>
	_delay_ms(50);
	//Init_CP2000();
	cli(); // disable inerrupts
    26de:	f8 94       	cli
	// MCUCR |= (1<<ISC11);  // 1 = INT1 fallede Flanke
	// MCUCR &= ~(1<<ISC10); // 0	= INT1 fallede Flanke
	EICRA = 0x08; // INT1 fallede Flanke
    26e0:	88 e0       	ldi	r24, 0x08	; 8
    26e2:	80 93 69 00 	sts	0x0069, r24
	// GIMSK = 0x80; // enable external int1
	EIMSK = 0x02; // enable external int1
    26e6:	82 e0       	ldi	r24, 0x02	; 2
    26e8:	8d bb       	out	0x1d, r24	; 29
	// GIFR = 0x80;
	sei();  // enable interrupts 
    26ea:	78 94       	sei
	uart_puts_P(PSTR("init CP2200 ..."));
    26ec:	8e e8       	ldi	r24, 0x8E	; 142
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    26f4:	b0 e5       	ldi	r27, 0x50	; 80
    26f6:	cb 2e       	mov	r12, r27
    26f8:	b3 ec       	ldi	r27, 0xC3	; 195
    26fa:	db 2e       	mov	r13, r27
    26fc:	c6 01       	movw	r24, r12
    26fe:	01 97       	sbiw	r24, 0x01	; 1
    2700:	f1 f7       	brne	.-4      	; 0x26fe <main+0xa4>
	_delay_ms(10);
	network_device_init();
    2702:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <network_device_init>
		cmd_ip("");
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	91 e0       	ldi	r25, 0x01	; 1
    270a:	0e 94 96 11 	call	0x232c	; 0x232c <cmd_ip>
	clock_init();
    270e:	0e 94 bd 10 	call	0x217a	; 0x217a <clock_init>
	timer_set(&periodic_timer, CLOCK_SECOND / 2);
    2712:	8e 01       	movw	r16, r28
    2714:	0f 5f       	subi	r16, 0xFF	; 255
    2716:	1f 4f       	sbci	r17, 0xFF	; 255
    2718:	c8 01       	movw	r24, r16
    271a:	64 ef       	ldi	r22, 0xF4	; 244
    271c:	71 e0       	ldi	r23, 0x01	; 1
    271e:	0e 94 da 25 	call	0x4bb4	; 0x4bb4 <timer_set>
	timer_set(&arp_timer, CLOCK_SECOND * 10);
    2722:	a5 e0       	ldi	r26, 0x05	; 5
    2724:	ea 2e       	mov	r14, r26
    2726:	f1 2c       	mov	r15, r1
    2728:	ec 0e       	add	r14, r28
    272a:	fd 1e       	adc	r15, r29
    272c:	c7 01       	movw	r24, r14
    272e:	60 e1       	ldi	r22, 0x10	; 16
    2730:	77 e2       	ldi	r23, 0x27	; 39
    2732:	0e 94 da 25 	call	0x4bb4	; 0x4bb4 <timer_set>
	uart_puts_P(PSTR("\r\nready. \r\n"));
    2736:	82 e8       	ldi	r24, 0x82	; 130
    2738:	90 e0       	ldi	r25, 0x00	; 0
    273a:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    273e:	c6 01       	movw	r24, r12
    2740:	01 97       	sbiw	r24, 0x01	; 1
    2742:	f1 f7       	brne	.-4      	; 0x2740 <main+0xe6>
	_delay_ms(10);

	uip_arp_init();
    2744:	0e 94 04 23 	call	0x4608	; 0x4608 <uip_arp_init>
	uip_init();
    2748:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <uip_init>
	httpd_init();
    274c:	0e 94 ba 26 	call	0x4d74	; 0x4d74 <httpd_init>
    2750:	cc 24       	eor	r12, r12
    2752:	dd 24       	eor	r13, r13
				{
					network_device_send();
				}
			}
		} 
		else if(timer_expired(&periodic_timer)) 
    2754:	70 2e       	mov	r7, r16
    2756:	81 2e       	mov	r8, r17
		{
			timer_reset(&periodic_timer);
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
    2758:	f2 e7       	ldi	r31, 0x72	; 114
    275a:	2f 2e       	mov	r2, r31
    275c:	f4 e0       	ldi	r31, 0x04	; 4
    275e:	3f 2e       	mov	r3, r31
    2760:	ef e1       	ldi	r30, 0x1F	; 31
    2762:	4e 2e       	mov	r4, r30
    2764:	e5 e0       	ldi	r30, 0x05	; 5
    2766:	5e 2e       	mov	r5, r30
					network_device_send();
				}
			}
			#endif // UIP_UDP */
			/* Call the ARP timer function every 10 seconds. */
			if(timer_expired(&arp_timer)) 
    2768:	9e 2c       	mov	r9, r14
    276a:	ef 2c       	mov	r14, r15
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    276c:	7a e0       	ldi	r23, 0x0A	; 10
    276e:	67 2e       	mov	r6, r23
			taste = UDR0; // Zeichen abholen
			uart_putc(taste); // Zeichen ausgeben
			if (taste == 13)
			{
				uart_putc('\n');
				zeile[i]=0;
    2770:	69 e0       	ldi	r22, 0x09	; 9
    2772:	a6 2e       	mov	r10, r22
    2774:	b1 2c       	mov	r11, r1
    2776:	ac 0e       	add	r10, r28
    2778:	bd 1e       	adc	r11, r29
    277a:	02 c0       	rjmp	.+4      	; 0x2780 <main+0x126>
	uart_puts_P(PSTR("\r\nready. \r\n"));
	_delay_ms(10);

	uip_arp_init();
	uip_init();
	httpd_init();
    277c:	86 01       	movw	r16, r12
    277e:	68 01       	movw	r12, r16



	while(1) 
	{
		uip_len = network_device_read();
    2780:	0e 94 88 16 	call	0x2d10	; 0x2d10 <network_device_read>
    2784:	90 93 66 04 	sts	0x0466, r25
    2788:	80 93 65 04 	sts	0x0465, r24
		if(uip_len > 0) 
    278c:	89 2b       	or	r24, r25
    278e:	89 f1       	breq	.+98     	; 0x27f2 <main+0x198>
		{
			if(BUF->type == htons(UIP_ETHTYPE_IP)) 
    2790:	00 91 14 06 	lds	r16, 0x0614
    2794:	10 91 15 06 	lds	r17, 0x0615
    2798:	80 e0       	ldi	r24, 0x00	; 0
    279a:	98 e0       	ldi	r25, 0x08	; 8
    279c:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    27a0:	08 17       	cp	r16, r24
    27a2:	19 07       	cpc	r17, r25
    27a4:	79 f4       	brne	.+30     	; 0x27c4 <main+0x16a>
			{
				uip_arp_ipin();
    27a6:	0e 94 e9 20 	call	0x41d2	; 0x41d2 <uip_arp_ipin>
				uip_input();
    27aa:	81 e0       	ldi	r24, 0x01	; 1
    27ac:	0e 94 17 19 	call	0x322e	; 0x322e <uip_process>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    27b0:	80 91 65 04 	lds	r24, 0x0465
    27b4:	90 91 66 04 	lds	r25, 0x0466
    27b8:	89 2b       	or	r24, r25
    27ba:	09 f4       	brne	.+2      	; 0x27be <main+0x164>
    27bc:	55 c0       	rjmp	.+170    	; 0x2868 <main+0x20e>
				{
					uip_arp_out();
    27be:	0e 94 d3 21 	call	0x43a6	; 0x43a6 <uip_arp_out>
    27c2:	14 c0       	rjmp	.+40     	; 0x27ec <main+0x192>
					network_device_send();
				}
			}
			else if(BUF->type == htons(UIP_ETHTYPE_ARP)) 
    27c4:	00 91 14 06 	lds	r16, 0x0614
    27c8:	10 91 15 06 	lds	r17, 0x0615
    27cc:	86 e0       	ldi	r24, 0x06	; 6
    27ce:	98 e0       	ldi	r25, 0x08	; 8
    27d0:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    27d4:	08 17       	cp	r16, r24
    27d6:	19 07       	cpc	r17, r25
    27d8:	09 f0       	breq	.+2      	; 0x27dc <main+0x182>
    27da:	46 c0       	rjmp	.+140    	; 0x2868 <main+0x20e>
			{
			
				uip_arp_arpin();
    27dc:	0e 94 1d 21 	call	0x423a	; 0x423a <uip_arp_arpin>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    27e0:	80 91 65 04 	lds	r24, 0x0465
    27e4:	90 91 66 04 	lds	r25, 0x0466
    27e8:	89 2b       	or	r24, r25
    27ea:	f1 f1       	breq	.+124    	; 0x2868 <main+0x20e>
				{
					network_device_send();
    27ec:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <network_device_send>
    27f0:	3b c0       	rjmp	.+118    	; 0x2868 <main+0x20e>
				}
			}
		} 
		else if(timer_expired(&periodic_timer)) 
    27f2:	87 2d       	mov	r24, r7
    27f4:	98 2d       	mov	r25, r8
    27f6:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <timer_expired>
    27fa:	89 2b       	or	r24, r25
    27fc:	a9 f1       	breq	.+106    	; 0x2868 <main+0x20e>
		{
			timer_reset(&periodic_timer);
    27fe:	87 2d       	mov	r24, r7
    2800:	98 2d       	mov	r25, r8
    2802:	0e 94 ae 25 	call	0x4b5c	; 0x4b5c <timer_reset>
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
    2806:	30 92 71 04 	sts	0x0471, r3
    280a:	20 92 70 04 	sts	0x0470, r2
    280e:	82 e0       	ldi	r24, 0x02	; 2
    2810:	0e 94 17 19 	call	0x322e	; 0x322e <uip_process>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    2814:	80 91 65 04 	lds	r24, 0x0465
    2818:	90 91 66 04 	lds	r25, 0x0466
    281c:	89 2b       	or	r24, r25
    281e:	21 f0       	breq	.+8      	; 0x2828 <main+0x1ce>
				{
					uip_arp_out();
    2820:	0e 94 d3 21 	call	0x43a6	; 0x43a6 <uip_arp_out>
					network_device_send();
    2824:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <network_device_send>
		else if(timer_expired(&periodic_timer)) 
		{
			timer_reset(&periodic_timer);
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
    2828:	50 92 71 04 	sts	0x0471, r5
    282c:	40 92 70 04 	sts	0x0470, r4
    2830:	82 e0       	ldi	r24, 0x02	; 2
    2832:	0e 94 17 19 	call	0x322e	; 0x322e <uip_process>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    2836:	80 91 65 04 	lds	r24, 0x0465
    283a:	90 91 66 04 	lds	r25, 0x0466
    283e:	89 2b       	or	r24, r25
    2840:	21 f0       	breq	.+8      	; 0x284a <main+0x1f0>
				{
					uip_arp_out();
    2842:	0e 94 d3 21 	call	0x43a6	; 0x43a6 <uip_arp_out>
					network_device_send();
    2846:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <network_device_send>
					network_device_send();
				}
			}
			#endif // UIP_UDP */
			/* Call the ARP timer function every 10 seconds. */
			if(timer_expired(&arp_timer)) 
    284a:	89 2d       	mov	r24, r9
    284c:	9e 2d       	mov	r25, r14
    284e:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <timer_expired>
    2852:	89 2b       	or	r24, r25
    2854:	31 f0       	breq	.+12     	; 0x2862 <main+0x208>
			{
				timer_reset(&arp_timer);
    2856:	89 2d       	mov	r24, r9
    2858:	9e 2d       	mov	r25, r14
    285a:	0e 94 ae 25 	call	0x4b5c	; 0x4b5c <timer_reset>
				uip_arp_timer();
    285e:	0e 94 d7 22 	call	0x45ae	; 0x45ae <uip_arp_timer>
    2862:	52 e0       	ldi	r21, 0x02	; 2
    2864:	c5 2e       	mov	r12, r21
    2866:	d1 2c       	mov	r13, r1
			}
		}

		
		if (UCSR0A & (1<<RXC0))  // Zeichen verfuegbar?
    2868:	80 91 c0 00 	lds	r24, 0x00C0
    286c:	87 ff       	sbrs	r24, 7
    286e:	88 cf       	rjmp	.-240    	; 0x2780 <main+0x126>
    2870:	86 01       	movw	r16, r12
		{
			taste = UDR0; // Zeichen abholen
    2872:	f0 90 c6 00 	lds	r15, 0x00C6
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2876:	80 91 c0 00 	lds	r24, 0x00C0
    287a:	85 ff       	sbrs	r24, 5
    287c:	fc cf       	rjmp	.-8      	; 0x2876 <main+0x21c>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    287e:	f0 92 c6 00 	sts	0x00C6, r15
		
		if (UCSR0A & (1<<RXC0))  // Zeichen verfuegbar?
		{
			taste = UDR0; // Zeichen abholen
			uart_putc(taste); // Zeichen ausgeben
			if (taste == 13)
    2882:	8d e0       	ldi	r24, 0x0D	; 13
    2884:	f8 16       	cp	r15, r24
    2886:	a1 f4       	brne	.+40     	; 0x28b0 <main+0x256>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2888:	80 91 c0 00 	lds	r24, 0x00C0
    288c:	85 ff       	sbrs	r24, 5
    288e:	fc cf       	rjmp	.-8      	; 0x2888 <main+0x22e>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2890:	60 92 c6 00 	sts	0x00C6, r6
			taste = UDR0; // Zeichen abholen
			uart_putc(taste); // Zeichen ausgeben
			if (taste == 13)
			{
				uart_putc('\n');
				zeile[i]=0;
    2894:	ca 0c       	add	r12, r10
    2896:	db 1c       	adc	r13, r11
    2898:	f6 01       	movw	r30, r12
    289a:	10 82       	st	Z, r1
				parse(zeile);	
    289c:	c5 01       	movw	r24, r10
    289e:	0e 94 2a 12 	call	0x2454	; 0x2454 <parse>
				uart_puts_P(PSTR("#"));
    28a2:	80 e8       	ldi	r24, 0x80	; 128
    28a4:	90 e0       	ldi	r25, 0x00	; 0
    28a6:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    28aa:	cc 24       	eor	r12, r12
    28ac:	dd 24       	eor	r13, r13
    28ae:	14 c0       	rjmp	.+40     	; 0x28d8 <main+0x27e>
				i=0;
				
			}
			
			if (taste == 8)
    28b0:	f8 e0       	ldi	r31, 0x08	; 8
    28b2:	ff 16       	cp	r15, r31
    28b4:	61 f4       	brne	.+24     	; 0x28ce <main+0x274>
			{
				// Backspace key
				if (i>0) 
    28b6:	c1 14       	cp	r12, r1
    28b8:	d1 04       	cpc	r13, r1
    28ba:	09 f4       	brne	.+2      	; 0x28be <main+0x264>
    28bc:	60 cf       	rjmp	.-320    	; 0x277e <main+0x124>
				{
					i--;
    28be:	86 01       	movw	r16, r12
    28c0:	01 50       	subi	r16, 0x01	; 1
    28c2:	10 40       	sbci	r17, 0x00	; 0
					uart_puts_P(PSTR("\x1B[P")); // VT100-Code Backspace
    28c4:	8c e7       	ldi	r24, 0x7C	; 124
    28c6:	90 e0       	ldi	r25, 0x00	; 0
    28c8:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    28cc:	58 cf       	rjmp	.-336    	; 0x277e <main+0x124>
				}
			}	
			else
			{
				if (i<78)
    28ce:	8e e4       	ldi	r24, 0x4E	; 78
    28d0:	c8 16       	cp	r12, r24
    28d2:	d1 04       	cpc	r13, r1
    28d4:	0c f0       	brlt	.+2      	; 0x28d8 <main+0x27e>
    28d6:	52 cf       	rjmp	.-348    	; 0x277c <main+0x122>
					zeile[i++]=taste; // Zeichen merken
    28d8:	f5 01       	movw	r30, r10
    28da:	ec 0d       	add	r30, r12
    28dc:	fd 1d       	adc	r31, r13
    28de:	f0 82       	st	Z, r15
    28e0:	86 01       	movw	r16, r12
    28e2:	0f 5f       	subi	r16, 0xFF	; 255
    28e4:	1f 4f       	sbci	r17, 0xFF	; 255
    28e6:	4b cf       	rjmp	.-362    	; 0x277e <main+0x124>

000028e8 <write_CP2200>:
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    28e8:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    28ea:	9f ef       	ldi	r25, 0xFF	; 255
    28ec:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    28ee:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    28f0:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    28f2:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    28f4:	62 b9       	out	0x02, r22	; 2
	PORTC |= (1 << nWR); // set WR#
    28f6:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    28f8:	62 b9       	out	0x02, r22	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    28fa:	11 b8       	out	0x01, r1	; 1
}
    28fc:	08 95       	ret

000028fe <CP2200_WriteRXBuffer>:
	return (read_CP2200(RAMRXDATA));
}

// ---------------------------------------------
void CP2200_WriteRXBuffer(unsigned int addr, unsigned char value)
{
    28fe:	0f 93       	push	r16
    2900:	1f 93       	push	r17
    2902:	28 2f       	mov	r18, r24
    2904:	19 2f       	mov	r17, r25
    2906:	06 2f       	mov	r16, r22
	write_CP2200(RAMADDRL,addr & 0xFF); 
    2908:	89 e0       	ldi	r24, 0x09	; 9
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	62 2f       	mov	r22, r18
    290e:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(RAMADDRH,addr >> 8); 
    2912:	88 e0       	ldi	r24, 0x08	; 8
    2914:	90 e0       	ldi	r25, 0x00	; 0
    2916:	61 2f       	mov	r22, r17
    2918:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(RAMRXDATA,value); 
    291c:	82 e0       	ldi	r24, 0x02	; 2
    291e:	90 e0       	ldi	r25, 0x00	; 0
    2920:	60 2f       	mov	r22, r16
    2922:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
}
    2926:	1f 91       	pop	r17
    2928:	0f 91       	pop	r16
    292a:	08 95       	ret

0000292c <CP2200_WriteTXBuffer>:
	return (read_CP2200(RAMTXDATA));
}

// ---------------------------------------------
void CP2200_WriteTXBuffer(unsigned int addr, unsigned char value)
{
    292c:	0f 93       	push	r16
    292e:	1f 93       	push	r17
    2930:	28 2f       	mov	r18, r24
    2932:	19 2f       	mov	r17, r25
    2934:	06 2f       	mov	r16, r22
	write_CP2200(RAMADDRL,addr & 0xFF); 
    2936:	89 e0       	ldi	r24, 0x09	; 9
    2938:	90 e0       	ldi	r25, 0x00	; 0
    293a:	62 2f       	mov	r22, r18
    293c:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(RAMADDRH,addr >> 8); 
    2940:	88 e0       	ldi	r24, 0x08	; 8
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	61 2f       	mov	r22, r17
    2946:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(RAMTXDATA,value); 
    294a:	84 e0       	ldi	r24, 0x04	; 4
    294c:	90 e0       	ldi	r25, 0x00	; 0
    294e:	60 2f       	mov	r22, r16
    2950:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
}
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	08 95       	ret

0000295a <read_CP2200>:


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    295a:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    295c:	9f ef       	ldi	r25, 0xFF	; 255
    295e:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2960:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2962:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2964:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2966:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2968:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    296a:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    296c:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    296e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2970:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2972:	45 9a       	sbi	0x08, 5	; 8
	return(value);
}
    2974:	08 95       	ret

00002976 <CP2200_WritePacket>:
	return(packetlen);
}

// ---------------------------------------------
void CP2200_WritePacket(void)
{
    2976:	0f 93       	push	r16
    2978:	1f 93       	push	r17
    297a:	cf 93       	push	r28
    297c:	df 93       	push	r29
	//unsigned int len;
	unsigned int addr;
	unsigned int t;
	// wait for previous packet complete
	while (read_CP2200(TXBUSY) != 0x00);
    297e:	84 e5       	ldi	r24, 0x54	; 84
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2986:	88 23       	and	r24, r24
    2988:	d1 f7       	brne	.-12     	; 0x297e <CP2200_WritePacket+0x8>
	// set transmit buffer pointer
	write_CP2200(TXSTARTH,0x00);
    298a:	89 e5       	ldi	r24, 0x59	; 89
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	60 e0       	ldi	r22, 0x00	; 0
    2990:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(TXSTARTL,0x00);
    2994:	8a e5       	ldi	r24, 0x5A	; 90
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	60 e0       	ldi	r22, 0x00	; 0
    299a:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
    299e:	80 e0       	ldi	r24, 0x00	; 0
    29a0:	90 e0       	ldi	r25, 0x00	; 0
	
	//hwsend(&uip_buf[0], UIP_LLH_LEN);
	addr=0;
	for (t=0;t < UIP_LLH_LEN;t++)
	{
		CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
    29a2:	ec 01       	movw	r28, r24
    29a4:	21 96       	adiw	r28, 0x01	; 1
    29a6:	fe 01       	movw	r30, r28
    29a8:	e9 5f       	subi	r30, 0xF9	; 249
    29aa:	f9 4f       	sbci	r31, 0xF9	; 249
    29ac:	60 81       	ld	r22, Z
    29ae:	0e 94 96 14 	call	0x292c	; 0x292c <CP2200_WriteTXBuffer>
    29b2:	ce 01       	movw	r24, r28
	write_CP2200(TXSTARTH,0x00);
	write_CP2200(TXSTARTL,0x00);
	
	//hwsend(&uip_buf[0], UIP_LLH_LEN);
	addr=0;
	for (t=0;t < UIP_LLH_LEN;t++)
    29b4:	ce 30       	cpi	r28, 0x0E	; 14
    29b6:	d1 05       	cpc	r29, r1
    29b8:	a1 f7       	brne	.-24     	; 0x29a2 <CP2200_WritePacket+0x2c>
	{
		CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
	}
	
	if(uip_len <= UIP_LLH_LEN + UIP_TCPIP_HLEN) 
    29ba:	80 91 65 04 	lds	r24, 0x0465
    29be:	90 91 66 04 	lds	r25, 0x0466
    29c2:	c7 97       	sbiw	r24, 0x37	; 55
    29c4:	60 f0       	brcs	.+24     	; 0x29de <CP2200_WritePacket+0x68>
    29c6:	13 c0       	rjmp	.+38     	; 0x29ee <CP2200_WritePacket+0x78>
	{
		
		//hwsend(&uip_buf[UIP_LLH_LEN], uip_len - UIP_LLH_LEN);
		for (t=UIP_LLH_LEN;t < uip_len;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
    29c8:	8e 01       	movw	r16, r28
    29ca:	0f 5f       	subi	r16, 0xFF	; 255
    29cc:	1f 4f       	sbci	r17, 0xFF	; 255
    29ce:	f8 01       	movw	r30, r16
    29d0:	e9 5f       	subi	r30, 0xF9	; 249
    29d2:	f9 4f       	sbci	r31, 0xF9	; 249
    29d4:	ce 01       	movw	r24, r28
    29d6:	60 81       	ld	r22, Z
    29d8:	0e 94 96 14 	call	0x292c	; 0x292c <CP2200_WriteTXBuffer>
    29dc:	e8 01       	movw	r28, r16
	
	if(uip_len <= UIP_LLH_LEN + UIP_TCPIP_HLEN) 
	{
		
		//hwsend(&uip_buf[UIP_LLH_LEN], uip_len - UIP_LLH_LEN);
		for (t=UIP_LLH_LEN;t < uip_len;t++)
    29de:	80 91 65 04 	lds	r24, 0x0465
    29e2:	90 91 66 04 	lds	r25, 0x0466
    29e6:	c8 17       	cp	r28, r24
    29e8:	d9 07       	cpc	r29, r25
    29ea:	70 f3       	brcs	.-36     	; 0x29c8 <CP2200_WritePacket+0x52>
    29ec:	25 c0       	rjmp	.+74     	; 0x2a38 <CP2200_WritePacket+0xc2>
    29ee:	ce 01       	movw	r24, r28
	else 
	{
		//hwsend(&uip_buf[UIP_LLH_LEN], UIP_TCPIP_HLEN);
		for (t=UIP_LLH_LEN;t < UIP_TCPIP_HLEN+UIP_LLH_LEN;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
    29f0:	21 96       	adiw	r28, 0x01	; 1
    29f2:	fe 01       	movw	r30, r28
    29f4:	e9 5f       	subi	r30, 0xF9	; 249
    29f6:	f9 4f       	sbci	r31, 0xF9	; 249
    29f8:	60 81       	ld	r22, Z
    29fa:	0e 94 96 14 	call	0x292c	; 0x292c <CP2200_WriteTXBuffer>
		}
	} 
	else 
	{
		//hwsend(&uip_buf[UIP_LLH_LEN], UIP_TCPIP_HLEN);
		for (t=UIP_LLH_LEN;t < UIP_TCPIP_HLEN+UIP_LLH_LEN;t++)
    29fe:	c6 33       	cpi	r28, 0x36	; 54
    2a00:	d1 05       	cpc	r29, r1
    2a02:	a9 f7       	brne	.-22     	; 0x29ee <CP2200_WritePacket+0x78>
    2a04:	0e c0       	rjmp	.+28     	; 0x2a22 <CP2200_WritePacket+0xac>
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
		}
		//hwsend(uip_appdata, uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN);
		for (t=0;t < uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(((unsigned char *)uip_appdata) + t));
    2a06:	8e 01       	movw	r16, r28
    2a08:	0f 5f       	subi	r16, 0xFF	; 255
    2a0a:	1f 4f       	sbci	r17, 0xFF	; 255
    2a0c:	e0 91 6e 04 	lds	r30, 0x046E
    2a10:	f0 91 6f 04 	lds	r31, 0x046F
    2a14:	e2 0f       	add	r30, r18
    2a16:	f3 1f       	adc	r31, r19
    2a18:	ce 01       	movw	r24, r28
    2a1a:	60 81       	ld	r22, Z
    2a1c:	0e 94 96 14 	call	0x292c	; 0x292c <CP2200_WriteTXBuffer>
    2a20:	e8 01       	movw	r28, r16
    2a22:	9e 01       	movw	r18, r28
    2a24:	26 53       	subi	r18, 0x36	; 54
    2a26:	30 40       	sbci	r19, 0x00	; 0
		for (t=UIP_LLH_LEN;t < UIP_TCPIP_HLEN+UIP_LLH_LEN;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
		}
		//hwsend(uip_appdata, uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN);
		for (t=0;t < uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN;t++)
    2a28:	80 91 65 04 	lds	r24, 0x0465
    2a2c:	90 91 66 04 	lds	r25, 0x0466
    2a30:	c6 97       	sbiw	r24, 0x36	; 54
    2a32:	28 17       	cp	r18, r24
    2a34:	39 07       	cpc	r19, r25
    2a36:	38 f3       	brcs	.-50     	; 0x2a06 <CP2200_WritePacket+0x90>
	//}
	
	// set packet end
	//write_CP2200(TXENDH,(char) (uip_len >> 8));
	//write_CP2200(TXENDL,(char) (uip_len & 0xFF));
	write_CP2200(TXENDH,(char) (addr >> 8));
    2a38:	87 e5       	ldi	r24, 0x57	; 87
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	6d 2f       	mov	r22, r29
    2a3e:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(TXENDL,(char) (addr & 0xFF));
    2a42:	88 e5       	ldi	r24, 0x58	; 88
    2a44:	90 e0       	ldi	r25, 0x00	; 0
    2a46:	6c 2f       	mov	r22, r28
    2a48:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	// set packet start
	write_CP2200(TXSTARTH,0x00);
    2a4c:	89 e5       	ldi	r24, 0x59	; 89
    2a4e:	90 e0       	ldi	r25, 0x00	; 0
    2a50:	60 e0       	ldi	r22, 0x00	; 0
    2a52:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(TXSTARTL,0x00);
    2a56:	8a e5       	ldi	r24, 0x5A	; 90
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	60 e0       	ldi	r22, 0x00	; 0
    2a5c:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(TXCN,0x01); // send packet
    2a60:	83 e5       	ldi	r24, 0x53	; 83
    2a62:	90 e0       	ldi	r25, 0x00	; 0
    2a64:	61 e0       	ldi	r22, 0x01	; 1
    2a66:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	//uart_puts_P(PSTR("[sp] "));	
}
    2a6a:	df 91       	pop	r29
    2a6c:	cf 91       	pop	r28
    2a6e:	1f 91       	pop	r17
    2a70:	0f 91       	pop	r16
    2a72:	08 95       	ret

00002a74 <network_device_send>:

// ---------------------------------------------
void network_device_send(void)
{
	CP2200_WritePacket();
    2a74:	0e 94 bb 14 	call	0x2976	; 0x2976 <CP2200_WritePacket>
}
    2a78:	08 95       	ret

00002a7a <CP2200_ReadPacket>:
	write_CP2200(RAMRXDATA,value); 
}

// ---------------------------------------------
u16_t CP2200_ReadPacket(void)
{
    2a7a:	ef 92       	push	r14
    2a7c:	ff 92       	push	r15
    2a7e:	0f 93       	push	r16
    2a80:	1f 93       	push	r17
    2a82:	cf 93       	push	r28
    2a84:	df 93       	push	r29
	// uip_buf
	// get packet len
		u16_t packetlen;
	u16_t i;
	packetlen = read_CP2200(CPLENH);
    2a86:	8f e1       	ldi	r24, 0x1F	; 31
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
	packetlen = packetlen << 8;
    2a8e:	18 2f       	mov	r17, r24
    2a90:	00 e0       	ldi	r16, 0x00	; 0
	packetlen |= read_CP2200(CPLENL);
    2a92:	80 e2       	ldi	r24, 0x20	; 32
    2a94:	90 e0       	ldi	r25, 0x00	; 0
    2a96:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2a9a:	e8 2e       	mov	r14, r24
    2a9c:	ff 24       	eor	r15, r15
    2a9e:	e0 2a       	or	r14, r16
    2aa0:	f1 2a       	or	r15, r17
    2aa2:	c0 e0       	ldi	r28, 0x00	; 0
    2aa4:	d0 e0       	ldi	r29, 0x00	; 0
    2aa6:	09 c0       	rjmp	.+18     	; 0x2aba <CP2200_ReadPacket+0x40>
	for (i=0;i<packetlen;i++)
	{
		*(uip_buf+i) = read_CP2200(RXAUTORD);
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2ab0:	fe 01       	movw	r30, r28
    2ab2:	e8 5f       	subi	r30, 0xF8	; 248
    2ab4:	f9 4f       	sbci	r31, 0xF9	; 249
    2ab6:	80 83       	st	Z, r24
		u16_t packetlen;
	u16_t i;
	packetlen = read_CP2200(CPLENH);
	packetlen = packetlen << 8;
	packetlen |= read_CP2200(CPLENL);
	for (i=0;i<packetlen;i++)
    2ab8:	21 96       	adiw	r28, 0x01	; 1
    2aba:	ce 15       	cp	r28, r14
    2abc:	df 05       	cpc	r29, r15
    2abe:	a0 f3       	brcs	.-24     	; 0x2aa8 <CP2200_ReadPacket+0x2e>
	{
		*(uip_buf+i) = read_CP2200(RXAUTORD);
	}
	return(packetlen);
}
    2ac0:	c7 01       	movw	r24, r14
    2ac2:	df 91       	pop	r29
    2ac4:	cf 91       	pop	r28
    2ac6:	1f 91       	pop	r17
    2ac8:	0f 91       	pop	r16
    2aca:	ff 90       	pop	r15
    2acc:	ef 90       	pop	r14
    2ace:	08 95       	ret

00002ad0 <CP2200_ReadRXBuffer>:
	write_CP2200(RAMTXDATA,value); 
}

// ---------------------------------------------
unsigned char CP2200_ReadRXBuffer(unsigned int addr)
{
    2ad0:	1f 93       	push	r17
    2ad2:	68 2f       	mov	r22, r24
    2ad4:	19 2f       	mov	r17, r25
	write_CP2200(RAMADDRL, (char) (addr & 0xFF)); 
    2ad6:	89 e0       	ldi	r24, 0x09	; 9
    2ad8:	90 e0       	ldi	r25, 0x00	; 0
    2ada:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(RAMADDRH,(char) (addr >> 8)); 
    2ade:	88 e0       	ldi	r24, 0x08	; 8
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	61 2f       	mov	r22, r17
    2ae4:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	return (read_CP2200(RAMRXDATA));
    2ae8:	82 e0       	ldi	r24, 0x02	; 2
    2aea:	90 e0       	ldi	r25, 0x00	; 0
    2aec:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
}
    2af0:	1f 91       	pop	r17
    2af2:	08 95       	ret

00002af4 <CP2200_ReadTXBuffer>:
// globale Variablen
static char CP2200_status=0;

// ---------------------------------------------
unsigned char CP2200_ReadTXBuffer(unsigned int addr)
{
    2af4:	1f 93       	push	r17
    2af6:	68 2f       	mov	r22, r24
    2af8:	19 2f       	mov	r17, r25
	write_CP2200(RAMADDRL,addr & 0xFF); 
    2afa:	89 e0       	ldi	r24, 0x09	; 9
    2afc:	90 e0       	ldi	r25, 0x00	; 0
    2afe:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(RAMADDRH,addr >> 8); 
    2b02:	88 e0       	ldi	r24, 0x08	; 8
    2b04:	90 e0       	ldi	r25, 0x00	; 0
    2b06:	61 2f       	mov	r22, r17
    2b08:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	return (read_CP2200(RAMTXDATA));
    2b0c:	84 e0       	ldi	r24, 0x04	; 4
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
}
    2b14:	1f 91       	pop	r17
    2b16:	08 95       	ret

00002b18 <cpWriteMac>:
}


// ---------------------------------------------
static void cpWriteMac(char adr,int value)
{
    2b18:	0f 93       	push	r16
    2b1a:	1f 93       	push	r17
    2b1c:	28 2f       	mov	r18, r24
    2b1e:	8b 01       	movw	r16, r22
  write_CP2200(MACADDR,adr);
    2b20:	8a e0       	ldi	r24, 0x0A	; 10
    2b22:	90 e0       	ldi	r25, 0x00	; 0
    2b24:	62 2f       	mov	r22, r18
    2b26:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  write_CP2200(MACDATAH,value>>8);
    2b2a:	61 2f       	mov	r22, r17
    2b2c:	77 27       	eor	r23, r23
    2b2e:	67 fd       	sbrc	r22, 7
    2b30:	7a 95       	dec	r23
    2b32:	8b e0       	ldi	r24, 0x0B	; 11
    2b34:	90 e0       	ldi	r25, 0x00	; 0
    2b36:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  write_CP2200(MACDATAL,value);
    2b3a:	8c e0       	ldi	r24, 0x0C	; 12
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	60 2f       	mov	r22, r16
    2b40:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  write_CP2200(MACRW,1);
    2b44:	8d e0       	ldi	r24, 0x0D	; 13
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	61 e0       	ldi	r22, 0x01	; 1
    2b4a:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
}
    2b4e:	1f 91       	pop	r17
    2b50:	0f 91       	pop	r16
    2b52:	08 95       	ret

00002b54 <Init_CP2000>:
	
}

// ---------------------------------------------
void Init_CP2000(void)
{
    2b54:	0f 93       	push	r16
    2b56:	1f 93       	push	r17
    2b58:	cf 93       	push	r28
    2b5a:	df 93       	push	r29
	unsigned char tmp;
	unsigned int tmp16;
	unsigned int timeout;
  //reset CP220x
  read_CP2200(CP2200_INT0); //clear CP2200 INT0
    2b5c:	83 e6       	ldi	r24, 0x63	; 99
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
  write_CP2200(SWRST,4);
    2b64:	85 e7       	ldi	r24, 0x75	; 117
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	64 e0       	ldi	r22, 0x04	; 4
    2b6a:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  while (!(read_CP2200(CP2200_INT0)& 0x20)); //wait for reset complete
    2b6e:	83 e6       	ldi	r24, 0x63	; 99
    2b70:	90 e0       	ldi	r25, 0x00	; 0
    2b72:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2b76:	85 ff       	sbrs	r24, 5
    2b78:	fa cf       	rjmp	.-12     	; 0x2b6e <Init_CP2000+0x1a>

  
//PHY INIT
  write_CP2200(PHYCF,0xFE);
    2b7a:	89 e7       	ldi	r24, 0x79	; 121
    2b7c:	90 e0       	ldi	r25, 0x00	; 0
    2b7e:	6e ef       	ldi	r22, 0xFE	; 254
    2b80:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  write_CP2200(PHYCN,0x00);
    2b84:	88 e7       	ldi	r24, 0x78	; 120
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	60 e0       	ldi	r22, 0x00	; 0
    2b8a:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
    2b8e:	08 e8       	ldi	r16, 0x88	; 136
    2b90:	13 e1       	ldi	r17, 0x13	; 19
    2b92:	c8 01       	movw	r24, r16
    2b94:	01 97       	sbiw	r24, 0x01	; 1
    2b96:	f1 f7       	brne	.-4      	; 0x2b94 <Init_CP2000+0x40>
  _delay_ms(1);
  read_CP2200(CP2200_INT1); 
    2b98:	8f e7       	ldi	r24, 0x7F	; 127
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
  write_CP2200(PHYCN,0x80);
    2ba0:	88 e7       	ldi	r24, 0x78	; 120
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	60 e8       	ldi	r22, 0x80	; 128
    2ba6:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
    2baa:	c8 01       	movw	r24, r16
    2bac:	01 97       	sbiw	r24, 0x01	; 1
    2bae:	f1 f7       	brne	.-4      	; 0x2bac <Init_CP2000+0x58>
  _delay_ms(1);
  write_CP2200(PHYCN,0xE0);
    2bb0:	88 e7       	ldi	r24, 0x78	; 120
    2bb2:	90 e0       	ldi	r25, 0x00	; 0
    2bb4:	60 ee       	ldi	r22, 0xE0	; 224
    2bb6:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
    2bba:	8e ee       	ldi	r24, 0xEE	; 238
    2bbc:	92 e0       	ldi	r25, 0x02	; 2
    2bbe:	24 ef       	ldi	r18, 0xF4	; 244
    2bc0:	31 e0       	ldi	r19, 0x01	; 1
    2bc2:	f9 01       	movw	r30, r18
    2bc4:	31 97       	sbiw	r30, 0x01	; 1
    2bc6:	f1 f7       	brne	.-4      	; 0x2bc4 <Init_CP2000+0x70>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2bc8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2bca:	d9 f7       	brne	.-10     	; 0x2bc2 <Init_CP2000+0x6e>
    2bcc:	c8 eb       	ldi	r28, 0xB8	; 184
    2bce:	db e0       	ldi	r29, 0x0B	; 11
    2bd0:	08 e8       	ldi	r16, 0x88	; 136
    2bd2:	13 e1       	ldi	r17, 0x13	; 19
    2bd4:	04 c0       	rjmp	.+8      	; 0x2bde <Init_CP2000+0x8a>
    2bd6:	c8 01       	movw	r24, r16
    2bd8:	01 97       	sbiw	r24, 0x01	; 1
    2bda:	f1 f7       	brne	.-4      	; 0x2bd8 <Init_CP2000+0x84>
  _delay_ms(75);
	timeout=3000;
  while ((!(read_CP2200(CP2200_INT1)& 0x01)) && (timeout > 0))
	{
		_delay_ms(1);
		timeout--;
    2bdc:	21 97       	sbiw	r28, 0x01	; 1
  write_CP2200(PHYCN,0x80);
  _delay_ms(1);
  write_CP2200(PHYCN,0xE0);
  _delay_ms(75);
	timeout=3000;
  while ((!(read_CP2200(CP2200_INT1)& 0x01)) && (timeout > 0))
    2bde:	8f e7       	ldi	r24, 0x7F	; 127
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2be6:	80 fd       	sbrc	r24, 0
    2be8:	03 c0       	rjmp	.+6      	; 0x2bf0 <Init_CP2000+0x9c>
    2bea:	20 97       	sbiw	r28, 0x00	; 0
    2bec:	a1 f7       	brne	.-24     	; 0x2bd6 <Init_CP2000+0x82>
    2bee:	02 c0       	rjmp	.+4      	; 0x2bf4 <Init_CP2000+0xa0>
	{
		_delay_ms(1);
		timeout--;
	}
	if (timeout < 1)
    2bf0:	cd 2b       	or	r28, r29
    2bf2:	21 f4       	brne	.+8      	; 0x2bfc <Init_CP2000+0xa8>
	{
		uart_puts_P(PSTR("timeout\r\n"));
    2bf4:	8e e9       	ldi	r24, 0x9E	; 158
    2bf6:	92 e0       	ldi	r25, 0x02	; 2
    2bf8:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    2bfc:	c8 eb       	ldi	r28, 0xB8	; 184
    2bfe:	db e0       	ldi	r29, 0x0B	; 11
    2c00:	08 e8       	ldi	r16, 0x88	; 136
    2c02:	13 e1       	ldi	r17, 0x13	; 19
    2c04:	04 c0       	rjmp	.+8      	; 0x2c0e <Init_CP2000+0xba>
    2c06:	c8 01       	movw	r24, r16
    2c08:	01 97       	sbiw	r24, 0x01	; 1
    2c0a:	f1 f7       	brne	.-4      	; 0x2c08 <Init_CP2000+0xb4>
	}
	timeout=3000;
  while ((!(read_CP2200(PHYCN)& 0x01)) && (timeout > 0))
	{
		_delay_ms(1);
		timeout--;
    2c0c:	21 97       	sbiw	r28, 0x01	; 1
	if (timeout < 1)
	{
		uart_puts_P(PSTR("timeout\r\n"));
	}
	timeout=3000;
  while ((!(read_CP2200(PHYCN)& 0x01)) && (timeout > 0))
    2c0e:	88 e7       	ldi	r24, 0x78	; 120
    2c10:	90 e0       	ldi	r25, 0x00	; 0
    2c12:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2c16:	80 fd       	sbrc	r24, 0
    2c18:	03 c0       	rjmp	.+6      	; 0x2c20 <Init_CP2000+0xcc>
    2c1a:	20 97       	sbiw	r28, 0x00	; 0
    2c1c:	a1 f7       	brne	.-24     	; 0x2c06 <Init_CP2000+0xb2>
    2c1e:	02 c0       	rjmp	.+4      	; 0x2c24 <Init_CP2000+0xd0>
	{
		_delay_ms(1);
		timeout--;
	}
	if (timeout < 1)
    2c20:	cd 2b       	or	r28, r29
    2c22:	21 f4       	brne	.+8      	; 0x2c2c <Init_CP2000+0xd8>
	{
		uart_puts_P(PSTR("timeout\r\n"));
    2c24:	84 e9       	ldi	r24, 0x94	; 148
    2c26:	92 e0       	ldi	r25, 0x02	; 2
    2c28:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	}
	//MAC INIT
  cpWriteMac(MACCF,0x40B3);
    2c2c:	81 e0       	ldi	r24, 0x01	; 1
    2c2e:	63 eb       	ldi	r22, 0xB3	; 179
    2c30:	70 e4       	ldi	r23, 0x40	; 64
    2c32:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
  cpWriteMac(IPGT,0x0015);
    2c36:	82 e0       	ldi	r24, 0x02	; 2
    2c38:	65 e1       	ldi	r22, 0x15	; 21
    2c3a:	70 e0       	ldi	r23, 0x00	; 0
    2c3c:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
  cpWriteMac(IPGR,0x0C12);
    2c40:	83 e0       	ldi	r24, 0x03	; 3
    2c42:	62 e1       	ldi	r22, 0x12	; 18
    2c44:	7c e0       	ldi	r23, 0x0C	; 12
    2c46:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
  cpWriteMac(MAXLEN,0x05EE);
    2c4a:	85 e0       	ldi	r24, 0x05	; 5
    2c4c:	6e ee       	ldi	r22, 0xEE	; 238
    2c4e:	75 e0       	ldi	r23, 0x05	; 5
    2c50:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
  write_CP2200(FLASHADDRL,0xFA);
    2c54:	88 e6       	ldi	r24, 0x68	; 104
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	6a ef       	ldi	r22, 0xFA	; 250
    2c5a:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  write_CP2200(FLASHADDRH,0x1F);
    2c5e:	89 e6       	ldi	r24, 0x69	; 105
    2c60:	90 e0       	ldi	r25, 0x00	; 0
    2c62:	6f e1       	ldi	r22, 0x1F	; 31
    2c64:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  tmp16 = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
    2c68:	85 e0       	ldi	r24, 0x05	; 5
    2c6a:	90 e0       	ldi	r25, 0x00	; 0
    2c6c:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2c70:	08 2f       	mov	r16, r24
    2c72:	10 e0       	ldi	r17, 0x00	; 0
  tmp16 |=read_CP2200(FLASHAUTORD)<<8;
    2c74:	85 e0       	ldi	r24, 0x05	; 5
    2c76:	90 e0       	ldi	r25, 0x00	; 0
    2c78:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
  cpWriteMac(MACAD2,tmp16);
    2c7c:	78 2f       	mov	r23, r24
    2c7e:	60 e0       	ldi	r22, 0x00	; 0
    2c80:	60 2b       	or	r22, r16
    2c82:	71 2b       	or	r23, r17
    2c84:	82 e1       	ldi	r24, 0x12	; 18
    2c86:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
	tmp16 = 0x0000;
  tmp16 = read_CP2200(FLASHAUTORD);
    2c8a:	85 e0       	ldi	r24, 0x05	; 5
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2c92:	08 2f       	mov	r16, r24
    2c94:	10 e0       	ldi	r17, 0x00	; 0
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
    2c96:	85 e0       	ldi	r24, 0x05	; 5
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
  cpWriteMac(MACAD1,tmp16);
    2c9e:	78 2f       	mov	r23, r24
    2ca0:	60 e0       	ldi	r22, 0x00	; 0
    2ca2:	60 2b       	or	r22, r16
    2ca4:	71 2b       	or	r23, r17
    2ca6:	81 e1       	ldi	r24, 0x11	; 17
    2ca8:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
  tmp = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
    2cac:	85 e0       	ldi	r24, 0x05	; 5
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2cb4:	08 2f       	mov	r16, r24
    2cb6:	10 e0       	ldi	r17, 0x00	; 0
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
    2cb8:	85 e0       	ldi	r24, 0x05	; 5
    2cba:	90 e0       	ldi	r25, 0x00	; 0
    2cbc:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
  cpWriteMac(MACAD0,tmp16);
    2cc0:	78 2f       	mov	r23, r24
    2cc2:	60 e0       	ldi	r22, 0x00	; 0
    2cc4:	60 2b       	or	r22, r16
    2cc6:	71 2b       	or	r23, r17
    2cc8:	80 e1       	ldi	r24, 0x10	; 16
    2cca:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
	write_CP2200(IOPWR,0x0C);
    2cce:	80 e7       	ldi	r24, 0x70	; 112
    2cd0:	90 e0       	ldi	r25, 0x00	; 0
    2cd2:	6c e0       	ldi	r22, 0x0C	; 12
    2cd4:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
  cpWriteMac(MACCN,0x01);
    2cd8:	80 e0       	ldi	r24, 0x00	; 0
    2cda:	61 e0       	ldi	r22, 0x01	; 1
    2cdc:	70 e0       	ldi	r23, 0x00	; 0
    2cde:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <cpWriteMac>
	write_CP2200(INT0EN,0x03);
    2ce2:	84 e6       	ldi	r24, 0x64	; 100
    2ce4:	90 e0       	ldi	r25, 0x00	; 0
    2ce6:	63 e0       	ldi	r22, 0x03	; 3
    2ce8:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(INT1EN,0x00);
    2cec:	8d e7       	ldi	r24, 0x7D	; 125
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	60 e0       	ldi	r22, 0x00	; 0
    2cf2:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	read_CP2200(CP2200_INT0); 
    2cf6:	83 e6       	ldi	r24, 0x63	; 99
    2cf8:	90 e0       	ldi	r25, 0x00	; 0
    2cfa:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
	read_CP2200(CP2200_INT1); 
    2cfe:	8f e7       	ldi	r24, 0x7F	; 127
    2d00:	90 e0       	ldi	r25, 0x00	; 0
    2d02:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
}
    2d06:	df 91       	pop	r29
    2d08:	cf 91       	pop	r28
    2d0a:	1f 91       	pop	r17
    2d0c:	0f 91       	pop	r16
    2d0e:	08 95       	ret

00002d10 <network_device_read>:
	return(packetlen);
}

// ---------------------------------------------
u16_t network_device_read(void)
{
    2d10:	cf 93       	push	r28
    2d12:	df 93       	push	r29
	u16_t  packetlen=0;
	int cp_bufptr; // Zeiger auf Paket Puffer
	CP2200_status = read_CP2200(CP2200_INT0);
    2d14:	83 e6       	ldi	r24, 0x63	; 99
    2d16:	90 e0       	ldi	r25, 0x00	; 0
    2d18:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2d1c:	80 93 ac 03 	sts	0x03AC, r24
	if ((CP2200_status & 0x02) == 0x02)
    2d20:	81 ff       	sbrs	r24, 1
    2d22:	0e c0       	rjmp	.+28     	; 0x2d40 <network_device_read+0x30>
	{
		uart_puts_P(PSTR("CP2200 buffer full\r\n"));	
    2d24:	82 eb       	ldi	r24, 0xB2	; 178
    2d26:	92 e0       	ldi	r25, 0x02	; 2
    2d28:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
		write_CP2200(RXCN,0x01);
    2d2c:	81 e1       	ldi	r24, 0x11	; 17
    2d2e:	90 e0       	ldi	r25, 0x00	; 0
    2d30:	61 e0       	ldi	r22, 0x01	; 1
    2d32:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
		write_CP2200(RXCN,0x00);
    2d36:	81 e1       	ldi	r24, 0x11	; 17
    2d38:	90 e0       	ldi	r25, 0x00	; 0
    2d3a:	60 e0       	ldi	r22, 0x00	; 0
    2d3c:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	}
	CP2200_status=0;
    2d40:	10 92 ac 03 	sts	0x03AC, r1
	// Paket im Empfangspuffer?
	if (((read_CP2200(CPINFOH) &0x80) != 0) && (read_CP2200(CPINFOL) &0x80) != 0)
    2d44:	8d e1       	ldi	r24, 0x1D	; 29
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2d4c:	87 ff       	sbrs	r24, 7
    2d4e:	18 c0       	rjmp	.+48     	; 0x2d80 <network_device_read+0x70>
    2d50:	8e e1       	ldi	r24, 0x1E	; 30
    2d52:	90 e0       	ldi	r25, 0x00	; 0
    2d54:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2d58:	87 ff       	sbrs	r24, 7
    2d5a:	12 c0       	rjmp	.+36     	; 0x2d80 <network_device_read+0x70>
	{
		PORTB |= (1<<PB0); // set PB0 = LED OFF
    2d5c:	28 9a       	sbi	0x05, 0	; 5
		
		// Zeiger auf Paket Puffer merken
		cp_bufptr = read_CP2200(RXFIFOHEADH);
    2d5e:	87 e1       	ldi	r24, 0x17	; 23
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
		cp_bufptr = cp_bufptr << 8;
		cp_bufptr |= read_CP2200(RXFIFOHEADL);
    2d66:	88 e1       	ldi	r24, 0x18	; 24
    2d68:	90 e0       	ldi	r25, 0x00	; 0
    2d6a:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
	
		packetlen = CP2200_ReadPacket();
    2d6e:	0e 94 3d 15 	call	0x2a7a	; 0x2a7a <CP2200_ReadPacket>
    2d72:	ec 01       	movw	r28, r24
		write_CP2200(RXCN,0x06); // discharge package
    2d74:	81 e1       	ldi	r24, 0x11	; 17
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	66 e0       	ldi	r22, 0x06	; 6
    2d7a:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
    2d7e:	02 c0       	rjmp	.+4      	; 0x2d84 <network_device_read+0x74>
    2d80:	c0 e0       	ldi	r28, 0x00	; 0
    2d82:	d0 e0       	ldi	r29, 0x00	; 0

		//	write_CP2200(RXCN,0x04); // discharge package
	}
	return(packetlen);
}
    2d84:	ce 01       	movw	r24, r28
    2d86:	df 91       	pop	r29
    2d88:	cf 91       	pop	r28
    2d8a:	08 95       	ret

00002d8c <network_device_init>:
}


// ---------------------------------------------
void network_device_init(void)
{
    2d8c:	ef 92       	push	r14
    2d8e:	ff 92       	push	r15
    2d90:	0f 93       	push	r16
    2d92:	1f 93       	push	r17
    2d94:	df 93       	push	r29
    2d96:	cf 93       	push	r28
    2d98:	cd b7       	in	r28, 0x3d	; 61
    2d9a:	de b7       	in	r29, 0x3e	; 62
    2d9c:	60 97       	sbiw	r28, 0x10	; 16
    2d9e:	0f b6       	in	r0, 0x3f	; 63
    2da0:	f8 94       	cli
    2da2:	de bf       	out	0x3e, r29	; 62
    2da4:	0f be       	out	0x3f, r0	; 63
    2da6:	cd bf       	out	0x3d, r28	; 61
	char hexstr[10];
	uip_ipaddr_t ipaddr;
	struct uip_eth_addr eaddr;
	unsigned int i;
	
	Init_CP2000();
    2da8:	0e 94 aa 15 	call	0x2b54	; 0x2b54 <Init_CP2000>
	
	// own mac address (get from CP2200 flash memory)
	write_CP2200(FLASHADDRL,0xFA);
    2dac:	88 e6       	ldi	r24, 0x68	; 104
    2dae:	90 e0       	ldi	r25, 0x00	; 0
    2db0:	6a ef       	ldi	r22, 0xFA	; 250
    2db2:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	write_CP2200(FLASHADDRH,0x1F);
    2db6:	89 e6       	ldi	r24, 0x69	; 105
    2db8:	90 e0       	ldi	r25, 0x00	; 0
    2dba:	6f e1       	ldi	r22, 0x1F	; 31
    2dbc:	0e 94 74 14 	call	0x28e8	; 0x28e8 <write_CP2200>
	uart_puts_P(PSTR("\n\rMAC:"));
    2dc0:	8b ea       	ldi	r24, 0xAB	; 171
    2dc2:	92 e0       	ldi	r25, 0x02	; 2
    2dc4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    2dc8:	8e 01       	movw	r16, r28
    2dca:	0f 5f       	subi	r16, 0xFF	; 255
    2dcc:	1f 4f       	sbci	r17, 0xFF	; 255
	for (i=0;i<6;i++)
	{
		eaddr.addr[i]=read_CP2200(FLASHAUTORD); // mac address from CP2200 
		itohex(hexstr,eaddr.addr[i] , 2);
    2dce:	97 e0       	ldi	r25, 0x07	; 7
    2dd0:	e9 2e       	mov	r14, r25
    2dd2:	f1 2c       	mov	r15, r1
    2dd4:	ec 0e       	add	r14, r28
    2dd6:	fd 1e       	adc	r15, r29
	write_CP2200(FLASHADDRL,0xFA);
	write_CP2200(FLASHADDRH,0x1F);
	uart_puts_P(PSTR("\n\rMAC:"));
	for (i=0;i<6;i++)
	{
		eaddr.addr[i]=read_CP2200(FLASHAUTORD); // mac address from CP2200 
    2dd8:	85 e0       	ldi	r24, 0x05	; 5
    2dda:	90 e0       	ldi	r25, 0x00	; 0
    2ddc:	0e 94 ad 14 	call	0x295a	; 0x295a <read_CP2200>
    2de0:	68 2f       	mov	r22, r24
    2de2:	f8 01       	movw	r30, r16
    2de4:	81 93       	st	Z+, r24
    2de6:	8f 01       	movw	r16, r30
		itohex(hexstr,eaddr.addr[i] , 2);
    2de8:	c7 01       	movw	r24, r14
    2dea:	70 e0       	ldi	r23, 0x00	; 0
    2dec:	42 e0       	ldi	r20, 0x02	; 2
    2dee:	0e 94 72 10 	call	0x20e4	; 0x20e4 <itohex>
		uart_puts(hexstr);
    2df2:	c7 01       	movw	r24, r14
    2df4:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
	
	// own mac address (get from CP2200 flash memory)
	write_CP2200(FLASHADDRL,0xFA);
	write_CP2200(FLASHADDRH,0x1F);
	uart_puts_P(PSTR("\n\rMAC:"));
	for (i=0;i<6;i++)
    2df8:	0e 15       	cp	r16, r14
    2dfa:	1f 05       	cpc	r17, r15
    2dfc:	69 f7       	brne	.-38     	; 0x2dd8 <network_device_init+0x4c>
		eaddr.addr[i]=read_CP2200(FLASHAUTORD); // mac address from CP2200 
		itohex(hexstr,eaddr.addr[i] , 2);
		uart_puts(hexstr);
		
	}
	uart_puts_P(PSTR("\n\r"));
    2dfe:	88 ea       	ldi	r24, 0xA8	; 168
    2e00:	92 e0       	ldi	r25, 0x02	; 2
    2e02:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
	// set mac address of this modules 
	uip_setethaddr(eaddr);
    2e06:	89 81       	ldd	r24, Y+1	; 0x01
    2e08:	80 93 ad 03 	sts	0x03AD, r24
    2e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e0e:	80 93 ae 03 	sts	0x03AE, r24
    2e12:	8b 81       	ldd	r24, Y+3	; 0x03
    2e14:	80 93 af 03 	sts	0x03AF, r24
    2e18:	8c 81       	ldd	r24, Y+4	; 0x04
    2e1a:	80 93 b0 03 	sts	0x03B0, r24
    2e1e:	8d 81       	ldd	r24, Y+5	; 0x05
    2e20:	80 93 b1 03 	sts	0x03B1, r24
    2e24:	8e 81       	ldd	r24, Y+6	; 0x06
    2e26:	80 93 b2 03 	sts	0x03B2, r24
	
	// set netmask
	uip_ipaddr(ipaddr, 255,255,255,0);
	uip_setnetmask(ipaddr);
    2e2a:	8f ef       	ldi	r24, 0xFF	; 255
    2e2c:	9f ef       	ldi	r25, 0xFF	; 255
    2e2e:	90 93 01 06 	sts	0x0601, r25
    2e32:	80 93 00 06 	sts	0x0600, r24
    2e36:	8f ef       	ldi	r24, 0xFF	; 255
    2e38:	90 e0       	ldi	r25, 0x00	; 0
    2e3a:	90 93 03 06 	sts	0x0603, r25
    2e3e:	80 93 02 06 	sts	0x0602, r24
	
	// set ip address of this module
	uip_ipaddr(ipaddr, 192,168,42,42);
	uip_sethostaddr(ipaddr);
    2e42:	20 ec       	ldi	r18, 0xC0	; 192
    2e44:	38 ea       	ldi	r19, 0xA8	; 168
    2e46:	30 93 05 06 	sts	0x0605, r19
    2e4a:	20 93 04 06 	sts	0x0604, r18
    2e4e:	8a e2       	ldi	r24, 0x2A	; 42
    2e50:	9a e2       	ldi	r25, 0x2A	; 42
    2e52:	90 93 07 06 	sts	0x0607, r25
    2e56:	80 93 06 06 	sts	0x0606, r24
	
	// set gateway address (default router address)
	uip_ipaddr(ipaddr, 192,168,42,2);
	uip_setdraddr(ipaddr);
    2e5a:	30 93 d1 05 	sts	0x05D1, r19
    2e5e:	20 93 d0 05 	sts	0x05D0, r18
    2e62:	8a e2       	ldi	r24, 0x2A	; 42
    2e64:	92 e0       	ldi	r25, 0x02	; 2
    2e66:	90 93 d3 05 	sts	0x05D3, r25
    2e6a:	80 93 d2 05 	sts	0x05D2, r24
	
}
    2e6e:	60 96       	adiw	r28, 0x10	; 16
    2e70:	0f b6       	in	r0, 0x3f	; 63
    2e72:	f8 94       	cli
    2e74:	de bf       	out	0x3e, r29	; 62
    2e76:	0f be       	out	0x3f, r0	; 63
    2e78:	cd bf       	out	0x3d, r28	; 61
    2e7a:	cf 91       	pop	r28
    2e7c:	df 91       	pop	r29
    2e7e:	1f 91       	pop	r17
    2e80:	0f 91       	pop	r16
    2e82:	ff 90       	pop	r15
    2e84:	ef 90       	pop	r14
    2e86:	08 95       	ret

00002e88 <uip_setipid>:

static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
    2e88:	90 93 b4 03 	sts	0x03B4, r25
    2e8c:	80 93 b3 03 	sts	0x03B3, r24
    2e90:	08 95       	ret

00002e92 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    2e92:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    2e94:	53 81       	ldd	r21, Z+3	; 0x03
    2e96:	56 0f       	add	r21, r22
    2e98:	50 93 6c 04 	sts	0x046C, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    2e9c:	27 2f       	mov	r18, r23
    2e9e:	33 27       	eor	r19, r19
    2ea0:	42 81       	ldd	r20, Z+2	; 0x02
    2ea2:	42 0f       	add	r20, r18
    2ea4:	40 93 6b 04 	sts	0x046B, r20
  uip_acc32[1] = op32[1];
    2ea8:	a1 81       	ldd	r26, Z+1	; 0x01
    2eaa:	a0 93 6a 04 	sts	0x046A, r26
  uip_acc32[0] = op32[0];
    2eae:	e0 81       	ld	r30, Z
    2eb0:	e0 93 69 04 	sts	0x0469, r30
  
  if(uip_acc32[2] < (op16 >> 8)) {
    2eb4:	84 2f       	mov	r24, r20
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	82 17       	cp	r24, r18
    2eba:	93 07       	cpc	r25, r19
    2ebc:	48 f4       	brcc	.+18     	; 0x2ed0 <uip_add32+0x3e>
    ++uip_acc32[1];
    2ebe:	8a 2f       	mov	r24, r26
    2ec0:	8f 5f       	subi	r24, 0xFF	; 255
    2ec2:	80 93 6a 04 	sts	0x046A, r24
    if(uip_acc32[1] == 0) {
    2ec6:	88 23       	and	r24, r24
    2ec8:	19 f4       	brne	.+6      	; 0x2ed0 <uip_add32+0x3e>
      ++uip_acc32[0];
    2eca:	ef 5f       	subi	r30, 0xFF	; 255
    2ecc:	e0 93 69 04 	sts	0x0469, r30
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
    2ed0:	85 2f       	mov	r24, r21
    2ed2:	90 e0       	ldi	r25, 0x00	; 0
    2ed4:	70 70       	andi	r23, 0x00	; 0
    2ed6:	86 17       	cp	r24, r22
    2ed8:	97 07       	cpc	r25, r23
    2eda:	90 f4       	brcc	.+36     	; 0x2f00 <uip_add32+0x6e>
    ++uip_acc32[2];
    2edc:	84 2f       	mov	r24, r20
    2ede:	8f 5f       	subi	r24, 0xFF	; 255
    2ee0:	80 93 6b 04 	sts	0x046B, r24
    if(uip_acc32[2] == 0) {
    2ee4:	88 23       	and	r24, r24
    2ee6:	61 f4       	brne	.+24     	; 0x2f00 <uip_add32+0x6e>
      ++uip_acc32[1];
    2ee8:	80 91 6a 04 	lds	r24, 0x046A
    2eec:	8f 5f       	subi	r24, 0xFF	; 255
    2eee:	80 93 6a 04 	sts	0x046A, r24
      if(uip_acc32[1] == 0) {
    2ef2:	88 23       	and	r24, r24
    2ef4:	29 f4       	brne	.+10     	; 0x2f00 <uip_add32+0x6e>
	++uip_acc32[0];
    2ef6:	80 91 69 04 	lds	r24, 0x0469
    2efa:	8f 5f       	subi	r24, 0xFF	; 255
    2efc:	80 93 69 04 	sts	0x0469, r24
    2f00:	08 95       	ret

00002f02 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    2f02:	9c 01       	movw	r18, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    2f04:	41 50       	subi	r20, 0x01	; 1
    2f06:	50 40       	sbci	r21, 0x00	; 0
    2f08:	46 0f       	add	r20, r22
    2f0a:	57 1f       	adc	r21, r23
    2f0c:	fb 01       	movw	r30, r22
    2f0e:	0e c0       	rjmp	.+28     	; 0x2f2c <chksum+0x2a>
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    2f10:	70 81       	ld	r23, Z
    2f12:	60 e0       	ldi	r22, 0x00	; 0
    2f14:	81 81       	ldd	r24, Z+1	; 0x01
    2f16:	db 01       	movw	r26, r22
    2f18:	a8 0f       	add	r26, r24
    2f1a:	b1 1d       	adc	r27, r1
    sum += t;
    2f1c:	2a 0f       	add	r18, r26
    2f1e:	3b 1f       	adc	r19, r27
    if(sum < t) {
    2f20:	2a 17       	cp	r18, r26
    2f22:	3b 07       	cpc	r19, r27
    2f24:	10 f4       	brcc	.+4      	; 0x2f2a <chksum+0x28>
      sum++;		/* carry */
    2f26:	2f 5f       	subi	r18, 0xFF	; 255
    2f28:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    2f2a:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    2f2c:	e4 17       	cp	r30, r20
    2f2e:	f5 07       	cpc	r31, r21
    2f30:	78 f3       	brcs	.-34     	; 0x2f10 <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    2f32:	e4 17       	cp	r30, r20
    2f34:	f5 07       	cpc	r31, r21
    2f36:	49 f4       	brne	.+18     	; 0x2f4a <chksum+0x48>
    t = (dataptr[0] << 8) + 0;
    2f38:	90 81       	ld	r25, Z
    2f3a:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    2f3c:	28 0f       	add	r18, r24
    2f3e:	39 1f       	adc	r19, r25
    if(sum < t) {
    2f40:	28 17       	cp	r18, r24
    2f42:	39 07       	cpc	r19, r25
    2f44:	10 f4       	brcc	.+4      	; 0x2f4a <chksum+0x48>
      sum++;		/* carry */
    2f46:	2f 5f       	subi	r18, 0xFF	; 255
    2f48:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    2f4a:	c9 01       	movw	r24, r18
    2f4c:	08 95       	ret

00002f4e <uip_chksum>:
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    2f4e:	9c 01       	movw	r18, r24
    2f50:	ab 01       	movw	r20, r22
  return htons(chksum(0, (u8_t *)data, len));
    2f52:	80 e0       	ldi	r24, 0x00	; 0
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	b9 01       	movw	r22, r18
    2f58:	0e 94 81 17 	call	0x2f02	; 0x2f02 <chksum>
    2f5c:	28 2f       	mov	r18, r24
}
    2f5e:	89 2f       	mov	r24, r25
    2f60:	92 2f       	mov	r25, r18
    2f62:	08 95       	ret

00002f64 <uip_ipchksum>:
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    2f64:	80 e0       	ldi	r24, 0x00	; 0
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	66 e1       	ldi	r22, 0x16	; 22
    2f6a:	76 e0       	ldi	r23, 0x06	; 6
    2f6c:	44 e1       	ldi	r20, 0x14	; 20
    2f6e:	50 e0       	ldi	r21, 0x00	; 0
    2f70:	0e 94 81 17 	call	0x2f02	; 0x2f02 <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    2f74:	00 97       	sbiw	r24, 0x00	; 0
    2f76:	19 f4       	brne	.+6      	; 0x2f7e <uip_ipchksum+0x1a>
    2f78:	2f ef       	ldi	r18, 0xFF	; 255
    2f7a:	3f ef       	ldi	r19, 0xFF	; 255
    2f7c:	02 c0       	rjmp	.+4      	; 0x2f82 <uip_ipchksum+0x1e>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    2f7e:	38 2f       	mov	r19, r24
    2f80:	29 2f       	mov	r18, r25
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
}
    2f82:	c9 01       	movw	r24, r18
    2f84:	08 95       	ret

00002f86 <upper_layer_chksum>:
#endif
/*---------------------------------------------------------------------------*/
static u16_t
upper_layer_chksum(u8_t proto)
{
    2f86:	0f 93       	push	r16
    2f88:	1f 93       	push	r17
  u16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    2f8a:	00 91 19 06 	lds	r16, 0x0619
    2f8e:	10 e0       	ldi	r17, 0x00	; 0
    2f90:	04 51       	subi	r16, 0x14	; 20
    2f92:	10 40       	sbci	r17, 0x00	; 0
    2f94:	30 91 18 06 	lds	r19, 0x0618
    2f98:	20 e0       	ldi	r18, 0x00	; 0
    2f9a:	02 0f       	add	r16, r18
    2f9c:	13 1f       	adc	r17, r19
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
    2f9e:	98 01       	movw	r18, r16
    2fa0:	28 0f       	add	r18, r24
    2fa2:	31 1d       	adc	r19, r1
    2fa4:	c9 01       	movw	r24, r18
    2fa6:	62 e2       	ldi	r22, 0x22	; 34
    2fa8:	76 e0       	ldi	r23, 0x06	; 6
    2faa:	48 e0       	ldi	r20, 0x08	; 8
    2fac:	50 e0       	ldi	r21, 0x00	; 0
    2fae:	0e 94 81 17 	call	0x2f02	; 0x2f02 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    2fb2:	6a e2       	ldi	r22, 0x2A	; 42
    2fb4:	76 e0       	ldi	r23, 0x06	; 6
    2fb6:	a8 01       	movw	r20, r16
    2fb8:	0e 94 81 17 	call	0x2f02	; 0x2f02 <chksum>
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
    2fbc:	00 97       	sbiw	r24, 0x00	; 0
    2fbe:	19 f4       	brne	.+6      	; 0x2fc6 <upper_layer_chksum+0x40>
    2fc0:	2f ef       	ldi	r18, 0xFF	; 255
    2fc2:	3f ef       	ldi	r19, 0xFF	; 255
    2fc4:	02 c0       	rjmp	.+4      	; 0x2fca <upper_layer_chksum+0x44>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    2fc6:	38 2f       	mov	r19, r24
    2fc8:	29 2f       	mov	r18, r25
  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
}
    2fca:	c9 01       	movw	r24, r18
    2fcc:	1f 91       	pop	r17
    2fce:	0f 91       	pop	r16
    2fd0:	08 95       	ret

00002fd2 <uip_tcpchksum>:
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
    2fd2:	86 e0       	ldi	r24, 0x06	; 6
    2fd4:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <upper_layer_chksum>
}
    2fd8:	08 95       	ret

00002fda <uip_udpchksum>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
u16_t
uip_udpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_UDP);
    2fda:	81 e1       	ldi	r24, 0x11	; 17
    2fdc:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <upper_layer_chksum>
}
    2fe0:	08 95       	ret

00002fe2 <uip_init>:
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
    2fe2:	80 e0       	ldi	r24, 0x00	; 0
    2fe4:	09 c0       	rjmp	.+18     	; 0x2ff8 <uip_init+0x16>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    2fe6:	e8 2f       	mov	r30, r24
    2fe8:	f0 e0       	ldi	r31, 0x00	; 0
    2fea:	ee 0f       	add	r30, r30
    2fec:	ff 1f       	adc	r31, r31
    2fee:	e4 53       	subi	r30, 0x34	; 52
    2ff0:	fa 4f       	sbci	r31, 0xFA	; 250
    2ff2:	11 82       	std	Z+1, r1	; 0x01
    2ff4:	10 82       	st	Z, r1
    2ff6:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2ff8:	82 30       	cpi	r24, 0x02	; 2
    2ffa:	a8 f3       	brcs	.-22     	; 0x2fe6 <uip_init+0x4>
    2ffc:	20 e0       	ldi	r18, 0x00	; 0
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    2ffe:	4d ea       	ldi	r20, 0xAD	; 173
    3000:	50 e0       	ldi	r21, 0x00	; 0
    3002:	0d c0       	rjmp	.+26     	; 0x301e <uip_init+0x3c>
    3004:	82 2f       	mov	r24, r18
    3006:	90 e0       	ldi	r25, 0x00	; 0
    3008:	84 9f       	mul	r24, r20
    300a:	f0 01       	movw	r30, r0
    300c:	85 9f       	mul	r24, r21
    300e:	f0 0d       	add	r31, r0
    3010:	94 9f       	mul	r25, r20
    3012:	f0 0d       	add	r31, r0
    3014:	11 24       	eor	r1, r1
    3016:	ee 58       	subi	r30, 0x8E	; 142
    3018:	fb 4f       	sbci	r31, 0xFB	; 251
    301a:	11 8e       	std	Z+25, r1	; 0x19
    301c:	2f 5f       	subi	r18, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    301e:	22 30       	cpi	r18, 0x02	; 2
    3020:	88 f3       	brcs	.-30     	; 0x3004 <uip_init+0x22>
    3022:	20 93 bb 03 	sts	0x03BB, r18
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    3026:	80 e0       	ldi	r24, 0x00	; 0
    3028:	94 e0       	ldi	r25, 0x04	; 4
    302a:	90 93 ba 03 	sts	0x03BA, r25
    302e:	80 93 b9 03 	sts	0x03B9, r24
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    3032:	08 95       	ret

00003034 <uip_connect>:
/*---------------------------------------------------------------------------*/
#if UIP_ACTIVE_OPEN
struct uip_conn *
uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
{
    3034:	cf 93       	push	r28
    3036:	df 93       	push	r29
    3038:	ec 01       	movw	r28, r24
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
    303a:	40 91 b9 03 	lds	r20, 0x03B9
    303e:	50 91 ba 03 	lds	r21, 0x03BA
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    3042:	bd ea       	ldi	r27, 0xAD	; 173
{
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    3044:	4f 5f       	subi	r20, 0xFF	; 255
    3046:	5f 4f       	sbci	r21, 0xFF	; 255

  if(lastport >= 32000) {
    3048:	8d e7       	ldi	r24, 0x7D	; 125
    304a:	40 30       	cpi	r20, 0x00	; 0
    304c:	58 07       	cpc	r21, r24
    304e:	10 f0       	brcs	.+4      	; 0x3054 <uip_connect+0x20>
    3050:	40 e0       	ldi	r20, 0x00	; 0
    3052:	50 e1       	ldi	r21, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    3054:	34 2f       	mov	r19, r20
    3056:	25 2f       	mov	r18, r21
    3058:	a0 e0       	ldi	r26, 0x00	; 0
    305a:	0e c0       	rjmp	.+28     	; 0x3078 <uip_connect+0x44>
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    305c:	ab 9f       	mul	r26, r27
    305e:	f0 01       	movw	r30, r0
    3060:	11 24       	eor	r1, r1
    3062:	ee 58       	subi	r30, 0x8E	; 142
    3064:	fb 4f       	sbci	r31, 0xFB	; 251
    if(conn->tcpstateflags != UIP_CLOSED &&
    3066:	81 8d       	ldd	r24, Z+25	; 0x19
    3068:	88 23       	and	r24, r24
    306a:	29 f0       	breq	.+10     	; 0x3076 <uip_connect+0x42>
    306c:	84 81       	ldd	r24, Z+4	; 0x04
    306e:	95 81       	ldd	r25, Z+5	; 0x05
    3070:	82 17       	cp	r24, r18
    3072:	93 07       	cpc	r25, r19
    3074:	39 f3       	breq	.-50     	; 0x3044 <uip_connect+0x10>
       conn->lport == htons(lastport)) {
      goto again;
    3076:	af 5f       	subi	r26, 0xFF	; 255
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    3078:	a2 30       	cpi	r26, 0x02	; 2
    307a:	81 f7       	brne	.-32     	; 0x305c <uip_connect+0x28>
    307c:	40 93 b9 03 	sts	0x03B9, r20
    3080:	50 93 ba 03 	sts	0x03BA, r21
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    3084:	10 92 bb 03 	sts	0x03BB, r1
    3088:	e0 e0       	ldi	r30, 0x00	; 0
    308a:	f0 e0       	ldi	r31, 0x00	; 0
    308c:	20 e0       	ldi	r18, 0x00	; 0
    cconn = &uip_conns[c];
    308e:	3d ea       	ldi	r19, 0xAD	; 173
    3090:	1a c0       	rjmp	.+52     	; 0x30c6 <uip_connect+0x92>
    3092:	23 9f       	mul	r18, r19
    3094:	d0 01       	movw	r26, r0
    3096:	11 24       	eor	r1, r1
    3098:	ae 58       	subi	r26, 0x8E	; 142
    309a:	bb 4f       	sbci	r27, 0xFB	; 251
    if(cconn->tcpstateflags == UIP_CLOSED) {
    309c:	59 96       	adiw	r26, 0x19	; 25
    309e:	8c 91       	ld	r24, X
    30a0:	59 97       	sbiw	r26, 0x19	; 25
    30a2:	88 23       	and	r24, r24
    30a4:	21 f4       	brne	.+8      	; 0x30ae <uip_connect+0x7a>
    30a6:	20 93 bb 03 	sts	0x03BB, r18
    30aa:	fd 01       	movw	r30, r26
    30ac:	10 c0       	rjmp	.+32     	; 0x30ce <uip_connect+0x9a>
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    30ae:	87 30       	cpi	r24, 0x07	; 7
    30b0:	49 f4       	brne	.+18     	; 0x30c4 <uip_connect+0x90>
      if(conn == 0 ||
    30b2:	30 97       	sbiw	r30, 0x00	; 0
    30b4:	31 f0       	breq	.+12     	; 0x30c2 <uip_connect+0x8e>
    30b6:	5a 96       	adiw	r26, 0x1a	; 26
    30b8:	9c 91       	ld	r25, X
    30ba:	5a 97       	sbiw	r26, 0x1a	; 26
    30bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    30be:	89 17       	cp	r24, r25
    30c0:	08 f4       	brcc	.+2      	; 0x30c4 <uip_connect+0x90>
    30c2:	fd 01       	movw	r30, r26
    30c4:	2f 5f       	subi	r18, 0xFF	; 255
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    30c6:	22 30       	cpi	r18, 0x02	; 2
    30c8:	20 f3       	brcs	.-56     	; 0x3092 <uip_connect+0x5e>
    30ca:	20 93 bb 03 	sts	0x03BB, r18
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    30ce:	30 97       	sbiw	r30, 0x00	; 0
    30d0:	61 f1       	breq	.+88     	; 0x312a <uip_connect+0xf6>
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;
    30d2:	82 e0       	ldi	r24, 0x02	; 2
    30d4:	81 8f       	std	Z+25, r24	; 0x19

  conn->snd_nxt[0] = iss[0];
    30d6:	80 91 b5 03 	lds	r24, 0x03B5
    30da:	84 87       	std	Z+12, r24	; 0x0c
  conn->snd_nxt[1] = iss[1];
    30dc:	80 91 b6 03 	lds	r24, 0x03B6
    30e0:	85 87       	std	Z+13, r24	; 0x0d
  conn->snd_nxt[2] = iss[2];
    30e2:	80 91 b7 03 	lds	r24, 0x03B7
    30e6:	86 87       	std	Z+14, r24	; 0x0e
  conn->snd_nxt[3] = iss[3];
    30e8:	80 91 b8 03 	lds	r24, 0x03B8
    30ec:	87 87       	std	Z+15, r24	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    30ee:	86 ea       	ldi	r24, 0xA6	; 166
    30f0:	95 e0       	ldi	r25, 0x05	; 5
    30f2:	93 8b       	std	Z+19, r25	; 0x13
    30f4:	82 8b       	std	Z+18, r24	; 0x12
    30f6:	95 8b       	std	Z+21, r25	; 0x15
    30f8:	84 8b       	std	Z+20, r24	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    30fa:	81 e0       	ldi	r24, 0x01	; 1
    30fc:	90 e0       	ldi	r25, 0x00	; 0
    30fe:	91 8b       	std	Z+17, r25	; 0x11
    3100:	80 8b       	std	Z+16, r24	; 0x10
  conn->nrtx = 0;
    3102:	13 8e       	std	Z+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    3104:	81 e0       	ldi	r24, 0x01	; 1
    3106:	82 8f       	std	Z+26, r24	; 0x1a
  conn->rto = UIP_RTO;
    3108:	83 e0       	ldi	r24, 0x03	; 3
    310a:	80 8f       	std	Z+24, r24	; 0x18
  conn->sa = 0;
    310c:	16 8a       	std	Z+22, r1	; 0x16
  conn->sv = 16;   /* Initial value of the RTT variance. */
    310e:	80 e1       	ldi	r24, 0x10	; 16
    3110:	87 8b       	std	Z+23, r24	; 0x17
  conn->lport = htons(lastport);
    3112:	54 83       	std	Z+4, r21	; 0x04
    3114:	45 83       	std	Z+5, r20	; 0x05
  conn->rport = rport;
    3116:	77 83       	std	Z+7, r23	; 0x07
    3118:	66 83       	std	Z+6, r22	; 0x06
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    311a:	88 81       	ld	r24, Y
    311c:	99 81       	ldd	r25, Y+1	; 0x01
    311e:	91 83       	std	Z+1, r25	; 0x01
    3120:	80 83       	st	Z, r24
    3122:	8a 81       	ldd	r24, Y+2	; 0x02
    3124:	9b 81       	ldd	r25, Y+3	; 0x03
    3126:	93 83       	std	Z+3, r25	; 0x03
    3128:	82 83       	std	Z+2, r24	; 0x02
  
  return conn;
}
    312a:	cf 01       	movw	r24, r30
    312c:	df 91       	pop	r29
    312e:	cf 91       	pop	r28
    3130:	08 95       	ret

00003132 <uip_unlisten>:
}
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
    3132:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    3134:	10 92 bb 03 	sts	0x03BB, r1
    3138:	20 e0       	ldi	r18, 0x00	; 0
    313a:	13 c0       	rjmp	.+38     	; 0x3162 <uip_unlisten+0x30>
    if(uip_listenports[c] == port) {
    313c:	e2 2f       	mov	r30, r18
    313e:	f0 e0       	ldi	r31, 0x00	; 0
    3140:	32 2f       	mov	r19, r18
    3142:	3f 5f       	subi	r19, 0xFF	; 255
    3144:	ee 0f       	add	r30, r30
    3146:	ff 1f       	adc	r31, r31
    3148:	e4 53       	subi	r30, 0x34	; 52
    314a:	fa 4f       	sbci	r31, 0xFA	; 250
    314c:	80 81       	ld	r24, Z
    314e:	91 81       	ldd	r25, Z+1	; 0x01
    3150:	84 17       	cp	r24, r20
    3152:	95 07       	cpc	r25, r21
    3154:	29 f4       	brne	.+10     	; 0x3160 <uip_unlisten+0x2e>
    3156:	20 93 bb 03 	sts	0x03BB, r18
      uip_listenports[c] = 0;
    315a:	11 82       	std	Z+1, r1	; 0x01
    315c:	10 82       	st	Z, r1
    315e:	08 95       	ret
      return;
    3160:	23 2f       	mov	r18, r19
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    3162:	22 30       	cpi	r18, 0x02	; 2
    3164:	58 f3       	brcs	.-42     	; 0x313c <uip_unlisten+0xa>
    3166:	20 93 bb 03 	sts	0x03BB, r18
    316a:	08 95       	ret

0000316c <uip_listen>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
    316c:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    316e:	10 92 bb 03 	sts	0x03BB, r1
    3172:	20 e0       	ldi	r18, 0x00	; 0
    3174:	12 c0       	rjmp	.+36     	; 0x319a <uip_listen+0x2e>
    if(uip_listenports[c] == 0) {
    3176:	e2 2f       	mov	r30, r18
    3178:	f0 e0       	ldi	r31, 0x00	; 0
    317a:	32 2f       	mov	r19, r18
    317c:	3f 5f       	subi	r19, 0xFF	; 255
    317e:	ee 0f       	add	r30, r30
    3180:	ff 1f       	adc	r31, r31
    3182:	e4 53       	subi	r30, 0x34	; 52
    3184:	fa 4f       	sbci	r31, 0xFA	; 250
    3186:	80 81       	ld	r24, Z
    3188:	91 81       	ldd	r25, Z+1	; 0x01
    318a:	89 2b       	or	r24, r25
    318c:	29 f4       	brne	.+10     	; 0x3198 <uip_listen+0x2c>
    318e:	20 93 bb 03 	sts	0x03BB, r18
      uip_listenports[c] = port;
    3192:	51 83       	std	Z+1, r21	; 0x01
    3194:	40 83       	st	Z, r20
    3196:	08 95       	ret
      return;
    3198:	23 2f       	mov	r18, r19
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    319a:	22 30       	cpi	r18, 0x02	; 2
    319c:	60 f3       	brcs	.-40     	; 0x3176 <uip_listen+0xa>
    319e:	20 93 bb 03 	sts	0x03BB, r18
    31a2:	08 95       	ret

000031a4 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    31a4:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    31a6:	80 91 70 04 	lds	r24, 0x0470
    31aa:	90 91 71 04 	lds	r25, 0x0471
    31ae:	08 96       	adiw	r24, 0x08	; 8
    31b0:	0e 94 49 17 	call	0x2e92	; 0x2e92 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    31b4:	e0 91 70 04 	lds	r30, 0x0470
    31b8:	f0 91 71 04 	lds	r31, 0x0471
    31bc:	80 91 69 04 	lds	r24, 0x0469
    31c0:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    31c2:	80 91 6a 04 	lds	r24, 0x046A
    31c6:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    31c8:	80 91 6b 04 	lds	r24, 0x046B
    31cc:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    31ce:	80 91 6c 04 	lds	r24, 0x046C
    31d2:	83 87       	std	Z+11, r24	; 0x0b
}
    31d4:	08 95       	ret

000031d6 <htons>:
  return;
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
    31d6:	28 2f       	mov	r18, r24
  return HTONS(val);
}
    31d8:	89 2f       	mov	r24, r25
    31da:	92 2f       	mov	r25, r18
    31dc:	08 95       	ret

000031de <uip_send>:
}

/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    31de:	ac 01       	movw	r20, r24
    31e0:	fb 01       	movw	r30, r22
  if(len > 0) {
    31e2:	16 16       	cp	r1, r22
    31e4:	17 06       	cpc	r1, r23
    31e6:	84 f4       	brge	.+32     	; 0x3208 <uip_send+0x2a>
    uip_slen = len;
    31e8:	60 93 e6 0b 	sts	0x0BE6, r22
    31ec:	f0 93 e7 0b 	sts	0x0BE7, r31
    if(data != uip_sappdata) {
    31f0:	20 91 67 04 	lds	r18, 0x0467
    31f4:	30 91 68 04 	lds	r19, 0x0468
    31f8:	82 17       	cp	r24, r18
    31fa:	93 07       	cpc	r25, r19
    31fc:	29 f0       	breq	.+10     	; 0x3208 <uip_send+0x2a>
      memcpy(uip_sappdata, (data), uip_slen);
    31fe:	c9 01       	movw	r24, r18
    3200:	ba 01       	movw	r22, r20
    3202:	af 01       	movw	r20, r30
    3204:	0e 94 38 2f 	call	0x5e70	; 0x5e70 <memcpy>
    3208:	08 95       	ret

0000320a <uip_send_P>:
  return HTONS(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send_P(const void *data, int len)
{
    320a:	ac 01       	movw	r20, r24
    320c:	9b 01       	movw	r18, r22
  if(len > 0) {
    320e:	16 16       	cp	r1, r22
    3210:	17 06       	cpc	r1, r23
    3212:	64 f4       	brge	.+24     	; 0x322c <uip_send_P+0x22>
    uip_slen = len;
    3214:	60 93 e6 0b 	sts	0x0BE6, r22
    3218:	30 93 e7 0b 	sts	0x0BE7, r19
    //if(data != uip_sappdata) {
      memcpy_P(uip_sappdata, (data), uip_slen);
    321c:	80 91 67 04 	lds	r24, 0x0467
    3220:	90 91 68 04 	lds	r25, 0x0468
    3224:	ba 01       	movw	r22, r20
    3226:	a9 01       	movw	r20, r18
    3228:	0e 94 ee 2e 	call	0x5ddc	; 0x5ddc <memcpy_P>
    322c:	08 95       	ret

0000322e <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    322e:	0f 93       	push	r16
    3230:	1f 93       	push	r17
    3232:	cf 93       	push	r28
    3234:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    3236:	c0 91 70 04 	lds	r28, 0x0470
    323a:	d0 91 71 04 	lds	r29, 0x0471
  if(flag == UIP_UDP_SEND_CONN) {
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    323e:	2e e3       	ldi	r18, 0x3E	; 62
    3240:	36 e0       	ldi	r19, 0x06	; 6
    3242:	30 93 6f 04 	sts	0x046F, r19
    3246:	20 93 6e 04 	sts	0x046E, r18
    324a:	30 93 68 04 	sts	0x0468, r19
    324e:	20 93 67 04 	sts	0x0467, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    3252:	83 30       	cpi	r24, 0x03	; 3
    3254:	59 f4       	brne	.+22     	; 0x326c <uip_process+0x3e>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    3256:	89 8d       	ldd	r24, Y+25	; 0x19
    3258:	8f 70       	andi	r24, 0x0F	; 15
    325a:	83 30       	cpi	r24, 0x03	; 3
    325c:	09 f0       	breq	.+2      	; 0x3260 <uip_process+0x32>
    325e:	01 c7       	rjmp	.+3586   	; 0x4062 <uip_process+0xe34>
    3260:	88 89       	ldd	r24, Y+16	; 0x10
    3262:	99 89       	ldd	r25, Y+17	; 0x11
    3264:	89 2b       	or	r24, r25
    3266:	09 f0       	breq	.+2      	; 0x326a <uip_process+0x3c>
    3268:	fc c6       	rjmp	.+3576   	; 0x4062 <uip_process+0xe34>
    326a:	92 c0       	rjmp	.+292    	; 0x3390 <uip_process+0x162>
	goto appsend;
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
    326c:	82 30       	cpi	r24, 0x02	; 2
    326e:	09 f0       	breq	.+2      	; 0x3272 <uip_process+0x44>
    3270:	93 c0       	rjmp	.+294    	; 0x3398 <uip_process+0x16a>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    3272:	80 91 b8 03 	lds	r24, 0x03B8
    3276:	8f 5f       	subi	r24, 0xFF	; 255
    3278:	80 93 b8 03 	sts	0x03B8, r24
    327c:	88 23       	and	r24, r24
    327e:	99 f4       	brne	.+38     	; 0x32a6 <uip_process+0x78>
      if(++iss[2] == 0) {
    3280:	80 91 b7 03 	lds	r24, 0x03B7
    3284:	8f 5f       	subi	r24, 0xFF	; 255
    3286:	80 93 b7 03 	sts	0x03B7, r24
    328a:	88 23       	and	r24, r24
    328c:	61 f4       	brne	.+24     	; 0x32a6 <uip_process+0x78>
	if(++iss[1] == 0) {
    328e:	80 91 b6 03 	lds	r24, 0x03B6
    3292:	8f 5f       	subi	r24, 0xFF	; 255
    3294:	80 93 b6 03 	sts	0x03B6, r24
    3298:	88 23       	and	r24, r24
    329a:	29 f4       	brne	.+10     	; 0x32a6 <uip_process+0x78>
	  ++iss[0];
    329c:	80 91 b5 03 	lds	r24, 0x03B5
    32a0:	8f 5f       	subi	r24, 0xFF	; 255
    32a2:	80 93 b5 03 	sts	0x03B5, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    32a6:	10 92 66 04 	sts	0x0466, r1
    32aa:	10 92 65 04 	sts	0x0465, r1
    uip_slen = 0;
    32ae:	10 92 e7 0b 	sts	0x0BE7, r1
    32b2:	10 92 e6 0b 	sts	0x0BE6, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    32b6:	29 8d       	ldd	r18, Y+25	; 0x19
    32b8:	27 30       	cpi	r18, 0x07	; 7
    32ba:	11 f0       	breq	.+4      	; 0x32c0 <uip_process+0x92>
    32bc:	25 30       	cpi	r18, 0x05	; 5
    32be:	41 f4       	brne	.+16     	; 0x32d0 <uip_process+0xa2>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    32c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    32c2:	8f 5f       	subi	r24, 0xFF	; 255
    32c4:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    32c6:	88 37       	cpi	r24, 0x78	; 120
    32c8:	09 f0       	breq	.+2      	; 0x32cc <uip_process+0x9e>
    32ca:	cb c6       	rjmp	.+3478   	; 0x4062 <uip_process+0xe34>
	uip_connr->tcpstateflags = UIP_CLOSED;
    32cc:	19 8e       	std	Y+25, r1	; 0x19
    32ce:	c9 c6       	rjmp	.+3474   	; 0x4062 <uip_process+0xe34>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    32d0:	22 23       	and	r18, r18
    32d2:	09 f4       	brne	.+2      	; 0x32d6 <uip_process+0xa8>
    32d4:	c6 c6       	rjmp	.+3468   	; 0x4062 <uip_process+0xe34>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    32d6:	88 89       	ldd	r24, Y+16	; 0x10
    32d8:	99 89       	ldd	r25, Y+17	; 0x11
    32da:	89 2b       	or	r24, r25
    32dc:	09 f4       	brne	.+2      	; 0x32e0 <uip_process+0xb2>
    32de:	54 c0       	rjmp	.+168    	; 0x3388 <uip_process+0x15a>
	if(uip_connr->timer-- == 0) {
    32e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    32e2:	81 50       	subi	r24, 0x01	; 1
    32e4:	8a 8f       	std	Y+26, r24	; 0x1a
    32e6:	8f 5f       	subi	r24, 0xFF	; 255
    32e8:	09 f0       	breq	.+2      	; 0x32ec <uip_process+0xbe>
    32ea:	bb c6       	rjmp	.+3446   	; 0x4062 <uip_process+0xe34>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    32ec:	3b 8d       	ldd	r19, Y+27	; 0x1b
    32ee:	38 30       	cpi	r19, 0x08	; 8
    32f0:	29 f0       	breq	.+10     	; 0x32fc <uip_process+0xce>
    32f2:	21 50       	subi	r18, 0x01	; 1
    32f4:	22 30       	cpi	r18, 0x02	; 2
    32f6:	48 f4       	brcc	.+18     	; 0x330a <uip_process+0xdc>
    32f8:	35 30       	cpi	r19, 0x05	; 5
    32fa:	39 f4       	brne	.+14     	; 0x330a <uip_process+0xdc>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    32fc:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    32fe:	80 e8       	ldi	r24, 0x80	; 128
    3300:	80 93 6d 04 	sts	0x046D, r24
	    UIP_APPCALL();
    3304:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>
    3308:	50 c5       	rjmp	.+2720   	; 0x3daa <uip_process+0xb7c>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    330a:	35 30       	cpi	r19, 0x05	; 5
    330c:	10 f0       	brcs	.+4      	; 0x3312 <uip_process+0xe4>
    330e:	80 e3       	ldi	r24, 0x30	; 48
    3310:	07 c0       	rjmp	.+14     	; 0x3320 <uip_process+0xf2>
    3312:	83 e0       	ldi	r24, 0x03	; 3
    3314:	90 e0       	ldi	r25, 0x00	; 0
    3316:	02 c0       	rjmp	.+4      	; 0x331c <uip_process+0xee>
    3318:	88 0f       	add	r24, r24
    331a:	99 1f       	adc	r25, r25
    331c:	3a 95       	dec	r19
    331e:	e2 f7       	brpl	.-8      	; 0x3318 <uip_process+0xea>
    3320:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    3322:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3324:	8f 5f       	subi	r24, 0xFF	; 255
    3326:	8b 8f       	std	Y+27, r24	; 0x1b
	     depending on which state we are in. In ESTABLISHED, we
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
    3328:	80 91 fa 05 	lds	r24, 0x05FA
    332c:	90 91 fb 05 	lds	r25, 0x05FB
    3330:	01 96       	adiw	r24, 0x01	; 1
    3332:	90 93 fb 05 	sts	0x05FB, r25
    3336:	80 93 fa 05 	sts	0x05FA, r24
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    333a:	89 8d       	ldd	r24, Y+25	; 0x19
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	8f 70       	andi	r24, 0x0F	; 15
    3340:	90 70       	andi	r25, 0x00	; 0
    3342:	83 30       	cpi	r24, 0x03	; 3
    3344:	91 05       	cpc	r25, r1
    3346:	d1 f0       	breq	.+52     	; 0x337c <uip_process+0x14e>
    3348:	84 30       	cpi	r24, 0x04	; 4
    334a:	91 05       	cpc	r25, r1
    334c:	44 f4       	brge	.+16     	; 0x335e <uip_process+0x130>
    334e:	81 30       	cpi	r24, 0x01	; 1
    3350:	91 05       	cpc	r25, r1
    3352:	09 f4       	brne	.+2      	; 0x3356 <uip_process+0x128>
    3354:	0c c3       	rjmp	.+1560   	; 0x396e <uip_process+0x740>
    3356:	02 97       	sbiw	r24, 0x02	; 2
    3358:	09 f0       	breq	.+2      	; 0x335c <uip_process+0x12e>
    335a:	83 c6       	rjmp	.+3334   	; 0x4062 <uip_process+0xe34>
    335c:	0c c0       	rjmp	.+24     	; 0x3376 <uip_process+0x148>
    335e:	86 30       	cpi	r24, 0x06	; 6
    3360:	91 05       	cpc	r25, r1
    3362:	09 f4       	brne	.+2      	; 0x3366 <uip_process+0x138>
    3364:	b5 c4       	rjmp	.+2410   	; 0x3cd0 <uip_process+0xaa2>
    3366:	88 30       	cpi	r24, 0x08	; 8
    3368:	91 05       	cpc	r25, r1
    336a:	09 f4       	brne	.+2      	; 0x336e <uip_process+0x140>
    336c:	b1 c4       	rjmp	.+2402   	; 0x3cd0 <uip_process+0xaa2>
    336e:	04 97       	sbiw	r24, 0x04	; 4
    3370:	09 f0       	breq	.+2      	; 0x3374 <uip_process+0x146>
    3372:	77 c6       	rjmp	.+3310   	; 0x4062 <uip_process+0xe34>
    3374:	ad c4       	rjmp	.+2394   	; 0x3cd0 <uip_process+0xaa2>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    3376:	10 92 37 06 	sts	0x0637, r1
    337a:	fc c2       	rjmp	.+1528   	; 0x3974 <uip_process+0x746>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    337c:	84 e0       	ldi	r24, 0x04	; 4
    337e:	80 93 6d 04 	sts	0x046D, r24
	    UIP_APPCALL();
    3382:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>
    3386:	46 c5       	rjmp	.+2700   	; 0x3e14 <uip_process+0xbe6>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    3388:	2f 70       	andi	r18, 0x0F	; 15
    338a:	23 30       	cpi	r18, 0x03	; 3
    338c:	09 f0       	breq	.+2      	; 0x3390 <uip_process+0x162>
    338e:	69 c6       	rjmp	.+3282   	; 0x4062 <uip_process+0xe34>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
    3390:	88 e0       	ldi	r24, 0x08	; 8
    3392:	80 93 6d 04 	sts	0x046D, r24
    3396:	fd c4       	rjmp	.+2554   	; 0x3d92 <uip_process+0xb64>
    }
  }
#endif

  /* This is where the input processing starts. */
  UIP_STAT(++uip_stat.ip.recv);
    3398:	80 91 d6 05 	lds	r24, 0x05D6
    339c:	90 91 d7 05 	lds	r25, 0x05D7
    33a0:	01 96       	adiw	r24, 0x01	; 1
    33a2:	90 93 d7 05 	sts	0x05D7, r25
    33a6:	80 93 d6 05 	sts	0x05D6, r24
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    33aa:	89 01       	movw	r16, r18
    33ac:	08 52       	subi	r16, 0x28	; 40
    33ae:	10 40       	sbci	r17, 0x00	; 0
    33b0:	80 91 16 06 	lds	r24, 0x0616
    33b4:	85 34       	cpi	r24, 0x45	; 69
    33b6:	a9 f0       	breq	.+42     	; 0x33e2 <uip_process+0x1b4>
    UIP_STAT(++uip_stat.ip.drop);
    33b8:	80 91 d4 05 	lds	r24, 0x05D4
    33bc:	90 91 d5 05 	lds	r25, 0x05D5
    33c0:	01 96       	adiw	r24, 0x01	; 1
    33c2:	90 93 d5 05 	sts	0x05D5, r25
    33c6:	80 93 d4 05 	sts	0x05D4, r24
    UIP_STAT(++uip_stat.ip.vhlerr);
    33ca:	80 91 da 05 	lds	r24, 0x05DA
    33ce:	90 91 db 05 	lds	r25, 0x05DB
    33d2:	01 96       	adiw	r24, 0x01	; 1
    33d4:	90 93 db 05 	sts	0x05DB, r25
    33d8:	80 93 da 05 	sts	0x05DA, r24
    UIP_LOG("ip: invalid version or header length.");
    33dc:	81 e0       	ldi	r24, 0x01	; 1
    33de:	91 e0       	ldi	r25, 0x01	; 1
    33e0:	1d c0       	rjmp	.+58     	; 0x341c <uip_process+0x1ee>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    33e2:	90 91 18 06 	lds	r25, 0x0618
    33e6:	80 e0       	ldi	r24, 0x00	; 0
    33e8:	20 91 19 06 	lds	r18, 0x0619
    33ec:	ac 01       	movw	r20, r24
    33ee:	42 0f       	add	r20, r18
    33f0:	51 1d       	adc	r21, r1
    33f2:	80 91 65 04 	lds	r24, 0x0465
    33f6:	90 91 66 04 	lds	r25, 0x0466
    33fa:	84 17       	cp	r24, r20
    33fc:	95 07       	cpc	r25, r21
    33fe:	60 f0       	brcs	.+24     	; 0x3418 <uip_process+0x1ea>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    3400:	50 93 66 04 	sts	0x0466, r21
    3404:	40 93 65 04 	sts	0x0465, r20
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    3408:	80 91 1c 06 	lds	r24, 0x061C
    340c:	90 e0       	ldi	r25, 0x00	; 0
    340e:	8f 73       	andi	r24, 0x3F	; 63
    3410:	90 70       	andi	r25, 0x00	; 0
    3412:	89 2b       	or	r24, r25
    3414:	31 f0       	breq	.+12     	; 0x3422 <uip_process+0x1f4>
    3416:	09 c0       	rjmp	.+18     	; 0x342a <uip_process+0x1fc>
		      contains the length of the entire packet. But
		      for IPv6 we need to add the size of the IPv6
		      header (40 bytes). */
#endif /* UIP_CONF_IPV6 */
  } else {
    UIP_LOG("ip: packet shorter than reported in IP header.");
    3418:	87 e2       	ldi	r24, 0x27	; 39
    341a:	91 e0       	ldi	r25, 0x01	; 1
    341c:	0e 94 cd 10 	call	0x219a	; 0x219a <uip_log>
    3420:	20 c6       	rjmp	.+3136   	; 0x4062 <uip_process+0xe34>
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    3422:	80 91 1d 06 	lds	r24, 0x061D
    3426:	88 23       	and	r24, r24
    3428:	a9 f0       	breq	.+42     	; 0x3454 <uip_process+0x226>
    uip_len = uip_reass();
    if(uip_len == 0) {
      goto drop;
    }
#else /* UIP_REASSEMBLY */
    UIP_STAT(++uip_stat.ip.drop);
    342a:	80 91 d4 05 	lds	r24, 0x05D4
    342e:	90 91 d5 05 	lds	r25, 0x05D5
    3432:	01 96       	adiw	r24, 0x01	; 1
    3434:	90 93 d5 05 	sts	0x05D5, r25
    3438:	80 93 d4 05 	sts	0x05D4, r24
    UIP_STAT(++uip_stat.ip.fragerr);
    343c:	80 91 e0 05 	lds	r24, 0x05E0
    3440:	90 91 e1 05 	lds	r25, 0x05E1
    3444:	01 96       	adiw	r24, 0x01	; 1
    3446:	90 93 e1 05 	sts	0x05E1, r25
    344a:	80 93 e0 05 	sts	0x05E0, r24
    UIP_LOG("ip: fragment dropped.");
    344e:	86 e5       	ldi	r24, 0x56	; 86
    3450:	91 e0       	ldi	r25, 0x01	; 1
    3452:	e4 cf       	rjmp	.-56     	; 0x341c <uip_process+0x1ee>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
    3454:	20 91 04 06 	lds	r18, 0x0604
    3458:	30 91 05 06 	lds	r19, 0x0605
    345c:	80 91 07 02 	lds	r24, 0x0207
    3460:	90 91 08 02 	lds	r25, 0x0208
    3464:	28 17       	cp	r18, r24
    3466:	39 07       	cpc	r19, r25
    3468:	31 f4       	brne	.+12     	; 0x3476 <uip_process+0x248>
    346a:	80 91 06 06 	lds	r24, 0x0606
    346e:	90 91 07 06 	lds	r25, 0x0607
    3472:	89 2b       	or	r24, r25
    3474:	e1 f0       	breq	.+56     	; 0x34ae <uip_process+0x280>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
    3476:	80 91 26 06 	lds	r24, 0x0626
    347a:	90 91 27 06 	lds	r25, 0x0627
    347e:	82 17       	cp	r24, r18
    3480:	93 07       	cpc	r25, r19
    3482:	59 f4       	brne	.+22     	; 0x349a <uip_process+0x26c>
    3484:	20 91 28 06 	lds	r18, 0x0628
    3488:	30 91 29 06 	lds	r19, 0x0629
    348c:	80 91 06 06 	lds	r24, 0x0606
    3490:	90 91 07 06 	lds	r25, 0x0607
    3494:	28 17       	cp	r18, r24
    3496:	39 07       	cpc	r19, r25
    3498:	51 f0       	breq	.+20     	; 0x34ae <uip_process+0x280>
      UIP_STAT(++uip_stat.ip.drop);
    349a:	80 91 d4 05 	lds	r24, 0x05D4
    349e:	90 91 d5 05 	lds	r25, 0x05D5
    34a2:	01 96       	adiw	r24, 0x01	; 1
    34a4:	90 93 d5 05 	sts	0x05D5, r25
    34a8:	80 93 d4 05 	sts	0x05D4, r24
    34ac:	da c5       	rjmp	.+2996   	; 0x4062 <uip_process+0xe34>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    34ae:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <uip_ipchksum>
    34b2:	8f 5f       	subi	r24, 0xFF	; 255
    34b4:	9f 4f       	sbci	r25, 0xFF	; 255
    34b6:	a9 f0       	breq	.+42     	; 0x34e2 <uip_process+0x2b4>
				    checksum. */
    UIP_STAT(++uip_stat.ip.drop);
    34b8:	80 91 d4 05 	lds	r24, 0x05D4
    34bc:	90 91 d5 05 	lds	r25, 0x05D5
    34c0:	01 96       	adiw	r24, 0x01	; 1
    34c2:	90 93 d5 05 	sts	0x05D5, r25
    34c6:	80 93 d4 05 	sts	0x05D4, r24
    UIP_STAT(++uip_stat.ip.chkerr);
    34ca:	80 91 e2 05 	lds	r24, 0x05E2
    34ce:	90 91 e3 05 	lds	r25, 0x05E3
    34d2:	01 96       	adiw	r24, 0x01	; 1
    34d4:	90 93 e3 05 	sts	0x05E3, r25
    34d8:	80 93 e2 05 	sts	0x05E2, r24
    UIP_LOG("ip: bad checksum.");
    34dc:	8c e6       	ldi	r24, 0x6C	; 108
    34de:	91 e0       	ldi	r25, 0x01	; 1
    34e0:	9d cf       	rjmp	.-198    	; 0x341c <uip_process+0x1ee>
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    34e2:	80 91 1f 06 	lds	r24, 0x061F
    34e6:	86 30       	cpi	r24, 0x06	; 6
    34e8:	09 f4       	brne	.+2      	; 0x34ec <uip_process+0x2be>
    34ea:	74 c0       	rjmp	.+232    	; 0x35d4 <uip_process+0x3a6>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    34ec:	81 30       	cpi	r24, 0x01	; 1
    34ee:	a9 f0       	breq	.+42     	; 0x351a <uip_process+0x2ec>
					here. */
    UIP_STAT(++uip_stat.ip.drop);
    34f0:	80 91 d4 05 	lds	r24, 0x05D4
    34f4:	90 91 d5 05 	lds	r25, 0x05D5
    34f8:	01 96       	adiw	r24, 0x01	; 1
    34fa:	90 93 d5 05 	sts	0x05D5, r25
    34fe:	80 93 d4 05 	sts	0x05D4, r24
    UIP_STAT(++uip_stat.ip.protoerr);
    3502:	80 91 e4 05 	lds	r24, 0x05E4
    3506:	90 91 e5 05 	lds	r25, 0x05E5
    350a:	01 96       	adiw	r24, 0x01	; 1
    350c:	90 93 e5 05 	sts	0x05E5, r25
    3510:	80 93 e4 05 	sts	0x05E4, r24
    UIP_LOG("ip: neither tcp nor icmp.");
    3514:	8e e7       	ldi	r24, 0x7E	; 126
    3516:	91 e0       	ldi	r25, 0x01	; 1
    3518:	81 cf       	rjmp	.-254    	; 0x341c <uip_process+0x1ee>
  }

#if UIP_PINGADDRCONF
 icmp_input:
#endif /* UIP_PINGADDRCONF */
  UIP_STAT(++uip_stat.icmp.recv);
    351a:	80 91 e8 05 	lds	r24, 0x05E8
    351e:	90 91 e9 05 	lds	r25, 0x05E9
    3522:	01 96       	adiw	r24, 0x01	; 1
    3524:	90 93 e9 05 	sts	0x05E9, r25
    3528:	80 93 e8 05 	sts	0x05E8, r24

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    352c:	80 91 2a 06 	lds	r24, 0x062A
    3530:	88 30       	cpi	r24, 0x08	; 8
    3532:	a9 f0       	breq	.+42     	; 0x355e <uip_process+0x330>
    UIP_STAT(++uip_stat.icmp.drop);
    3534:	80 91 e6 05 	lds	r24, 0x05E6
    3538:	90 91 e7 05 	lds	r25, 0x05E7
    353c:	01 96       	adiw	r24, 0x01	; 1
    353e:	90 93 e7 05 	sts	0x05E7, r25
    3542:	80 93 e6 05 	sts	0x05E6, r24
    UIP_STAT(++uip_stat.icmp.typeerr);
    3546:	80 91 ec 05 	lds	r24, 0x05EC
    354a:	90 91 ed 05 	lds	r25, 0x05ED
    354e:	01 96       	adiw	r24, 0x01	; 1
    3550:	90 93 ed 05 	sts	0x05ED, r25
    3554:	80 93 ec 05 	sts	0x05EC, r24
    UIP_LOG("icmp: not icmp echo.");
    3558:	88 e9       	ldi	r24, 0x98	; 152
    355a:	91 e0       	ldi	r25, 0x01	; 1
    355c:	5f cf       	rjmp	.-322    	; 0x341c <uip_process+0x1ee>
    uip_hostaddr[0] = BUF->destipaddr[0];
    uip_hostaddr[1] = BUF->destipaddr[1];
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    355e:	10 92 2a 06 	sts	0x062A, r1

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    3562:	80 91 2c 06 	lds	r24, 0x062C
    3566:	90 91 2d 06 	lds	r25, 0x062D
    356a:	ef ef       	ldi	r30, 0xFF	; 255
    356c:	87 3f       	cpi	r24, 0xF7	; 247
    356e:	9e 07       	cpc	r25, r30
    3570:	10 f0       	brcs	.+4      	; 0x3576 <uip_process+0x348>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    3572:	09 96       	adiw	r24, 0x09	; 9
    3574:	01 c0       	rjmp	.+2      	; 0x3578 <uip_process+0x34a>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    3576:	08 96       	adiw	r24, 0x08	; 8
    3578:	90 93 2d 06 	sts	0x062D, r25
    357c:	80 93 2c 06 	sts	0x062C, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    3580:	80 91 22 06 	lds	r24, 0x0622
    3584:	90 91 23 06 	lds	r25, 0x0623
    3588:	90 93 27 06 	sts	0x0627, r25
    358c:	80 93 26 06 	sts	0x0626, r24
    3590:	80 91 24 06 	lds	r24, 0x0624
    3594:	90 91 25 06 	lds	r25, 0x0625
    3598:	90 93 29 06 	sts	0x0629, r25
    359c:	80 93 28 06 	sts	0x0628, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    35a0:	80 91 04 06 	lds	r24, 0x0604
    35a4:	90 91 05 06 	lds	r25, 0x0605
    35a8:	90 93 23 06 	sts	0x0623, r25
    35ac:	80 93 22 06 	sts	0x0622, r24
    35b0:	80 91 06 06 	lds	r24, 0x0606
    35b4:	90 91 07 06 	lds	r25, 0x0607
    35b8:	90 93 25 06 	sts	0x0625, r25
    35bc:	80 93 24 06 	sts	0x0624, r24

  UIP_STAT(++uip_stat.icmp.sent);
    35c0:	80 91 ea 05 	lds	r24, 0x05EA
    35c4:	90 91 eb 05 	lds	r25, 0x05EB
    35c8:	01 96       	adiw	r24, 0x01	; 1
    35ca:	90 93 eb 05 	sts	0x05EB, r25
    35ce:	80 93 ea 05 	sts	0x05EA, r24
    35d2:	3d c5       	rjmp	.+2682   	; 0x404e <uip_process+0xe20>
  goto ip_send_nolen;
#endif /* UIP_UDP */
  
  /* TCP input processing. */
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);
    35d4:	80 91 f0 05 	lds	r24, 0x05F0
    35d8:	90 91 f1 05 	lds	r25, 0x05F1
    35dc:	01 96       	adiw	r24, 0x01	; 1
    35de:	90 93 f1 05 	sts	0x05F1, r25
    35e2:	80 93 f0 05 	sts	0x05F0, r24

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    35e6:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uip_tcpchksum>
    35ea:	8f 5f       	subi	r24, 0xFF	; 255
    35ec:	9f 4f       	sbci	r25, 0xFF	; 255
    35ee:	a9 f0       	breq	.+42     	; 0x361a <uip_process+0x3ec>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    35f0:	80 91 ee 05 	lds	r24, 0x05EE
    35f4:	90 91 ef 05 	lds	r25, 0x05EF
    35f8:	01 96       	adiw	r24, 0x01	; 1
    35fa:	90 93 ef 05 	sts	0x05EF, r25
    35fe:	80 93 ee 05 	sts	0x05EE, r24
    UIP_STAT(++uip_stat.tcp.chkerr);
    3602:	80 91 f4 05 	lds	r24, 0x05F4
    3606:	90 91 f5 05 	lds	r25, 0x05F5
    360a:	01 96       	adiw	r24, 0x01	; 1
    360c:	90 93 f5 05 	sts	0x05F5, r25
    3610:	80 93 f4 05 	sts	0x05F4, r24
    UIP_LOG("tcp: bad checksum.");
    3614:	8d ea       	ldi	r24, 0xAD	; 173
    3616:	91 e0       	ldi	r25, 0x01	; 1
    3618:	01 cf       	rjmp	.-510    	; 0x341c <uip_process+0x1ee>
    goto drop;
    361a:	c2 e7       	ldi	r28, 0x72	; 114
    361c:	d4 e0       	ldi	r29, 0x04	; 4
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    361e:	89 8d       	ldd	r24, Y+25	; 0x19
    3620:	88 23       	and	r24, r24
    3622:	29 f1       	breq	.+74     	; 0x366e <uip_process+0x440>
    3624:	20 91 2c 06 	lds	r18, 0x062C
    3628:	30 91 2d 06 	lds	r19, 0x062D
    362c:	8c 81       	ldd	r24, Y+4	; 0x04
    362e:	9d 81       	ldd	r25, Y+5	; 0x05
    3630:	28 17       	cp	r18, r24
    3632:	39 07       	cpc	r19, r25
    3634:	e1 f4       	brne	.+56     	; 0x366e <uip_process+0x440>
    3636:	20 91 2a 06 	lds	r18, 0x062A
    363a:	30 91 2b 06 	lds	r19, 0x062B
    363e:	8e 81       	ldd	r24, Y+6	; 0x06
    3640:	9f 81       	ldd	r25, Y+7	; 0x07
    3642:	28 17       	cp	r18, r24
    3644:	39 07       	cpc	r19, r25
    3646:	99 f4       	brne	.+38     	; 0x366e <uip_process+0x440>
    3648:	20 91 22 06 	lds	r18, 0x0622
    364c:	30 91 23 06 	lds	r19, 0x0623
    3650:	88 81       	ld	r24, Y
    3652:	99 81       	ldd	r25, Y+1	; 0x01
    3654:	28 17       	cp	r18, r24
    3656:	39 07       	cpc	r19, r25
    3658:	51 f4       	brne	.+20     	; 0x366e <uip_process+0x440>
    365a:	20 91 24 06 	lds	r18, 0x0624
    365e:	30 91 25 06 	lds	r19, 0x0625
    3662:	8a 81       	ldd	r24, Y+2	; 0x02
    3664:	9b 81       	ldd	r25, Y+3	; 0x03
    3666:	28 17       	cp	r18, r24
    3668:	39 07       	cpc	r19, r25
    366a:	09 f4       	brne	.+2      	; 0x366e <uip_process+0x440>
    366c:	9c c1       	rjmp	.+824    	; 0x39a6 <uip_process+0x778>
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    366e:	c3 55       	subi	r28, 0x53	; 83
    3670:	df 4f       	sbci	r29, 0xFF	; 255
  }
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    3672:	25 e0       	ldi	r18, 0x05	; 5
    3674:	cf 31       	cpi	r28, 0x1F	; 31
    3676:	d2 07       	cpc	r29, r18
    3678:	91 f2       	breq	.-92     	; 0x361e <uip_process+0x3f0>
    367a:	88 f2       	brcs	.-94     	; 0x361e <uip_process+0x3f0>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    367c:	80 91 37 06 	lds	r24, 0x0637
    3680:	8f 73       	andi	r24, 0x3F	; 63
    3682:	82 30       	cpi	r24, 0x02	; 2
    3684:	59 f5       	brne	.+86     	; 0x36dc <uip_process+0x4ae>
    goto reset;
  }
  
  tmp16 = BUF->destport;
    3686:	80 91 2c 06 	lds	r24, 0x062C
    368a:	90 91 2d 06 	lds	r25, 0x062D
    368e:	90 93 be 03 	sts	0x03BE, r25
    3692:	80 93 bd 03 	sts	0x03BD, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    3696:	10 92 bb 03 	sts	0x03BB, r1
    369a:	13 c0       	rjmp	.+38     	; 0x36c2 <uip_process+0x494>
    if(tmp16 == uip_listenports[c])
    369c:	e4 2f       	mov	r30, r20
    369e:	f0 e0       	ldi	r31, 0x00	; 0
    36a0:	ee 0f       	add	r30, r30
    36a2:	ff 1f       	adc	r31, r31
    36a4:	e4 53       	subi	r30, 0x34	; 52
    36a6:	fa 4f       	sbci	r31, 0xFA	; 250
    36a8:	20 91 bd 03 	lds	r18, 0x03BD
    36ac:	30 91 be 03 	lds	r19, 0x03BE
    36b0:	80 81       	ld	r24, Z
    36b2:	91 81       	ldd	r25, Z+1	; 0x01
    36b4:	28 17       	cp	r18, r24
    36b6:	39 07       	cpc	r19, r25
    36b8:	09 f4       	brne	.+2      	; 0x36bc <uip_process+0x48e>
    36ba:	83 c0       	rjmp	.+262    	; 0x37c2 <uip_process+0x594>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    36bc:	4f 5f       	subi	r20, 0xFF	; 255
    36be:	40 93 bb 03 	sts	0x03BB, r20
    36c2:	40 91 bb 03 	lds	r20, 0x03BB
    36c6:	42 30       	cpi	r20, 0x02	; 2
    36c8:	48 f3       	brcs	.-46     	; 0x369c <uip_process+0x46e>
    if(tmp16 == uip_listenports[c])
      goto found_listen;
  }
  
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);
    36ca:	80 91 fe 05 	lds	r24, 0x05FE
    36ce:	90 91 ff 05 	lds	r25, 0x05FF
    36d2:	01 96       	adiw	r24, 0x01	; 1
    36d4:	90 93 ff 05 	sts	0x05FF, r25
    36d8:	80 93 fe 05 	sts	0x05FE, r24
 reset:

  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    36dc:	80 91 37 06 	lds	r24, 0x0637
    36e0:	82 fd       	sbrc	r24, 2
    36e2:	bf c4       	rjmp	.+2430   	; 0x4062 <uip_process+0xe34>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
    36e4:	80 91 f8 05 	lds	r24, 0x05F8
    36e8:	90 91 f9 05 	lds	r25, 0x05F9
    36ec:	01 96       	adiw	r24, 0x01	; 1
    36ee:	90 93 f9 05 	sts	0x05F9, r25
    36f2:	80 93 f8 05 	sts	0x05F8, r24
  
  BUF->flags = TCP_RST | TCP_ACK;
    36f6:	84 e1       	ldi	r24, 0x14	; 20
    36f8:	f8 01       	movw	r30, r16
    36fa:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    36fc:	88 e2       	ldi	r24, 0x28	; 40
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	90 93 66 04 	sts	0x0466, r25
    3704:	80 93 65 04 	sts	0x0465, r24
  BUF->tcpoffset = 5 << 4;
    3708:	80 e5       	ldi	r24, 0x50	; 80
    370a:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    370c:	90 91 31 06 	lds	r25, 0x0631
  BUF->seqno[3] = BUF->ackno[3];
    3710:	80 91 35 06 	lds	r24, 0x0635
    3714:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    3716:	30 91 30 06 	lds	r19, 0x0630
  BUF->seqno[2] = BUF->ackno[2];
    371a:	80 91 34 06 	lds	r24, 0x0634
    371e:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    3720:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    3722:	40 91 2f 06 	lds	r20, 0x062F
  BUF->seqno[1] = BUF->ackno[1];
    3726:	80 91 33 06 	lds	r24, 0x0633
    372a:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    372c:	45 8f       	std	Z+29, r20	; 0x1d
  
  c = BUF->seqno[0];
    372e:	20 91 2e 06 	lds	r18, 0x062E
    3732:	20 93 bb 03 	sts	0x03BB, r18
  BUF->seqno[0] = BUF->ackno[0];
    3736:	80 91 32 06 	lds	r24, 0x0632
    373a:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    373c:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    373e:	9f 5f       	subi	r25, 0xFF	; 255
    3740:	97 8f       	std	Z+31, r25	; 0x1f
    3742:	99 23       	and	r25, r25
    3744:	61 f4       	brne	.+24     	; 0x375e <uip_process+0x530>
    if(++BUF->ackno[2] == 0) {
    3746:	83 2f       	mov	r24, r19
    3748:	8f 5f       	subi	r24, 0xFF	; 255
    374a:	86 8f       	std	Z+30, r24	; 0x1e
    374c:	88 23       	and	r24, r24
    374e:	39 f4       	brne	.+14     	; 0x375e <uip_process+0x530>
      if(++BUF->ackno[1] == 0) {
    3750:	84 2f       	mov	r24, r20
    3752:	8f 5f       	subi	r24, 0xFF	; 255
    3754:	85 8f       	std	Z+29, r24	; 0x1d
    3756:	88 23       	and	r24, r24
    3758:	11 f4       	brne	.+4      	; 0x375e <uip_process+0x530>
	++BUF->ackno[0];
    375a:	2f 5f       	subi	r18, 0xFF	; 255
    375c:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    375e:	20 91 2a 06 	lds	r18, 0x062A
    3762:	30 91 2b 06 	lds	r19, 0x062B
    3766:	30 93 be 03 	sts	0x03BE, r19
    376a:	20 93 bd 03 	sts	0x03BD, r18
  BUF->srcport = BUF->destport;
    376e:	80 91 2c 06 	lds	r24, 0x062C
    3772:	90 91 2d 06 	lds	r25, 0x062D
    3776:	f8 01       	movw	r30, r16
    3778:	95 8b       	std	Z+21, r25	; 0x15
    377a:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    377c:	37 8b       	std	Z+23, r19	; 0x17
    377e:	26 8b       	std	Z+22, r18	; 0x16
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    3780:	80 91 22 06 	lds	r24, 0x0622
    3784:	90 91 23 06 	lds	r25, 0x0623
    3788:	90 93 27 06 	sts	0x0627, r25
    378c:	80 93 26 06 	sts	0x0626, r24
    3790:	80 91 24 06 	lds	r24, 0x0624
    3794:	90 91 25 06 	lds	r25, 0x0625
    3798:	90 93 29 06 	sts	0x0629, r25
    379c:	80 93 28 06 	sts	0x0628, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    37a0:	80 91 04 06 	lds	r24, 0x0604
    37a4:	90 91 05 06 	lds	r25, 0x0605
    37a8:	90 93 23 06 	sts	0x0623, r25
    37ac:	80 93 22 06 	sts	0x0622, r24
    37b0:	80 91 06 06 	lds	r24, 0x0606
    37b4:	90 91 07 06 	lds	r25, 0x0607
    37b8:	90 93 25 06 	sts	0x0625, r25
    37bc:	80 93 24 06 	sts	0x0624, r24
    37c0:	00 c4       	rjmp	.+2048   	; 0x3fc2 <uip_process+0xd94>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    37c2:	10 92 bb 03 	sts	0x03BB, r1
    37c6:	c0 e0       	ldi	r28, 0x00	; 0
    37c8:	d0 e0       	ldi	r29, 0x00	; 0
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    37ca:	4d ea       	ldi	r20, 0xAD	; 173
    37cc:	50 e0       	ldi	r21, 0x00	; 0
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    37ce:	3d ea       	ldi	r19, 0xAD	; 173
    37d0:	25 c0       	rjmp	.+74     	; 0x381c <uip_process+0x5ee>
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    37d2:	82 2f       	mov	r24, r18
    37d4:	90 e0       	ldi	r25, 0x00	; 0
    37d6:	84 9f       	mul	r24, r20
    37d8:	f0 01       	movw	r30, r0
    37da:	85 9f       	mul	r24, r21
    37dc:	f0 0d       	add	r31, r0
    37de:	94 9f       	mul	r25, r20
    37e0:	f0 0d       	add	r31, r0
    37e2:	11 24       	eor	r1, r1
    37e4:	ee 58       	subi	r30, 0x8E	; 142
    37e6:	fb 4f       	sbci	r31, 0xFB	; 251
    37e8:	81 8d       	ldd	r24, Z+25	; 0x19
    37ea:	88 23       	and	r24, r24
    37ec:	39 f4       	brne	.+14     	; 0x37fc <uip_process+0x5ce>
      uip_connr = &uip_conns[c];
    37ee:	8d ea       	ldi	r24, 0xAD	; 173
    37f0:	28 9f       	mul	r18, r24
    37f2:	e0 01       	movw	r28, r0
    37f4:	11 24       	eor	r1, r1
    37f6:	ce 58       	subi	r28, 0x8E	; 142
    37f8:	db 4f       	sbci	r29, 0xFB	; 251
    37fa:	14 c0       	rjmp	.+40     	; 0x3824 <uip_process+0x5f6>
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    37fc:	87 30       	cpi	r24, 0x07	; 7
    37fe:	59 f4       	brne	.+22     	; 0x3816 <uip_process+0x5e8>
      if(uip_connr == 0 ||
    3800:	20 97       	sbiw	r28, 0x00	; 0
    3802:	21 f0       	breq	.+8      	; 0x380c <uip_process+0x5de>
    3804:	92 8d       	ldd	r25, Z+26	; 0x1a
    3806:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3808:	89 17       	cp	r24, r25
    380a:	28 f4       	brcc	.+10     	; 0x3816 <uip_process+0x5e8>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    380c:	23 9f       	mul	r18, r19
    380e:	e0 01       	movw	r28, r0
    3810:	11 24       	eor	r1, r1
    3812:	ce 58       	subi	r28, 0x8E	; 142
    3814:	db 4f       	sbci	r29, 0xFB	; 251
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    3816:	2f 5f       	subi	r18, 0xFF	; 255
    3818:	20 93 bb 03 	sts	0x03BB, r18
    381c:	20 91 bb 03 	lds	r18, 0x03BB
    3820:	22 30       	cpi	r18, 0x02	; 2
    3822:	b8 f2       	brcs	.-82     	; 0x37d2 <uip_process+0x5a4>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    3824:	20 97       	sbiw	r28, 0x00	; 0
    3826:	61 f4       	brne	.+24     	; 0x3840 <uip_process+0x612>
    /* All connections are used already, we drop packet and hope that
       the remote end will retransmit the packet at a time when we
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    3828:	80 91 fc 05 	lds	r24, 0x05FC
    382c:	90 91 fd 05 	lds	r25, 0x05FD
    3830:	01 96       	adiw	r24, 0x01	; 1
    3832:	90 93 fd 05 	sts	0x05FD, r25
    3836:	80 93 fc 05 	sts	0x05FC, r24
    UIP_LOG("tcp: found no unused connections.");
    383a:	80 ec       	ldi	r24, 0xC0	; 192
    383c:	91 e0       	ldi	r25, 0x01	; 1
    383e:	ee cd       	rjmp	.-1060   	; 0x341c <uip_process+0x1ee>
    goto drop;
  }
  uip_conn = uip_connr;
    3840:	d0 93 71 04 	sts	0x0471, r29
    3844:	c0 93 70 04 	sts	0x0470, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    3848:	83 e0       	ldi	r24, 0x03	; 3
    384a:	8a 8f       	std	Y+26, r24	; 0x1a
    384c:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    384e:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    3850:	84 e0       	ldi	r24, 0x04	; 4
    3852:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    3854:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    3856:	80 91 2c 06 	lds	r24, 0x062C
    385a:	90 91 2d 06 	lds	r25, 0x062D
    385e:	9d 83       	std	Y+5, r25	; 0x05
    3860:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    3862:	80 91 2a 06 	lds	r24, 0x062A
    3866:	90 91 2b 06 	lds	r25, 0x062B
    386a:	9f 83       	std	Y+7, r25	; 0x07
    386c:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
    386e:	80 91 22 06 	lds	r24, 0x0622
    3872:	90 91 23 06 	lds	r25, 0x0623
    3876:	99 83       	std	Y+1, r25	; 0x01
    3878:	88 83       	st	Y, r24
    387a:	80 91 24 06 	lds	r24, 0x0624
    387e:	90 91 25 06 	lds	r25, 0x0625
    3882:	9b 83       	std	Y+3, r25	; 0x03
    3884:	8a 83       	std	Y+2, r24	; 0x02
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    3886:	81 e0       	ldi	r24, 0x01	; 1
    3888:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    388a:	80 91 b5 03 	lds	r24, 0x03B5
    388e:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    3890:	80 91 b6 03 	lds	r24, 0x03B6
    3894:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    3896:	80 91 b7 03 	lds	r24, 0x03B7
    389a:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    389c:	80 91 b8 03 	lds	r24, 0x03B8
    38a0:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    38a2:	81 e0       	ldi	r24, 0x01	; 1
    38a4:	90 e0       	ldi	r25, 0x00	; 0
    38a6:	99 8b       	std	Y+17, r25	; 0x11
    38a8:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    38aa:	80 91 31 06 	lds	r24, 0x0631
    38ae:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    38b0:	80 91 30 06 	lds	r24, 0x0630
    38b4:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    38b6:	80 91 2f 06 	lds	r24, 0x062F
    38ba:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    38bc:	80 91 2e 06 	lds	r24, 0x062E
    38c0:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    38c2:	81 e0       	ldi	r24, 0x01	; 1
    38c4:	90 e0       	ldi	r25, 0x00	; 0
    38c6:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    38ca:	80 91 36 06 	lds	r24, 0x0636
    38ce:	90 e0       	ldi	r25, 0x00	; 0
    38d0:	80 7f       	andi	r24, 0xF0	; 240
    38d2:	90 70       	andi	r25, 0x00	; 0
    38d4:	81 35       	cpi	r24, 0x51	; 81
    38d6:	91 05       	cpc	r25, r1
    38d8:	0c f4       	brge	.+2      	; 0x38dc <uip_process+0x6ae>
    38da:	49 c0       	rjmp	.+146    	; 0x396e <uip_process+0x740>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    38dc:	10 92 bb 03 	sts	0x03BB, r1
    38e0:	34 c0       	rjmp	.+104    	; 0x394a <uip_process+0x71c>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    38e2:	f9 01       	movw	r30, r18
    38e4:	e8 5f       	subi	r30, 0xF8	; 248
    38e6:	f9 4f       	sbci	r31, 0xF9	; 249
    38e8:	86 a9       	ldd	r24, Z+54	; 0x36
    38ea:	80 93 bc 03 	sts	0x03BC, r24
      if(opt == TCP_OPT_END) {
    38ee:	88 23       	and	r24, r24
    38f0:	f1 f1       	breq	.+124    	; 0x396e <uip_process+0x740>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    38f2:	81 30       	cpi	r24, 0x01	; 1
    38f4:	21 f4       	brne	.+8      	; 0x38fe <uip_process+0x6d0>
	++c;
    38f6:	4f 5f       	subi	r20, 0xFF	; 255
    38f8:	40 93 bb 03 	sts	0x03BB, r20
    38fc:	26 c0       	rjmp	.+76     	; 0x394a <uip_process+0x71c>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    38fe:	82 30       	cpi	r24, 0x02	; 2
    3900:	c1 f4       	brne	.+48     	; 0x3932 <uip_process+0x704>
    3902:	87 a9       	ldd	r24, Z+55	; 0x37
    3904:	84 30       	cpi	r24, 0x04	; 4
    3906:	a9 f4       	brne	.+42     	; 0x3932 <uip_process+0x704>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    3908:	30 ad       	ldd	r19, Z+56	; 0x38
    390a:	20 e0       	ldi	r18, 0x00	; 0
    390c:	81 ad       	ldd	r24, Z+57	; 0x39
    390e:	90 e0       	ldi	r25, 0x00	; 0
    3910:	82 2b       	or	r24, r18
    3912:	93 2b       	or	r25, r19
    3914:	90 93 be 03 	sts	0x03BE, r25
    3918:	80 93 bd 03 	sts	0x03BD, r24
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    391c:	f5 e0       	ldi	r31, 0x05	; 5
    391e:	87 3a       	cpi	r24, 0xA7	; 167
    3920:	9f 07       	cpc	r25, r31
    3922:	10 f0       	brcs	.+4      	; 0x3928 <uip_process+0x6fa>
    3924:	86 ea       	ldi	r24, 0xA6	; 166
    3926:	95 e0       	ldi	r25, 0x05	; 5
    3928:	9b 8b       	std	Y+19, r25	; 0x13
    392a:	8a 8b       	std	Y+18, r24	; 0x12
    392c:	9d 8b       	std	Y+21, r25	; 0x15
    392e:	8c 8b       	std	Y+20, r24	; 0x14
    3930:	1e c0       	rjmp	.+60     	; 0x396e <uip_process+0x740>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    3932:	90 91 bb 03 	lds	r25, 0x03BB
    3936:	e9 2f       	mov	r30, r25
    3938:	f0 e0       	ldi	r31, 0x00	; 0
    393a:	e8 5f       	subi	r30, 0xF8	; 248
    393c:	f9 4f       	sbci	r31, 0xF9	; 249
    393e:	87 a9       	ldd	r24, Z+55	; 0x37
    3940:	88 23       	and	r24, r24
    3942:	a9 f0       	breq	.+42     	; 0x396e <uip_process+0x740>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    3944:	89 0f       	add	r24, r25
    3946:	80 93 bb 03 	sts	0x03BB, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    394a:	40 91 bb 03 	lds	r20, 0x03BB
    394e:	24 2f       	mov	r18, r20
    3950:	30 e0       	ldi	r19, 0x00	; 0
    3952:	80 91 36 06 	lds	r24, 0x0636
    3956:	82 95       	swap	r24
    3958:	8f 70       	andi	r24, 0x0F	; 15
    395a:	90 e0       	ldi	r25, 0x00	; 0
    395c:	05 97       	sbiw	r24, 0x05	; 5
    395e:	88 0f       	add	r24, r24
    3960:	99 1f       	adc	r25, r25
    3962:	88 0f       	add	r24, r24
    3964:	99 1f       	adc	r25, r25
    3966:	28 17       	cp	r18, r24
    3968:	39 07       	cpc	r19, r25
    396a:	0c f4       	brge	.+2      	; 0x396e <uip_process+0x740>
    396c:	ba cf       	rjmp	.-140    	; 0x38e2 <uip_process+0x6b4>
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    396e:	80 e1       	ldi	r24, 0x10	; 16
    3970:	80 93 37 06 	sts	0x0637, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    3974:	80 91 37 06 	lds	r24, 0x0637
    3978:	82 60       	ori	r24, 0x02	; 2
    397a:	80 93 37 06 	sts	0x0637, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    397e:	82 e0       	ldi	r24, 0x02	; 2
    3980:	80 93 3e 06 	sts	0x063E, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    3984:	84 e0       	ldi	r24, 0x04	; 4
    3986:	80 93 3f 06 	sts	0x063F, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    398a:	85 e0       	ldi	r24, 0x05	; 5
    398c:	80 93 40 06 	sts	0x0640, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    3990:	86 ea       	ldi	r24, 0xA6	; 166
    3992:	80 93 41 06 	sts	0x0641, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    3996:	8c e2       	ldi	r24, 0x2C	; 44
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	90 93 66 04 	sts	0x0466, r25
    399e:	80 93 65 04 	sts	0x0465, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    39a2:	80 e6       	ldi	r24, 0x60	; 96
    39a4:	bb c2       	rjmp	.+1398   	; 0x3f1c <uip_process+0xcee>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    39a6:	d0 93 71 04 	sts	0x0471, r29
    39aa:	c0 93 70 04 	sts	0x0470, r28
  uip_flags = 0;
    39ae:	10 92 6d 04 	sts	0x046D, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    39b2:	80 91 37 06 	lds	r24, 0x0637
    39b6:	48 2f       	mov	r20, r24
    39b8:	50 e0       	ldi	r21, 0x00	; 0
    39ba:	82 ff       	sbrs	r24, 2
    39bc:	07 c0       	rjmp	.+14     	; 0x39cc <uip_process+0x79e>
    uip_connr->tcpstateflags = UIP_CLOSED;
    39be:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    39c0:	82 ee       	ldi	r24, 0xE2	; 226
    39c2:	91 e0       	ldi	r25, 0x01	; 1
    39c4:	0e 94 cd 10 	call	0x219a	; 0x219a <uip_log>
    uip_flags = UIP_ABORT;
    39c8:	80 e2       	ldi	r24, 0x20	; 32
    39ca:	51 c2       	rjmp	.+1186   	; 0x3e6e <uip_process+0xc40>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculated the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    39cc:	80 91 36 06 	lds	r24, 0x0636
    39d0:	82 95       	swap	r24
    39d2:	8f 70       	andi	r24, 0x0F	; 15
    39d4:	88 0f       	add	r24, r24
    39d6:	88 0f       	add	r24, r24
    39d8:	80 93 bb 03 	sts	0x03BB, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    39dc:	20 91 65 04 	lds	r18, 0x0465
    39e0:	30 91 66 04 	lds	r19, 0x0466
    39e4:	24 51       	subi	r18, 0x14	; 20
    39e6:	30 40       	sbci	r19, 0x00	; 0
    39e8:	28 1b       	sub	r18, r24
    39ea:	31 09       	sbc	r19, r1
    39ec:	30 93 66 04 	sts	0x0466, r19
    39f0:	20 93 65 04 	sts	0x0465, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    39f4:	89 8d       	ldd	r24, Y+25	; 0x19
    39f6:	8f 70       	andi	r24, 0x0F	; 15
    39f8:	82 30       	cpi	r24, 0x02	; 2
    39fa:	29 f4       	brne	.+10     	; 0x3a06 <uip_process+0x7d8>
    39fc:	4f 73       	andi	r20, 0x3F	; 63
    39fe:	50 70       	andi	r21, 0x00	; 0
    3a00:	42 31       	cpi	r20, 0x12	; 18
    3a02:	51 05       	cpc	r21, r1
    3a04:	09 f1       	breq	.+66     	; 0x3a48 <uip_process+0x81a>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    3a06:	23 2b       	or	r18, r19
    3a08:	39 f4       	brne	.+14     	; 0x3a18 <uip_process+0x7ea>
    3a0a:	80 91 37 06 	lds	r24, 0x0637
    3a0e:	90 e0       	ldi	r25, 0x00	; 0
    3a10:	83 70       	andi	r24, 0x03	; 3
    3a12:	90 70       	andi	r25, 0x00	; 0
    3a14:	89 2b       	or	r24, r25
    3a16:	c1 f0       	breq	.+48     	; 0x3a48 <uip_process+0x81a>
    3a18:	90 91 2e 06 	lds	r25, 0x062E
    3a1c:	88 85       	ldd	r24, Y+8	; 0x08
    3a1e:	98 17       	cp	r25, r24
    3a20:	09 f0       	breq	.+2      	; 0x3a24 <uip_process+0x7f6>
    3a22:	72 c2       	rjmp	.+1252   	; 0x3f08 <uip_process+0xcda>
    3a24:	90 91 2f 06 	lds	r25, 0x062F
    3a28:	89 85       	ldd	r24, Y+9	; 0x09
    3a2a:	98 17       	cp	r25, r24
    3a2c:	09 f0       	breq	.+2      	; 0x3a30 <uip_process+0x802>
    3a2e:	6c c2       	rjmp	.+1240   	; 0x3f08 <uip_process+0xcda>
    3a30:	90 91 30 06 	lds	r25, 0x0630
    3a34:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a36:	98 17       	cp	r25, r24
    3a38:	09 f0       	breq	.+2      	; 0x3a3c <uip_process+0x80e>
    3a3a:	66 c2       	rjmp	.+1228   	; 0x3f08 <uip_process+0xcda>
    3a3c:	90 91 31 06 	lds	r25, 0x0631
    3a40:	8b 85       	ldd	r24, Y+11	; 0x0b
    3a42:	98 17       	cp	r25, r24
    3a44:	09 f0       	breq	.+2      	; 0x3a48 <uip_process+0x81a>
    3a46:	60 c2       	rjmp	.+1216   	; 0x3f08 <uip_process+0xcda>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    3a48:	80 91 37 06 	lds	r24, 0x0637
    3a4c:	84 ff       	sbrs	r24, 4
    3a4e:	51 c0       	rjmp	.+162    	; 0x3af2 <uip_process+0x8c4>
    3a50:	68 89       	ldd	r22, Y+16	; 0x10
    3a52:	79 89       	ldd	r23, Y+17	; 0x11
    3a54:	61 15       	cp	r22, r1
    3a56:	71 05       	cpc	r23, r1
    3a58:	09 f4       	brne	.+2      	; 0x3a5c <uip_process+0x82e>
    3a5a:	4b c0       	rjmp	.+150    	; 0x3af2 <uip_process+0x8c4>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    3a5c:	ce 01       	movw	r24, r28
    3a5e:	0c 96       	adiw	r24, 0x0c	; 12
    3a60:	0e 94 49 17 	call	0x2e92	; 0x2e92 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    3a64:	20 91 32 06 	lds	r18, 0x0632
    3a68:	80 91 69 04 	lds	r24, 0x0469
    3a6c:	28 17       	cp	r18, r24
    3a6e:	09 f0       	breq	.+2      	; 0x3a72 <uip_process+0x844>
    3a70:	40 c0       	rjmp	.+128    	; 0x3af2 <uip_process+0x8c4>
    3a72:	90 91 33 06 	lds	r25, 0x0633
    3a76:	80 91 6a 04 	lds	r24, 0x046A
    3a7a:	98 17       	cp	r25, r24
    3a7c:	d1 f5       	brne	.+116    	; 0x3af2 <uip_process+0x8c4>
    3a7e:	90 91 34 06 	lds	r25, 0x0634
    3a82:	80 91 6b 04 	lds	r24, 0x046B
    3a86:	98 17       	cp	r25, r24
    3a88:	a1 f5       	brne	.+104    	; 0x3af2 <uip_process+0x8c4>
    3a8a:	90 91 35 06 	lds	r25, 0x0635
    3a8e:	80 91 6c 04 	lds	r24, 0x046C
    3a92:	98 17       	cp	r25, r24
    3a94:	71 f5       	brne	.+92     	; 0x3af2 <uip_process+0x8c4>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    3a96:	2c 87       	std	Y+12, r18	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    3a98:	80 91 6a 04 	lds	r24, 0x046A
    3a9c:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    3a9e:	80 91 6b 04 	lds	r24, 0x046B
    3aa2:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    3aa4:	80 91 6c 04 	lds	r24, 0x046C
    3aa8:	8f 87       	std	Y+15, r24	; 0x0f
	

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    3aaa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3aac:	88 23       	and	r24, r24
    3aae:	d1 f4       	brne	.+52     	; 0x3ae4 <uip_process+0x8b6>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    3ab0:	2e 89       	ldd	r18, Y+22	; 0x16
    3ab2:	98 8d       	ldd	r25, Y+24	; 0x18
    3ab4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3ab6:	98 1b       	sub	r25, r24
    3ab8:	82 2f       	mov	r24, r18
    3aba:	86 95       	lsr	r24
    3abc:	86 95       	lsr	r24
    3abe:	86 95       	lsr	r24
    3ac0:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    3ac2:	39 2f       	mov	r19, r25
    3ac4:	32 0f       	add	r19, r18
    3ac6:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    3ac8:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    3aca:	28 2f       	mov	r18, r24
    3acc:	26 95       	lsr	r18
    3ace:	26 95       	lsr	r18
    3ad0:	82 1b       	sub	r24, r18
    3ad2:	97 fd       	sbrc	r25, 7
    3ad4:	91 95       	neg	r25
    3ad6:	89 0f       	add	r24, r25
    3ad8:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    3ada:	36 95       	lsr	r19
    3adc:	36 95       	lsr	r19
    3ade:	36 95       	lsr	r19
    3ae0:	83 0f       	add	r24, r19
    3ae2:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    3ae4:	81 e0       	ldi	r24, 0x01	; 1
    3ae6:	80 93 6d 04 	sts	0x046D, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    3aea:	88 8d       	ldd	r24, Y+24	; 0x18
    3aec:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    3aee:	19 8a       	std	Y+17, r1	; 0x11
    3af0:	18 8a       	std	Y+16, r1	; 0x10
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    3af2:	89 8d       	ldd	r24, Y+25	; 0x19
    3af4:	28 2f       	mov	r18, r24
    3af6:	30 e0       	ldi	r19, 0x00	; 0
    3af8:	c9 01       	movw	r24, r18
    3afa:	8f 70       	andi	r24, 0x0F	; 15
    3afc:	90 70       	andi	r25, 0x00	; 0
    3afe:	84 30       	cpi	r24, 0x04	; 4
    3b00:	91 05       	cpc	r25, r1
    3b02:	09 f4       	brne	.+2      	; 0x3b06 <uip_process+0x8d8>
    3b04:	b9 c1       	rjmp	.+882    	; 0x3e78 <uip_process+0xc4a>
    3b06:	85 30       	cpi	r24, 0x05	; 5
    3b08:	91 05       	cpc	r25, r1
    3b0a:	5c f4       	brge	.+22     	; 0x3b22 <uip_process+0x8f4>
    3b0c:	82 30       	cpi	r24, 0x02	; 2
    3b0e:	91 05       	cpc	r25, r1
    3b10:	91 f1       	breq	.+100    	; 0x3b76 <uip_process+0x948>
    3b12:	83 30       	cpi	r24, 0x03	; 3
    3b14:	91 05       	cpc	r25, r1
    3b16:	0c f0       	brlt	.+2      	; 0x3b1a <uip_process+0x8ec>
    3b18:	b1 c0       	rjmp	.+354    	; 0x3c7c <uip_process+0xa4e>
    3b1a:	01 97       	sbiw	r24, 0x01	; 1
    3b1c:	09 f0       	breq	.+2      	; 0x3b20 <uip_process+0x8f2>
    3b1e:	a1 c2       	rjmp	.+1346   	; 0x4062 <uip_process+0xe34>
    3b20:	10 c0       	rjmp	.+32     	; 0x3b42 <uip_process+0x914>
    3b22:	86 30       	cpi	r24, 0x06	; 6
    3b24:	91 05       	cpc	r25, r1
    3b26:	09 f4       	brne	.+2      	; 0x3b2a <uip_process+0x8fc>
    3b28:	e7 c1       	rjmp	.+974    	; 0x3ef8 <uip_process+0xcca>
    3b2a:	86 30       	cpi	r24, 0x06	; 6
    3b2c:	91 05       	cpc	r25, r1
    3b2e:	0c f4       	brge	.+2      	; 0x3b32 <uip_process+0x904>
    3b30:	c3 c1       	rjmp	.+902    	; 0x3eb8 <uip_process+0xc8a>
    3b32:	87 30       	cpi	r24, 0x07	; 7
    3b34:	91 05       	cpc	r25, r1
    3b36:	09 f4       	brne	.+2      	; 0x3b3a <uip_process+0x90c>
    3b38:	e7 c1       	rjmp	.+974    	; 0x3f08 <uip_process+0xcda>
    3b3a:	08 97       	sbiw	r24, 0x08	; 8
    3b3c:	09 f0       	breq	.+2      	; 0x3b40 <uip_process+0x912>
    3b3e:	91 c2       	rjmp	.+1314   	; 0x4062 <uip_process+0xe34>
    3b40:	90 c1       	rjmp	.+800    	; 0x3e62 <uip_process+0xc34>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    3b42:	80 91 6d 04 	lds	r24, 0x046D
    3b46:	80 ff       	sbrs	r24, 0
    3b48:	8c c2       	rjmp	.+1304   	; 0x4062 <uip_process+0xe34>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    3b4a:	83 e0       	ldi	r24, 0x03	; 3
    3b4c:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    3b4e:	80 e4       	ldi	r24, 0x40	; 64
    3b50:	80 93 6d 04 	sts	0x046D, r24
      uip_connr->len = 0;
    3b54:	19 8a       	std	Y+17, r1	; 0x11
    3b56:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    3b58:	20 91 65 04 	lds	r18, 0x0465
    3b5c:	30 91 66 04 	lds	r19, 0x0466
    3b60:	21 15       	cp	r18, r1
    3b62:	31 05       	cpc	r19, r1
    3b64:	09 f4       	brne	.+2      	; 0x3b68 <uip_process+0x93a>
    3b66:	11 c1       	rjmp	.+546    	; 0x3d8a <uip_process+0xb5c>
        uip_flags |= UIP_NEWDATA;
    3b68:	82 e4       	ldi	r24, 0x42	; 66
    3b6a:	80 93 6d 04 	sts	0x046D, r24
        uip_add_rcv_nxt(uip_len);
    3b6e:	c9 01       	movw	r24, r18
    3b70:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
    3b74:	0a c1       	rjmp	.+532    	; 0x3d8a <uip_process+0xb5c>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    3b76:	80 91 6d 04 	lds	r24, 0x046D
    3b7a:	80 ff       	sbrs	r24, 0
    3b7c:	74 c0       	rjmp	.+232    	; 0x3c66 <uip_process+0xa38>
    3b7e:	80 91 37 06 	lds	r24, 0x0637
    3b82:	8f 73       	andi	r24, 0x3F	; 63
    3b84:	82 31       	cpi	r24, 0x12	; 18
    3b86:	09 f0       	breq	.+2      	; 0x3b8a <uip_process+0x95c>
    3b88:	6e c0       	rjmp	.+220    	; 0x3c66 <uip_process+0xa38>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    3b8a:	80 91 36 06 	lds	r24, 0x0636
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	80 7f       	andi	r24, 0xF0	; 240
    3b92:	90 70       	andi	r25, 0x00	; 0
    3b94:	81 35       	cpi	r24, 0x51	; 81
    3b96:	91 05       	cpc	r25, r1
    3b98:	0c f4       	brge	.+2      	; 0x3b9c <uip_process+0x96e>
    3b9a:	49 c0       	rjmp	.+146    	; 0x3c2e <uip_process+0xa00>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    3b9c:	10 92 bb 03 	sts	0x03BB, r1
    3ba0:	34 c0       	rjmp	.+104    	; 0x3c0a <uip_process+0x9dc>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    3ba2:	f9 01       	movw	r30, r18
    3ba4:	e8 5f       	subi	r30, 0xF8	; 248
    3ba6:	f9 4f       	sbci	r31, 0xF9	; 249
    3ba8:	86 a9       	ldd	r24, Z+54	; 0x36
    3baa:	80 93 bc 03 	sts	0x03BC, r24
	  if(opt == TCP_OPT_END) {
    3bae:	88 23       	and	r24, r24
    3bb0:	f1 f1       	breq	.+124    	; 0x3c2e <uip_process+0xa00>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    3bb2:	81 30       	cpi	r24, 0x01	; 1
    3bb4:	21 f4       	brne	.+8      	; 0x3bbe <uip_process+0x990>
	    ++c;
    3bb6:	4f 5f       	subi	r20, 0xFF	; 255
    3bb8:	40 93 bb 03 	sts	0x03BB, r20
    3bbc:	26 c0       	rjmp	.+76     	; 0x3c0a <uip_process+0x9dc>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    3bbe:	82 30       	cpi	r24, 0x02	; 2
    3bc0:	c1 f4       	brne	.+48     	; 0x3bf2 <uip_process+0x9c4>
    3bc2:	87 a9       	ldd	r24, Z+55	; 0x37
    3bc4:	84 30       	cpi	r24, 0x04	; 4
    3bc6:	a9 f4       	brne	.+42     	; 0x3bf2 <uip_process+0x9c4>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    3bc8:	30 ad       	ldd	r19, Z+56	; 0x38
    3bca:	20 e0       	ldi	r18, 0x00	; 0
    3bcc:	81 ad       	ldd	r24, Z+57	; 0x39
    3bce:	90 e0       	ldi	r25, 0x00	; 0
    3bd0:	82 2b       	or	r24, r18
    3bd2:	93 2b       	or	r25, r19
    3bd4:	90 93 be 03 	sts	0x03BE, r25
    3bd8:	80 93 bd 03 	sts	0x03BD, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    3bdc:	25 e0       	ldi	r18, 0x05	; 5
    3bde:	87 3a       	cpi	r24, 0xA7	; 167
    3be0:	92 07       	cpc	r25, r18
    3be2:	10 f0       	brcs	.+4      	; 0x3be8 <uip_process+0x9ba>
    3be4:	86 ea       	ldi	r24, 0xA6	; 166
    3be6:	95 e0       	ldi	r25, 0x05	; 5
    3be8:	9b 8b       	std	Y+19, r25	; 0x13
    3bea:	8a 8b       	std	Y+18, r24	; 0x12
    3bec:	9d 8b       	std	Y+21, r25	; 0x15
    3bee:	8c 8b       	std	Y+20, r24	; 0x14
    3bf0:	1e c0       	rjmp	.+60     	; 0x3c2e <uip_process+0xa00>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    3bf2:	90 91 bb 03 	lds	r25, 0x03BB
    3bf6:	e9 2f       	mov	r30, r25
    3bf8:	f0 e0       	ldi	r31, 0x00	; 0
    3bfa:	e8 5f       	subi	r30, 0xF8	; 248
    3bfc:	f9 4f       	sbci	r31, 0xF9	; 249
    3bfe:	87 a9       	ldd	r24, Z+55	; 0x37
    3c00:	88 23       	and	r24, r24
    3c02:	a9 f0       	breq	.+42     	; 0x3c2e <uip_process+0xa00>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    3c04:	89 0f       	add	r24, r25
    3c06:	80 93 bb 03 	sts	0x03BB, r24
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    3c0a:	40 91 bb 03 	lds	r20, 0x03BB
    3c0e:	24 2f       	mov	r18, r20
    3c10:	30 e0       	ldi	r19, 0x00	; 0
    3c12:	80 91 36 06 	lds	r24, 0x0636
    3c16:	82 95       	swap	r24
    3c18:	8f 70       	andi	r24, 0x0F	; 15
    3c1a:	90 e0       	ldi	r25, 0x00	; 0
    3c1c:	05 97       	sbiw	r24, 0x05	; 5
    3c1e:	88 0f       	add	r24, r24
    3c20:	99 1f       	adc	r25, r25
    3c22:	88 0f       	add	r24, r24
    3c24:	99 1f       	adc	r25, r25
    3c26:	28 17       	cp	r18, r24
    3c28:	39 07       	cpc	r19, r25
    3c2a:	0c f4       	brge	.+2      	; 0x3c2e <uip_process+0xa00>
    3c2c:	ba cf       	rjmp	.-140    	; 0x3ba2 <uip_process+0x974>
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    3c2e:	83 e0       	ldi	r24, 0x03	; 3
    3c30:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    3c32:	80 91 2e 06 	lds	r24, 0x062E
    3c36:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    3c38:	80 91 2f 06 	lds	r24, 0x062F
    3c3c:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    3c3e:	80 91 30 06 	lds	r24, 0x0630
    3c42:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    3c44:	80 91 31 06 	lds	r24, 0x0631
    3c48:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    3c4a:	81 e0       	ldi	r24, 0x01	; 1
    3c4c:	90 e0       	ldi	r25, 0x00	; 0
    3c4e:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    3c52:	82 e4       	ldi	r24, 0x42	; 66
    3c54:	80 93 6d 04 	sts	0x046D, r24
      uip_connr->len = 0;
    3c58:	19 8a       	std	Y+17, r1	; 0x11
    3c5a:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    3c5c:	10 92 66 04 	sts	0x0466, r1
    3c60:	10 92 65 04 	sts	0x0465, r1
    3c64:	92 c0       	rjmp	.+292    	; 0x3d8a <uip_process+0xb5c>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    3c66:	80 e2       	ldi	r24, 0x20	; 32
    3c68:	80 93 6d 04 	sts	0x046D, r24
    UIP_APPCALL();
    3c6c:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    3c70:	e0 91 70 04 	lds	r30, 0x0470
    3c74:	f0 91 71 04 	lds	r31, 0x0471
    3c78:	11 8e       	std	Z+25, r1	; 0x19
    3c7a:	30 cd       	rjmp	.-1440   	; 0x36dc <uip_process+0x4ae>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    3c7c:	80 91 37 06 	lds	r24, 0x0637
    3c80:	80 ff       	sbrs	r24, 0
    3c82:	2a c0       	rjmp	.+84     	; 0x3cd8 <uip_process+0xaaa>
    3c84:	24 fd       	sbrc	r18, 4
    3c86:	28 c0       	rjmp	.+80     	; 0x3cd8 <uip_process+0xaaa>
      if(uip_outstanding(uip_connr)) {
    3c88:	88 89       	ldd	r24, Y+16	; 0x10
    3c8a:	99 89       	ldd	r25, Y+17	; 0x11
    3c8c:	89 2b       	or	r24, r25
    3c8e:	09 f0       	breq	.+2      	; 0x3c92 <uip_process+0xa64>
    3c90:	e8 c1       	rjmp	.+976    	; 0x4062 <uip_process+0xe34>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    3c92:	80 91 65 04 	lds	r24, 0x0465
    3c96:	90 91 66 04 	lds	r25, 0x0466
    3c9a:	01 96       	adiw	r24, 0x01	; 1
    3c9c:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    3ca0:	20 91 6d 04 	lds	r18, 0x046D
    3ca4:	82 2f       	mov	r24, r18
    3ca6:	80 61       	ori	r24, 0x10	; 16
    3ca8:	80 93 6d 04 	sts	0x046D, r24
      if(uip_len > 0) {
    3cac:	80 91 65 04 	lds	r24, 0x0465
    3cb0:	90 91 66 04 	lds	r25, 0x0466
    3cb4:	89 2b       	or	r24, r25
    3cb6:	19 f0       	breq	.+6      	; 0x3cbe <uip_process+0xa90>
	uip_flags |= UIP_NEWDATA;
    3cb8:	22 61       	ori	r18, 0x12	; 18
    3cba:	20 93 6d 04 	sts	0x046D, r18
      }
      UIP_APPCALL();
    3cbe:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>
      uip_connr->len = 1;
    3cc2:	81 e0       	ldi	r24, 0x01	; 1
    3cc4:	90 e0       	ldi	r25, 0x00	; 0
    3cc6:	99 8b       	std	Y+17, r25	; 0x11
    3cc8:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    3cca:	88 e0       	ldi	r24, 0x08	; 8
    3ccc:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    3cce:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    3cd0:	81 e1       	ldi	r24, 0x11	; 17
    3cd2:	80 93 37 06 	sts	0x0637, r24
    3cd6:	1b c1       	rjmp	.+566    	; 0x3f0e <uip_process+0xce0>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    3cd8:	85 ff       	sbrs	r24, 5
    3cda:	21 c0       	rjmp	.+66     	; 0x3d1e <uip_process+0xaf0>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    3cdc:	60 91 3c 06 	lds	r22, 0x063C
    3ce0:	36 2f       	mov	r19, r22
    3ce2:	20 e0       	ldi	r18, 0x00	; 0
    3ce4:	40 91 3d 06 	lds	r20, 0x063D
    3ce8:	50 e0       	ldi	r21, 0x00	; 0
    3cea:	24 2b       	or	r18, r20
    3cec:	35 2b       	or	r19, r21
    3cee:	80 91 6e 04 	lds	r24, 0x046E
    3cf2:	90 91 6f 04 	lds	r25, 0x046F
    3cf6:	82 0f       	add	r24, r18
    3cf8:	93 1f       	adc	r25, r19
    3cfa:	90 93 6f 04 	sts	0x046F, r25
    3cfe:	80 93 6e 04 	sts	0x046E, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    3d02:	96 2f       	mov	r25, r22
    3d04:	80 e0       	ldi	r24, 0x00	; 0
    3d06:	84 2b       	or	r24, r20
    3d08:	95 2b       	or	r25, r21
    3d0a:	20 91 65 04 	lds	r18, 0x0465
    3d0e:	30 91 66 04 	lds	r19, 0x0466
    3d12:	28 1b       	sub	r18, r24
    3d14:	39 0b       	sbc	r19, r25
    3d16:	30 93 66 04 	sts	0x0466, r19
    3d1a:	20 93 65 04 	sts	0x0465, r18
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    3d1e:	20 91 65 04 	lds	r18, 0x0465
    3d22:	30 91 66 04 	lds	r19, 0x0466
    3d26:	21 15       	cp	r18, r1
    3d28:	31 05       	cpc	r19, r1
    3d2a:	59 f0       	breq	.+22     	; 0x3d42 <uip_process+0xb14>
    3d2c:	89 8d       	ldd	r24, Y+25	; 0x19
    3d2e:	84 fd       	sbrc	r24, 4
    3d30:	08 c0       	rjmp	.+16     	; 0x3d42 <uip_process+0xb14>
      uip_flags |= UIP_NEWDATA;
    3d32:	80 91 6d 04 	lds	r24, 0x046D
    3d36:	82 60       	ori	r24, 0x02	; 2
    3d38:	80 93 6d 04 	sts	0x046D, r24
      uip_add_rcv_nxt(uip_len);
    3d3c:	c9 01       	movw	r24, r18
    3d3e:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    3d42:	90 91 38 06 	lds	r25, 0x0638
    3d46:	80 e0       	ldi	r24, 0x00	; 0
    3d48:	20 91 39 06 	lds	r18, 0x0639
    3d4c:	82 0f       	add	r24, r18
    3d4e:	91 1d       	adc	r25, r1
    3d50:	90 93 be 03 	sts	0x03BE, r25
    3d54:	80 93 bd 03 	sts	0x03BD, r24
    if(tmp16 > uip_connr->initialmss ||
    3d58:	2c 89       	ldd	r18, Y+20	; 0x14
    3d5a:	3d 89       	ldd	r19, Y+21	; 0x15
    3d5c:	28 17       	cp	r18, r24
    3d5e:	39 07       	cpc	r19, r25
    3d60:	10 f0       	brcs	.+4      	; 0x3d66 <uip_process+0xb38>
    3d62:	89 2b       	or	r24, r25
    3d64:	21 f4       	brne	.+8      	; 0x3d6e <uip_process+0xb40>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    3d66:	30 93 be 03 	sts	0x03BE, r19
    3d6a:	20 93 bd 03 	sts	0x03BD, r18
    }
    uip_connr->mss = tmp16;
    3d6e:	80 91 bd 03 	lds	r24, 0x03BD
    3d72:	90 91 be 03 	lds	r25, 0x03BE
    3d76:	9b 8b       	std	Y+19, r25	; 0x13
    3d78:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    3d7a:	80 91 6d 04 	lds	r24, 0x046D
    3d7e:	90 e0       	ldi	r25, 0x00	; 0
    3d80:	83 70       	andi	r24, 0x03	; 3
    3d82:	90 70       	andi	r25, 0x00	; 0
    3d84:	89 2b       	or	r24, r25
    3d86:	09 f4       	brne	.+2      	; 0x3d8a <uip_process+0xb5c>
    3d88:	6c c1       	rjmp	.+728    	; 0x4062 <uip_process+0xe34>
      uip_slen = 0;
    3d8a:	10 92 e7 0b 	sts	0x0BE7, r1
    3d8e:	10 92 e6 0b 	sts	0x0BE6, r1
      UIP_APPCALL();
    3d92:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    3d96:	80 91 6d 04 	lds	r24, 0x046D
    3d9a:	28 2f       	mov	r18, r24
    3d9c:	85 ff       	sbrs	r24, 5
    3d9e:	07 c0       	rjmp	.+14     	; 0x3dae <uip_process+0xb80>
	uip_slen = 0;
    3da0:	10 92 e7 0b 	sts	0x0BE7, r1
    3da4:	10 92 e6 0b 	sts	0x0BE6, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    3da8:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    3daa:	84 e1       	ldi	r24, 0x14	; 20
    3dac:	92 cf       	rjmp	.-220    	; 0x3cd2 <uip_process+0xaa4>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    3dae:	84 ff       	sbrs	r24, 4
    3db0:	0a c0       	rjmp	.+20     	; 0x3dc6 <uip_process+0xb98>
	uip_slen = 0;
    3db2:	10 92 e7 0b 	sts	0x0BE7, r1
    3db6:	10 92 e6 0b 	sts	0x0BE6, r1
	uip_connr->len = 1;
    3dba:	81 e0       	ldi	r24, 0x01	; 1
    3dbc:	90 e0       	ldi	r25, 0x00	; 0
    3dbe:	99 8b       	std	Y+17, r25	; 0x11
    3dc0:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    3dc2:	84 e0       	ldi	r24, 0x04	; 4
    3dc4:	83 cf       	rjmp	.-250    	; 0x3ccc <uip_process+0xa9e>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    3dc6:	80 91 e6 0b 	lds	r24, 0x0BE6
    3dca:	90 91 e7 0b 	lds	r25, 0x0BE7
    3dce:	89 2b       	or	r24, r25
    3dd0:	01 f1       	breq	.+64     	; 0x3e12 <uip_process+0xbe4>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    3dd2:	20 ff       	sbrs	r18, 0
    3dd4:	02 c0       	rjmp	.+4      	; 0x3dda <uip_process+0xbac>
	  uip_connr->len = 0;
    3dd6:	19 8a       	std	Y+17, r1	; 0x11
    3dd8:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    3dda:	88 89       	ldd	r24, Y+16	; 0x10
    3ddc:	99 89       	ldd	r25, Y+17	; 0x11
    3dde:	00 97       	sbiw	r24, 0x00	; 0
    3de0:	a1 f4       	brne	.+40     	; 0x3e0a <uip_process+0xbdc>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    3de2:	2a 89       	ldd	r18, Y+18	; 0x12
    3de4:	3b 89       	ldd	r19, Y+19	; 0x13
    3de6:	80 91 e6 0b 	lds	r24, 0x0BE6
    3dea:	90 91 e7 0b 	lds	r25, 0x0BE7
    3dee:	28 17       	cp	r18, r24
    3df0:	39 07       	cpc	r19, r25
    3df2:	20 f4       	brcc	.+8      	; 0x3dfc <uip_process+0xbce>
	    uip_slen = uip_connr->mss;
    3df4:	30 93 e7 0b 	sts	0x0BE7, r19
    3df8:	20 93 e6 0b 	sts	0x0BE6, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    3dfc:	80 91 e6 0b 	lds	r24, 0x0BE6
    3e00:	90 91 e7 0b 	lds	r25, 0x0BE7
    3e04:	99 8b       	std	Y+17, r25	; 0x11
    3e06:	88 8b       	std	Y+16, r24	; 0x10
    3e08:	04 c0       	rjmp	.+8      	; 0x3e12 <uip_process+0xbe4>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    3e0a:	90 93 e7 0b 	sts	0x0BE7, r25
    3e0e:	80 93 e6 0b 	sts	0x0BE6, r24
	}
      }
      uip_connr->nrtx = 0;
    3e12:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    3e14:	80 91 67 04 	lds	r24, 0x0467
    3e18:	90 91 68 04 	lds	r25, 0x0468
    3e1c:	90 93 6f 04 	sts	0x046F, r25
    3e20:	80 93 6e 04 	sts	0x046E, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    3e24:	80 91 e6 0b 	lds	r24, 0x0BE6
    3e28:	90 91 e7 0b 	lds	r25, 0x0BE7
    3e2c:	89 2b       	or	r24, r25
    3e2e:	59 f0       	breq	.+22     	; 0x3e46 <uip_process+0xc18>
    3e30:	88 89       	ldd	r24, Y+16	; 0x10
    3e32:	99 89       	ldd	r25, Y+17	; 0x11
    3e34:	00 97       	sbiw	r24, 0x00	; 0
    3e36:	39 f0       	breq	.+14     	; 0x3e46 <uip_process+0xc18>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    3e38:	88 96       	adiw	r24, 0x28	; 40
    3e3a:	90 93 66 04 	sts	0x0466, r25
    3e3e:	80 93 65 04 	sts	0x0465, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    3e42:	88 e1       	ldi	r24, 0x18	; 24
    3e44:	0b c0       	rjmp	.+22     	; 0x3e5c <uip_process+0xc2e>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    3e46:	80 91 6d 04 	lds	r24, 0x046D
    3e4a:	81 ff       	sbrs	r24, 1
    3e4c:	0a c1       	rjmp	.+532    	; 0x4062 <uip_process+0xe34>
	uip_len = UIP_TCPIP_HLEN;
    3e4e:	88 e2       	ldi	r24, 0x28	; 40
    3e50:	90 e0       	ldi	r25, 0x00	; 0
    3e52:	90 93 66 04 	sts	0x0466, r25
    3e56:	80 93 65 04 	sts	0x0465, r24
	BUF->flags = TCP_ACK;
    3e5a:	80 e1       	ldi	r24, 0x10	; 16
    3e5c:	80 93 37 06 	sts	0x0637, r24
    3e60:	5c c0       	rjmp	.+184    	; 0x3f1a <uip_process+0xcec>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    3e62:	80 91 6d 04 	lds	r24, 0x046D
    3e66:	80 ff       	sbrs	r24, 0
    3e68:	fc c0       	rjmp	.+504    	; 0x4062 <uip_process+0xe34>
      uip_connr->tcpstateflags = UIP_CLOSED;
    3e6a:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    3e6c:	80 e1       	ldi	r24, 0x10	; 16
    3e6e:	80 93 6d 04 	sts	0x046D, r24
      UIP_APPCALL();
    3e72:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>
    3e76:	f5 c0       	rjmp	.+490    	; 0x4062 <uip_process+0xe34>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    3e78:	80 91 65 04 	lds	r24, 0x0465
    3e7c:	90 91 66 04 	lds	r25, 0x0466
    3e80:	00 97       	sbiw	r24, 0x00	; 0
    3e82:	11 f0       	breq	.+4      	; 0x3e88 <uip_process+0xc5a>
      uip_add_rcv_nxt(uip_len);
    3e84:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    3e88:	80 91 37 06 	lds	r24, 0x0637
    3e8c:	90 91 6d 04 	lds	r25, 0x046D
    3e90:	80 ff       	sbrs	r24, 0
    3e92:	0b c0       	rjmp	.+22     	; 0x3eaa <uip_process+0xc7c>
      if(uip_flags & UIP_ACKDATA) {
    3e94:	90 ff       	sbrs	r25, 0
    3e96:	06 c0       	rjmp	.+12     	; 0x3ea4 <uip_process+0xc76>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3e98:	87 e0       	ldi	r24, 0x07	; 7
    3e9a:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    3e9c:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    3e9e:	19 8a       	std	Y+17, r1	; 0x11
    3ea0:	18 8a       	std	Y+16, r1	; 0x10
    3ea2:	19 c0       	rjmp	.+50     	; 0x3ed6 <uip_process+0xca8>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    3ea4:	86 e0       	ldi	r24, 0x06	; 6
    3ea6:	89 8f       	std	Y+25, r24	; 0x19
    3ea8:	16 c0       	rjmp	.+44     	; 0x3ed6 <uip_process+0xca8>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    3eaa:	90 ff       	sbrs	r25, 0
    3eac:	1e c0       	rjmp	.+60     	; 0x3eea <uip_process+0xcbc>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    3eae:	85 e0       	ldi	r24, 0x05	; 5
    3eb0:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    3eb2:	19 8a       	std	Y+17, r1	; 0x11
    3eb4:	18 8a       	std	Y+16, r1	; 0x10
    3eb6:	d5 c0       	rjmp	.+426    	; 0x4062 <uip_process+0xe34>
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    3eb8:	80 91 65 04 	lds	r24, 0x0465
    3ebc:	90 91 66 04 	lds	r25, 0x0466
    3ec0:	00 97       	sbiw	r24, 0x00	; 0
    3ec2:	11 f0       	breq	.+4      	; 0x3ec8 <uip_process+0xc9a>
      uip_add_rcv_nxt(uip_len);
    3ec4:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    3ec8:	80 91 37 06 	lds	r24, 0x0637
    3ecc:	80 ff       	sbrs	r24, 0
    3ece:	0d c0       	rjmp	.+26     	; 0x3eea <uip_process+0xcbc>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3ed0:	87 e0       	ldi	r24, 0x07	; 7
    3ed2:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3ed4:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    3ed6:	81 e0       	ldi	r24, 0x01	; 1
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	0e 94 d2 18 	call	0x31a4	; 0x31a4 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    3ede:	80 e1       	ldi	r24, 0x10	; 16
    3ee0:	80 93 6d 04 	sts	0x046D, r24
      UIP_APPCALL();
    3ee4:	0e 94 69 2a 	call	0x54d2	; 0x54d2 <httpd_appcall>
    3ee8:	0f c0       	rjmp	.+30     	; 0x3f08 <uip_process+0xcda>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    3eea:	80 91 65 04 	lds	r24, 0x0465
    3eee:	90 91 66 04 	lds	r25, 0x0466
    3ef2:	89 2b       	or	r24, r25
    3ef4:	49 f4       	brne	.+18     	; 0x3f08 <uip_process+0xcda>
    3ef6:	b5 c0       	rjmp	.+362    	; 0x4062 <uip_process+0xe34>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    3ef8:	80 91 6d 04 	lds	r24, 0x046D
    3efc:	80 ff       	sbrs	r24, 0
    3efe:	b1 c0       	rjmp	.+354    	; 0x4062 <uip_process+0xe34>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3f00:	87 e0       	ldi	r24, 0x07	; 7
    3f02:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3f04:	1a 8e       	std	Y+26, r1	; 0x1a
    3f06:	ad c0       	rjmp	.+346    	; 0x4062 <uip_process+0xe34>
  

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    3f08:	80 e1       	ldi	r24, 0x10	; 16
    3f0a:	f8 01       	movw	r30, r16
    3f0c:	81 a3       	std	Z+33, r24	; 0x21
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    3f0e:	88 e2       	ldi	r24, 0x28	; 40
    3f10:	90 e0       	ldi	r25, 0x00	; 0
    3f12:	90 93 66 04 	sts	0x0466, r25
    3f16:	80 93 65 04 	sts	0x0465, r24
 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    3f1a:	80 e5       	ldi	r24, 0x50	; 80
    3f1c:	80 93 36 06 	sts	0x0636, r24
 tcp_send:
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    3f20:	88 85       	ldd	r24, Y+8	; 0x08
    3f22:	80 93 32 06 	sts	0x0632, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    3f26:	89 85       	ldd	r24, Y+9	; 0x09
    3f28:	80 93 33 06 	sts	0x0633, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    3f2c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f2e:	80 93 34 06 	sts	0x0634, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    3f32:	8b 85       	ldd	r24, Y+11	; 0x0b
    3f34:	80 93 35 06 	sts	0x0635, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    3f38:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f3a:	80 93 2e 06 	sts	0x062E, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    3f3e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f40:	80 93 2f 06 	sts	0x062F, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    3f44:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f46:	80 93 30 06 	sts	0x0630, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    3f4a:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f4c:	80 93 31 06 	sts	0x0631, r24

  BUF->proto = UIP_PROTO_TCP;
    3f50:	86 e0       	ldi	r24, 0x06	; 6
    3f52:	80 93 1f 06 	sts	0x061F, r24
  
  BUF->srcport  = uip_connr->lport;
    3f56:	8c 81       	ldd	r24, Y+4	; 0x04
    3f58:	9d 81       	ldd	r25, Y+5	; 0x05
    3f5a:	90 93 2b 06 	sts	0x062B, r25
    3f5e:	80 93 2a 06 	sts	0x062A, r24
  BUF->destport = uip_connr->rport;
    3f62:	8e 81       	ldd	r24, Y+6	; 0x06
    3f64:	9f 81       	ldd	r25, Y+7	; 0x07
    3f66:	90 93 2d 06 	sts	0x062D, r25
    3f6a:	80 93 2c 06 	sts	0x062C, r24

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    3f6e:	80 91 04 06 	lds	r24, 0x0604
    3f72:	90 91 05 06 	lds	r25, 0x0605
    3f76:	90 93 23 06 	sts	0x0623, r25
    3f7a:	80 93 22 06 	sts	0x0622, r24
    3f7e:	80 91 06 06 	lds	r24, 0x0606
    3f82:	90 91 07 06 	lds	r25, 0x0607
    3f86:	90 93 25 06 	sts	0x0625, r25
    3f8a:	80 93 24 06 	sts	0x0624, r24
  uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
    3f8e:	88 81       	ld	r24, Y
    3f90:	99 81       	ldd	r25, Y+1	; 0x01
    3f92:	90 93 27 06 	sts	0x0627, r25
    3f96:	80 93 26 06 	sts	0x0626, r24
    3f9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f9e:	90 93 29 06 	sts	0x0629, r25
    3fa2:	80 93 28 06 	sts	0x0628, r24

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    3fa6:	89 8d       	ldd	r24, Y+25	; 0x19
    3fa8:	84 ff       	sbrs	r24, 4
    3faa:	05 c0       	rjmp	.+10     	; 0x3fb6 <uip_process+0xd88>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    3fac:	10 92 39 06 	sts	0x0639, r1
    3fb0:	10 92 38 06 	sts	0x0638, r1
    3fb4:	06 c0       	rjmp	.+12     	; 0x3fc2 <uip_process+0xd94>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    3fb6:	85 e0       	ldi	r24, 0x05	; 5
    3fb8:	80 93 38 06 	sts	0x0638, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    3fbc:	86 ea       	ldi	r24, 0xA6	; 166
    3fbe:	80 93 39 06 	sts	0x0639, r24
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    3fc2:	80 e4       	ldi	r24, 0x40	; 64
    3fc4:	80 93 1e 06 	sts	0x061E, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    3fc8:	80 91 66 04 	lds	r24, 0x0466
    3fcc:	80 93 18 06 	sts	0x0618, r24
  BUF->len[1] = (uip_len & 0xff);
    3fd0:	80 91 65 04 	lds	r24, 0x0465
    3fd4:	80 93 19 06 	sts	0x0619, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    3fd8:	10 92 3d 06 	sts	0x063D, r1
    3fdc:	10 92 3c 06 	sts	0x063C, r1
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    3fe0:	10 92 3b 06 	sts	0x063B, r1
    3fe4:	10 92 3a 06 	sts	0x063A, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    3fe8:	0e 94 e9 17 	call	0x2fd2	; 0x2fd2 <uip_tcpchksum>
    3fec:	80 95       	com	r24
    3fee:	90 95       	com	r25
    3ff0:	90 93 3b 06 	sts	0x063B, r25
    3ff4:	80 93 3a 06 	sts	0x063A, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    3ff8:	85 e4       	ldi	r24, 0x45	; 69
    3ffa:	80 93 16 06 	sts	0x0616, r24
  BUF->tos = 0;
    3ffe:	10 92 17 06 	sts	0x0617, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    4002:	10 92 1d 06 	sts	0x061D, r1
    4006:	10 92 1c 06 	sts	0x061C, r1
  ++ipid;
    400a:	80 91 b3 03 	lds	r24, 0x03B3
    400e:	90 91 b4 03 	lds	r25, 0x03B4
    4012:	01 96       	adiw	r24, 0x01	; 1
    4014:	90 93 b4 03 	sts	0x03B4, r25
    4018:	80 93 b3 03 	sts	0x03B3, r24
  BUF->ipid[0] = ipid >> 8;
    401c:	90 93 1a 06 	sts	0x061A, r25
  BUF->ipid[1] = ipid & 0xff;
    4020:	80 93 1b 06 	sts	0x061B, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    4024:	10 92 21 06 	sts	0x0621, r1
    4028:	10 92 20 06 	sts	0x0620, r1
  BUF->ipchksum = ~(uip_ipchksum());
    402c:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <uip_ipchksum>
    4030:	80 95       	com	r24
    4032:	90 95       	com	r25
    4034:	90 93 21 06 	sts	0x0621, r25
    4038:	80 93 20 06 	sts	0x0620, r24
  DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
#endif /* UIP_CONF_IPV6 */
   
  UIP_STAT(++uip_stat.tcp.sent);
    403c:	80 91 f2 05 	lds	r24, 0x05F2
    4040:	90 91 f3 05 	lds	r25, 0x05F3
    4044:	01 96       	adiw	r24, 0x01	; 1
    4046:	90 93 f3 05 	sts	0x05F3, r25
    404a:	80 93 f2 05 	sts	0x05F2, r24
 send:
  DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
	       (BUF->len[0] << 8) | BUF->len[1]);
  
  UIP_STAT(++uip_stat.ip.sent);
    404e:	80 91 d8 05 	lds	r24, 0x05D8
    4052:	90 91 d9 05 	lds	r25, 0x05D9
    4056:	01 96       	adiw	r24, 0x01	; 1
    4058:	90 93 d9 05 	sts	0x05D9, r25
    405c:	80 93 d8 05 	sts	0x05D8, r24
    4060:	04 c0       	rjmp	.+8      	; 0x406a <uip_process+0xe3c>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;
 drop:
  uip_len = 0;
    4062:	10 92 66 04 	sts	0x0466, r1
    4066:	10 92 65 04 	sts	0x0465, r1
  uip_flags = 0;
    406a:	10 92 6d 04 	sts	0x046D, r1
  return;
}
    406e:	df 91       	pop	r29
    4070:	cf 91       	pop	r28
    4072:	1f 91       	pop	r17
    4074:	0f 91       	pop	r16
    4076:	08 95       	ret

00004078 <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    4078:	df 92       	push	r13
    407a:	ef 92       	push	r14
    407c:	ff 92       	push	r15
    407e:	0f 93       	push	r16
    4080:	1f 93       	push	r17
    4082:	cf 93       	push	r28
    4084:	df 93       	push	r29
    4086:	dc 01       	movw	r26, r24
    4088:	06 2f       	mov	r16, r22
    408a:	d7 2e       	mov	r13, r23
  register struct arp_entry *tabptr=0;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    408c:	10 92 ef 03 	sts	0x03EF, r1
    4090:	e0 e0       	ldi	r30, 0x00	; 0
    4092:	f0 e0       	ldi	r31, 0x00	; 0
    4094:	60 e0       	ldi	r22, 0x00	; 0

    tabptr = &arp_table[i];
    4096:	1b e0       	ldi	r17, 0x0B	; 11
    4098:	2b c0       	rjmp	.+86     	; 0x40f0 <uip_arp_update+0x78>
    409a:	61 9f       	mul	r22, r17
    409c:	f0 01       	movw	r30, r0
    409e:	11 24       	eor	r1, r1
    40a0:	e1 54       	subi	r30, 0x41	; 65
    40a2:	fc 4f       	sbci	r31, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(tabptr->ipaddr[0] != 0 &&
    40a4:	40 81       	ld	r20, Z
    40a6:	51 81       	ldd	r21, Z+1	; 0x01
    40a8:	41 15       	cp	r20, r1
    40aa:	51 05       	cpc	r21, r1
    40ac:	01 f1       	breq	.+64     	; 0x40ee <uip_arp_update+0x76>
    40ae:	22 81       	ldd	r18, Z+2	; 0x02
    40b0:	33 81       	ldd	r19, Z+3	; 0x03
    40b2:	21 15       	cp	r18, r1
    40b4:	31 05       	cpc	r19, r1
    40b6:	d9 f0       	breq	.+54     	; 0x40ee <uip_arp_update+0x76>
       tabptr->ipaddr[1] != 0) {

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(ipaddr[0] == tabptr->ipaddr[0] &&
    40b8:	8d 91       	ld	r24, X+
    40ba:	9c 91       	ld	r25, X
    40bc:	11 97       	sbiw	r26, 0x01	; 1
    40be:	84 17       	cp	r24, r20
    40c0:	95 07       	cpc	r25, r21
    40c2:	a9 f4       	brne	.+42     	; 0x40ee <uip_arp_update+0x76>
    40c4:	12 96       	adiw	r26, 0x02	; 2
    40c6:	8d 91       	ld	r24, X+
    40c8:	9c 91       	ld	r25, X
    40ca:	13 97       	sbiw	r26, 0x03	; 3
    40cc:	82 17       	cp	r24, r18
    40ce:	93 07       	cpc	r25, r19
    40d0:	71 f4       	brne	.+28     	; 0x40ee <uip_arp_update+0x76>
    40d2:	60 93 ef 03 	sts	0x03EF, r22
	 ipaddr[1] == tabptr->ipaddr[1]) {
	 
	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    40d6:	ef 01       	movw	r28, r30
    40d8:	24 96       	adiw	r28, 0x04	; 4
    40da:	80 2f       	mov	r24, r16
    40dc:	9d 2d       	mov	r25, r13
    40de:	9c 01       	movw	r18, r24
    40e0:	d9 01       	movw	r26, r18
    40e2:	86 e0       	ldi	r24, 0x06	; 6
    40e4:	0d 90       	ld	r0, X+
    40e6:	09 92       	st	Y+, r0
    40e8:	81 50       	subi	r24, 0x01	; 1
    40ea:	e1 f7       	brne	.-8      	; 0x40e4 <uip_arp_update+0x6c>
    40ec:	67 c0       	rjmp	.+206    	; 0x41bc <uip_arp_update+0x144>
	tabptr->time = arptime;

	return;
    40ee:	6f 5f       	subi	r22, 0xFF	; 255
{
  register struct arp_entry *tabptr=0;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    40f0:	64 30       	cpi	r22, 0x04	; 4
    40f2:	98 f2       	brcs	.-90     	; 0x409a <uip_arp_update+0x22>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    40f4:	10 92 ef 03 	sts	0x03EF, r1
    40f8:	20 e0       	ldi	r18, 0x00	; 0
    tabptr = &arp_table[i];
    40fa:	3b e0       	ldi	r19, 0x0B	; 11
    40fc:	11 c0       	rjmp	.+34     	; 0x4120 <uip_arp_update+0xa8>
    40fe:	23 9f       	mul	r18, r19
    4100:	f0 01       	movw	r30, r0
    4102:	11 24       	eor	r1, r1
    4104:	e1 54       	subi	r30, 0x41	; 65
    4106:	fc 4f       	sbci	r31, 0xFC	; 252
    if(tabptr->ipaddr[0] == 0 &&
    4108:	80 81       	ld	r24, Z
    410a:	91 81       	ldd	r25, Z+1	; 0x01
    410c:	89 2b       	or	r24, r25
    410e:	39 f4       	brne	.+14     	; 0x411e <uip_arp_update+0xa6>
    4110:	82 81       	ldd	r24, Z+2	; 0x02
    4112:	93 81       	ldd	r25, Z+3	; 0x03
    4114:	89 2b       	or	r24, r25
    4116:	19 f4       	brne	.+6      	; 0x411e <uip_arp_update+0xa6>
    4118:	20 93 ef 03 	sts	0x03EF, r18
    411c:	3c c0       	rjmp	.+120    	; 0x4196 <uip_arp_update+0x11e>
    411e:	2f 5f       	subi	r18, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4120:	24 30       	cpi	r18, 0x04	; 4
    4122:	68 f3       	brcs	.-38     	; 0x40fe <uip_arp_update+0x86>
    4124:	20 93 ef 03 	sts	0x03EF, r18
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    4128:	24 30       	cpi	r18, 0x04	; 4
    412a:	a9 f5       	brne	.+106    	; 0x4196 <uip_arp_update+0x11e>
    tmpage = 0;
    412c:	10 92 f2 03 	sts	0x03F2, r1
    c = 0;
    4130:	10 92 f0 03 	sts	0x03F0, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    4134:	10 91 f1 03 	lds	r17, 0x03F1
    4138:	c1 2f       	mov	r28, r17
    413a:	d0 e0       	ldi	r29, 0x00	; 0
    413c:	60 e0       	ldi	r22, 0x00	; 0
    413e:	70 e0       	ldi	r23, 0x00	; 0
    4140:	40 e0       	ldi	r20, 0x00	; 0
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4142:	8b e0       	ldi	r24, 0x0B	; 11
    4144:	e8 2e       	mov	r14, r24
    4146:	f1 2c       	mov	r15, r1
    4148:	18 c0       	rjmp	.+48     	; 0x417a <uip_arp_update+0x102>
    414a:	84 2f       	mov	r24, r20
    414c:	90 e0       	ldi	r25, 0x00	; 0
    414e:	8e 9d       	mul	r24, r14
    4150:	f0 01       	movw	r30, r0
    4152:	8f 9d       	mul	r24, r15
    4154:	f0 0d       	add	r31, r0
    4156:	9e 9d       	mul	r25, r14
    4158:	f0 0d       	add	r31, r0
    415a:	11 24       	eor	r1, r1
    415c:	e1 54       	subi	r30, 0x41	; 65
    415e:	fc 4f       	sbci	r31, 0xFC	; 252
    4160:	52 85       	ldd	r21, Z+10	; 0x0a
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    4162:	9e 01       	movw	r18, r28
    4164:	25 1b       	sub	r18, r21
    4166:	31 09       	sbc	r19, r1
    4168:	87 2f       	mov	r24, r23
    416a:	90 e0       	ldi	r25, 0x00	; 0
    416c:	82 17       	cp	r24, r18
    416e:	93 07       	cpc	r25, r19
    4170:	1c f4       	brge	.+6      	; 0x4178 <uip_arp_update+0x100>
	tmpage = arptime - tabptr->time;
    4172:	71 2f       	mov	r23, r17
    4174:	75 1b       	sub	r23, r21
    4176:	64 2f       	mov	r22, r20
    4178:	4f 5f       	subi	r20, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    417a:	44 30       	cpi	r20, 0x04	; 4
    417c:	30 f3       	brcs	.-52     	; 0x414a <uip_arp_update+0xd2>
    417e:	60 93 f0 03 	sts	0x03F0, r22
    4182:	70 93 f2 03 	sts	0x03F2, r23
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    4186:	60 93 ef 03 	sts	0x03EF, r22
    tabptr = &arp_table[i];
    418a:	8b e0       	ldi	r24, 0x0B	; 11
    418c:	68 9f       	mul	r22, r24
    418e:	f0 01       	movw	r30, r0
    4190:	11 24       	eor	r1, r1
    4192:	e1 54       	subi	r30, 0x41	; 65
    4194:	fc 4f       	sbci	r31, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  memcpy(tabptr->ipaddr, ipaddr, 4);
    4196:	8d 91       	ld	r24, X+
    4198:	9d 91       	ld	r25, X+
    419a:	0d 90       	ld	r0, X+
    419c:	bc 91       	ld	r27, X
    419e:	a0 2d       	mov	r26, r0
    41a0:	ef 01       	movw	r28, r30
    41a2:	89 93       	st	Y+, r24
    41a4:	99 93       	st	Y+, r25
    41a6:	a9 93       	st	Y+, r26
    41a8:	b9 93       	st	Y+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    41aa:	20 2f       	mov	r18, r16
    41ac:	3d 2d       	mov	r19, r13
    41ae:	c9 01       	movw	r24, r18
    41b0:	dc 01       	movw	r26, r24
    41b2:	86 e0       	ldi	r24, 0x06	; 6
    41b4:	0d 90       	ld	r0, X+
    41b6:	09 92       	st	Y+, r0
    41b8:	81 50       	subi	r24, 0x01	; 1
    41ba:	e1 f7       	brne	.-8      	; 0x41b4 <uip_arp_update+0x13c>
  tabptr->time = arptime;
    41bc:	80 91 f1 03 	lds	r24, 0x03F1
    41c0:	82 87       	std	Z+10, r24	; 0x0a
}
    41c2:	df 91       	pop	r29
    41c4:	cf 91       	pop	r28
    41c6:	1f 91       	pop	r17
    41c8:	0f 91       	pop	r16
    41ca:	ff 90       	pop	r15
    41cc:	ef 90       	pop	r14
    41ce:	df 90       	pop	r13
    41d0:	08 95       	ret

000041d2 <uip_arp_ipin>:
/*-----------------------------------------------------------------------------------*/
#if 1
void
uip_arp_ipin(void)
{
  uip_len -= sizeof(struct uip_eth_hdr);
    41d2:	80 91 65 04 	lds	r24, 0x0465
    41d6:	90 91 66 04 	lds	r25, 0x0466
    41da:	0e 97       	sbiw	r24, 0x0e	; 14
    41dc:	90 93 66 04 	sts	0x0466, r25
    41e0:	80 93 65 04 	sts	0x0465, r24
	
  /* Only insert/update an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  if((IPBUF->srcipaddr[0] & uip_netmask[0]) !=
    41e4:	80 91 04 06 	lds	r24, 0x0604
    41e8:	90 91 05 06 	lds	r25, 0x0605
    41ec:	20 91 22 06 	lds	r18, 0x0622
    41f0:	30 91 23 06 	lds	r19, 0x0623
    41f4:	82 27       	eor	r24, r18
    41f6:	93 27       	eor	r25, r19
    41f8:	20 91 00 06 	lds	r18, 0x0600
    41fc:	30 91 01 06 	lds	r19, 0x0601
    4200:	82 23       	and	r24, r18
    4202:	93 23       	and	r25, r19
    4204:	89 2b       	or	r24, r25
    4206:	c1 f4       	brne	.+48     	; 0x4238 <uip_arp_ipin+0x66>
     (uip_hostaddr[0] & uip_netmask[0])) {
    return;
  }
  if((IPBUF->srcipaddr[1] & uip_netmask[1]) !=
    4208:	80 91 06 06 	lds	r24, 0x0606
    420c:	90 91 07 06 	lds	r25, 0x0607
    4210:	20 91 24 06 	lds	r18, 0x0624
    4214:	30 91 25 06 	lds	r19, 0x0625
    4218:	82 27       	eor	r24, r18
    421a:	93 27       	eor	r25, r19
    421c:	20 91 02 06 	lds	r18, 0x0602
    4220:	30 91 03 06 	lds	r19, 0x0603
    4224:	82 23       	and	r24, r18
    4226:	93 23       	and	r25, r19
    4228:	89 2b       	or	r24, r25
    422a:	31 f4       	brne	.+12     	; 0x4238 <uip_arp_ipin+0x66>
     (uip_hostaddr[1] & uip_netmask[1])) {
    return;
  }
  uip_arp_update(IPBUF->srcipaddr, &(IPBUF->ethhdr.src));
    422c:	82 e2       	ldi	r24, 0x22	; 34
    422e:	96 e0       	ldi	r25, 0x06	; 6
    4230:	6e e0       	ldi	r22, 0x0E	; 14
    4232:	76 e0       	ldi	r23, 0x06	; 6
    4234:	0e 94 3c 20 	call	0x4078	; 0x4078 <uip_arp_update>
    4238:	08 95       	ret

0000423a <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    423a:	cf 93       	push	r28
    423c:	df 93       	push	r29
  
  if(uip_len < sizeof(struct arp_hdr)) {
    423e:	80 91 65 04 	lds	r24, 0x0465
    4242:	90 91 66 04 	lds	r25, 0x0466
    4246:	8a 97       	sbiw	r24, 0x2a	; 42
    4248:	28 f4       	brcc	.+10     	; 0x4254 <uip_arp_arpin+0x1a>
    uip_len = 0;
    424a:	10 92 66 04 	sts	0x0466, r1
    424e:	10 92 65 04 	sts	0x0465, r1
    4252:	a6 c0       	rjmp	.+332    	; 0x43a0 <uip_arp_arpin+0x166>
    return;
  }
  uip_len = 0;
    4254:	10 92 66 04 	sts	0x0466, r1
    4258:	10 92 65 04 	sts	0x0465, r1
  
  switch(BUF->opcode) {
    425c:	c8 e0       	ldi	r28, 0x08	; 8
    425e:	d6 e0       	ldi	r29, 0x06	; 6
    4260:	80 91 1c 06 	lds	r24, 0x061C
    4264:	90 91 1d 06 	lds	r25, 0x061D
    4268:	21 e0       	ldi	r18, 0x01	; 1
    426a:	80 30       	cpi	r24, 0x00	; 0
    426c:	92 07       	cpc	r25, r18
    426e:	29 f0       	breq	.+10     	; 0x427a <uip_arp_arpin+0x40>
    4270:	80 50       	subi	r24, 0x00	; 0
    4272:	92 40       	sbci	r25, 0x02	; 2
    4274:	09 f0       	breq	.+2      	; 0x4278 <uip_arp_arpin+0x3e>
    4276:	94 c0       	rjmp	.+296    	; 0x43a0 <uip_arp_arpin+0x166>
    4278:	76 c0       	rjmp	.+236    	; 0x4366 <uip_arp_arpin+0x12c>
  case HTONS(ARP_REQUEST):
    /* ARP request. If it asked for our address, we send out a
       reply. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    427a:	20 91 2e 06 	lds	r18, 0x062E
    427e:	30 91 2f 06 	lds	r19, 0x062F
    4282:	80 91 04 06 	lds	r24, 0x0604
    4286:	90 91 05 06 	lds	r25, 0x0605
    428a:	28 17       	cp	r18, r24
    428c:	39 07       	cpc	r19, r25
    428e:	09 f0       	breq	.+2      	; 0x4292 <uip_arp_arpin+0x58>
    4290:	87 c0       	rjmp	.+270    	; 0x43a0 <uip_arp_arpin+0x166>
    4292:	20 91 30 06 	lds	r18, 0x0630
    4296:	30 91 31 06 	lds	r19, 0x0631
    429a:	80 91 06 06 	lds	r24, 0x0606
    429e:	90 91 07 06 	lds	r25, 0x0607
    42a2:	28 17       	cp	r18, r24
    42a4:	39 07       	cpc	r19, r25
    42a6:	09 f0       	breq	.+2      	; 0x42aa <uip_arp_arpin+0x70>
    42a8:	7b c0       	rjmp	.+246    	; 0x43a0 <uip_arp_arpin+0x166>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    42aa:	ce 01       	movw	r24, r28
    42ac:	4c 96       	adiw	r24, 0x1c	; 28
    42ae:	be 01       	movw	r22, r28
    42b0:	6a 5e       	subi	r22, 0xEA	; 234
    42b2:	7f 4f       	sbci	r23, 0xFF	; 255
    42b4:	0e 94 3c 20 	call	0x4078	; 0x4078 <uip_arp_update>
      
      /* The reply opcode is 2. */
      BUF->opcode = HTONS(2);
    42b8:	80 e0       	ldi	r24, 0x00	; 0
    42ba:	92 e0       	ldi	r25, 0x02	; 2
    42bc:	90 93 1d 06 	sts	0x061D, r25
    42c0:	80 93 1c 06 	sts	0x061C, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    42c4:	de 01       	movw	r26, r28
    42c6:	90 96       	adiw	r26, 0x20	; 32
    42c8:	fe 01       	movw	r30, r28
    42ca:	76 96       	adiw	r30, 0x16	; 22
    42cc:	86 e0       	ldi	r24, 0x06	; 6
    42ce:	01 90       	ld	r0, Z+
    42d0:	0d 92       	st	X+, r0
    42d2:	81 50       	subi	r24, 0x01	; 1
    42d4:	e1 f7       	brne	.-8      	; 0x42ce <uip_arp_arpin+0x94>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    42d6:	ae e1       	ldi	r26, 0x1E	; 30
    42d8:	b6 e0       	ldi	r27, 0x06	; 6
    42da:	ed ea       	ldi	r30, 0xAD	; 173
    42dc:	f3 e0       	ldi	r31, 0x03	; 3
    42de:	86 e0       	ldi	r24, 0x06	; 6
    42e0:	01 90       	ld	r0, Z+
    42e2:	0d 92       	st	X+, r0
    42e4:	81 50       	subi	r24, 0x01	; 1
    42e6:	e1 f7       	brne	.-8      	; 0x42e0 <uip_arp_arpin+0xa6>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    42e8:	ae e0       	ldi	r26, 0x0E	; 14
    42ea:	b6 e0       	ldi	r27, 0x06	; 6
    42ec:	ed ea       	ldi	r30, 0xAD	; 173
    42ee:	f3 e0       	ldi	r31, 0x03	; 3
    42f0:	86 e0       	ldi	r24, 0x06	; 6
    42f2:	01 90       	ld	r0, Z+
    42f4:	0d 92       	st	X+, r0
    42f6:	81 50       	subi	r24, 0x01	; 1
    42f8:	e1 f7       	brne	.-8      	; 0x42f2 <uip_arp_arpin+0xb8>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    42fa:	e8 e0       	ldi	r30, 0x08	; 8
    42fc:	f6 e0       	ldi	r31, 0x06	; 6
    42fe:	df 01       	movw	r26, r30
    4300:	90 96       	adiw	r26, 0x20	; 32
    4302:	86 e0       	ldi	r24, 0x06	; 6
    4304:	0d 90       	ld	r0, X+
    4306:	01 92       	st	Z+, r0
    4308:	81 50       	subi	r24, 0x01	; 1
    430a:	e1 f7       	brne	.-8      	; 0x4304 <uip_arp_arpin+0xca>
      
      BUF->dipaddr[0] = BUF->sipaddr[0];
    430c:	80 91 24 06 	lds	r24, 0x0624
    4310:	90 91 25 06 	lds	r25, 0x0625
    4314:	90 93 2f 06 	sts	0x062F, r25
    4318:	80 93 2e 06 	sts	0x062E, r24
      BUF->dipaddr[1] = BUF->sipaddr[1];
    431c:	80 91 26 06 	lds	r24, 0x0626
    4320:	90 91 27 06 	lds	r25, 0x0627
    4324:	90 93 31 06 	sts	0x0631, r25
    4328:	80 93 30 06 	sts	0x0630, r24
      BUF->sipaddr[0] = uip_hostaddr[0];
    432c:	80 91 04 06 	lds	r24, 0x0604
    4330:	90 91 05 06 	lds	r25, 0x0605
    4334:	90 93 25 06 	sts	0x0625, r25
    4338:	80 93 24 06 	sts	0x0624, r24
      BUF->sipaddr[1] = uip_hostaddr[1];
    433c:	80 91 06 06 	lds	r24, 0x0606
    4340:	90 91 07 06 	lds	r25, 0x0607
    4344:	90 93 27 06 	sts	0x0627, r25
    4348:	80 93 26 06 	sts	0x0626, r24

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    434c:	88 e0       	ldi	r24, 0x08	; 8
    434e:	96 e0       	ldi	r25, 0x06	; 6
    4350:	90 93 15 06 	sts	0x0615, r25
    4354:	80 93 14 06 	sts	0x0614, r24
      uip_len = sizeof(struct arp_hdr);
    4358:	8a e2       	ldi	r24, 0x2A	; 42
    435a:	90 e0       	ldi	r25, 0x00	; 0
    435c:	90 93 66 04 	sts	0x0466, r25
    4360:	80 93 65 04 	sts	0x0465, r24
    4364:	1d c0       	rjmp	.+58     	; 0x43a0 <uip_arp_arpin+0x166>
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    4366:	20 91 2e 06 	lds	r18, 0x062E
    436a:	30 91 2f 06 	lds	r19, 0x062F
    436e:	80 91 04 06 	lds	r24, 0x0604
    4372:	90 91 05 06 	lds	r25, 0x0605
    4376:	28 17       	cp	r18, r24
    4378:	39 07       	cpc	r19, r25
    437a:	91 f4       	brne	.+36     	; 0x43a0 <uip_arp_arpin+0x166>
    437c:	20 91 30 06 	lds	r18, 0x0630
    4380:	30 91 31 06 	lds	r19, 0x0631
    4384:	80 91 06 06 	lds	r24, 0x0606
    4388:	90 91 07 06 	lds	r25, 0x0607
    438c:	28 17       	cp	r18, r24
    438e:	39 07       	cpc	r19, r25
    4390:	39 f4       	brne	.+14     	; 0x43a0 <uip_arp_arpin+0x166>
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    4392:	ce 01       	movw	r24, r28
    4394:	4c 96       	adiw	r24, 0x1c	; 28
    4396:	be 01       	movw	r22, r28
    4398:	6a 5e       	subi	r22, 0xEA	; 234
    439a:	7f 4f       	sbci	r23, 0xFF	; 255
    439c:	0e 94 3c 20 	call	0x4078	; 0x4078 <uip_arp_update>
    }
    break;
  }

  return;
}
    43a0:	df 91       	pop	r29
    43a2:	cf 91       	pop	r28
    43a4:	08 95       	ret

000043a6 <uip_arp_out>:

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
    43a6:	40 91 26 06 	lds	r20, 0x0626
    43aa:	50 91 27 06 	lds	r21, 0x0627
    43ae:	80 91 0b 02 	lds	r24, 0x020B
    43b2:	90 91 0c 02 	lds	r25, 0x020C
    43b6:	48 17       	cp	r20, r24
    43b8:	59 07       	cpc	r21, r25
    43ba:	89 f4       	brne	.+34     	; 0x43de <uip_arp_out+0x38>
    43bc:	80 91 28 06 	lds	r24, 0x0628
    43c0:	90 91 29 06 	lds	r25, 0x0629
    43c4:	8f 5f       	subi	r24, 0xFF	; 255
    43c6:	9f 4f       	sbci	r25, 0xFF	; 255
    43c8:	51 f4       	brne	.+20     	; 0x43de <uip_arp_out+0x38>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    43ca:	a8 e0       	ldi	r26, 0x08	; 8
    43cc:	b6 e0       	ldi	r27, 0x06	; 6
    43ce:	ef e0       	ldi	r30, 0x0F	; 15
    43d0:	f2 e0       	ldi	r31, 0x02	; 2
    43d2:	86 e0       	ldi	r24, 0x06	; 6
    43d4:	01 90       	ld	r0, Z+
    43d6:	0d 92       	st	X+, r0
    43d8:	81 50       	subi	r24, 0x01	; 1
    43da:	e1 f7       	brne	.-8      	; 0x43d4 <uip_arp_out+0x2e>
    43dc:	cf c0       	rjmp	.+414    	; 0x457c <uip_arp_out+0x1d6>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {
    43de:	80 91 04 06 	lds	r24, 0x0604
    43e2:	90 91 05 06 	lds	r25, 0x0605
    43e6:	84 27       	eor	r24, r20
    43e8:	95 27       	eor	r25, r21
    43ea:	20 91 00 06 	lds	r18, 0x0600
    43ee:	30 91 01 06 	lds	r19, 0x0601
    43f2:	82 23       	and	r24, r18
    43f4:	93 23       	and	r25, r19
    43f6:	89 2b       	or	r24, r25
    43f8:	91 f4       	brne	.+36     	; 0x441e <uip_arp_out+0x78>
    43fa:	60 91 28 06 	lds	r22, 0x0628
    43fe:	70 91 29 06 	lds	r23, 0x0629
    4402:	80 91 06 06 	lds	r24, 0x0606
    4406:	90 91 07 06 	lds	r25, 0x0607
    440a:	86 27       	eor	r24, r22
    440c:	97 27       	eor	r25, r23
    440e:	20 91 02 06 	lds	r18, 0x0602
    4412:	30 91 03 06 	lds	r19, 0x0603
    4416:	82 23       	and	r24, r18
    4418:	93 23       	and	r25, r19
    441a:	89 2b       	or	r24, r25
    441c:	89 f0       	breq	.+34     	; 0x4440 <uip_arp_out+0x9a>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(ipaddr, uip_draddr);
    441e:	80 91 d0 05 	lds	r24, 0x05D0
    4422:	90 91 d1 05 	lds	r25, 0x05D1
    4426:	90 93 ec 03 	sts	0x03EC, r25
    442a:	80 93 eb 03 	sts	0x03EB, r24
    442e:	80 91 d2 05 	lds	r24, 0x05D2
    4432:	90 91 d3 05 	lds	r25, 0x05D3
    4436:	90 93 ee 03 	sts	0x03EE, r25
    443a:	80 93 ed 03 	sts	0x03ED, r24
    443e:	08 c0       	rjmp	.+16     	; 0x4450 <uip_arp_out+0xaa>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    4440:	50 93 ec 03 	sts	0x03EC, r21
    4444:	40 93 eb 03 	sts	0x03EB, r20
    4448:	70 93 ee 03 	sts	0x03EE, r23
    444c:	60 93 ed 03 	sts	0x03ED, r22
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4450:	10 92 ef 03 	sts	0x03EF, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    4454:	60 91 eb 03 	lds	r22, 0x03EB
    4458:	70 91 ec 03 	lds	r23, 0x03EC
    445c:	40 91 ed 03 	lds	r20, 0x03ED
    4460:	50 91 ee 03 	lds	r21, 0x03EE
    4464:	e0 e0       	ldi	r30, 0x00	; 0
    4466:	f0 e0       	ldi	r31, 0x00	; 0
    4468:	20 e0       	ldi	r18, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    446a:	3b e0       	ldi	r19, 0x0B	; 11
    446c:	13 c0       	rjmp	.+38     	; 0x4494 <uip_arp_out+0xee>
    446e:	23 9f       	mul	r18, r19
    4470:	f0 01       	movw	r30, r0
    4472:	11 24       	eor	r1, r1
    4474:	e1 54       	subi	r30, 0x41	; 65
    4476:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    4478:	80 81       	ld	r24, Z
    447a:	91 81       	ldd	r25, Z+1	; 0x01
    447c:	68 17       	cp	r22, r24
    447e:	79 07       	cpc	r23, r25
    4480:	41 f4       	brne	.+16     	; 0x4492 <uip_arp_out+0xec>
    4482:	82 81       	ldd	r24, Z+2	; 0x02
    4484:	93 81       	ldd	r25, Z+3	; 0x03
    4486:	48 17       	cp	r20, r24
    4488:	59 07       	cpc	r21, r25
    448a:	19 f4       	brne	.+6      	; 0x4492 <uip_arp_out+0xec>
    448c:	20 93 ef 03 	sts	0x03EF, r18
    4490:	6d c0       	rjmp	.+218    	; 0x456c <uip_arp_out+0x1c6>
    4492:	2f 5f       	subi	r18, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4494:	24 30       	cpi	r18, 0x04	; 4
    4496:	58 f3       	brcs	.-42     	; 0x446e <uip_arp_out+0xc8>
    4498:	20 93 ef 03 	sts	0x03EF, r18
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    449c:	24 30       	cpi	r18, 0x04	; 4
    449e:	09 f0       	breq	.+2      	; 0x44a2 <uip_arp_out+0xfc>
    44a0:	65 c0       	rjmp	.+202    	; 0x456c <uip_arp_out+0x1c6>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    44a2:	88 e0       	ldi	r24, 0x08	; 8
    44a4:	96 e0       	ldi	r25, 0x06	; 6
    44a6:	6f ef       	ldi	r22, 0xFF	; 255
    44a8:	70 e0       	ldi	r23, 0x00	; 0
    44aa:	46 e0       	ldi	r20, 0x06	; 6
    44ac:	50 e0       	ldi	r21, 0x00	; 0
    44ae:	0e 94 41 2f 	call	0x5e82	; 0x5e82 <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    44b2:	e8 e2       	ldi	r30, 0x28	; 40
    44b4:	f6 e0       	ldi	r31, 0x06	; 6
    44b6:	86 e0       	ldi	r24, 0x06	; 6
    44b8:	df 01       	movw	r26, r30
    44ba:	1d 92       	st	X+, r1
    44bc:	8a 95       	dec	r24
    44be:	e9 f7       	brne	.-6      	; 0x44ba <uip_arp_out+0x114>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    44c0:	7a 97       	sbiw	r30, 0x1a	; 26
    44c2:	ad ea       	ldi	r26, 0xAD	; 173
    44c4:	b3 e0       	ldi	r27, 0x03	; 3
    44c6:	86 e0       	ldi	r24, 0x06	; 6
    44c8:	0d 90       	ld	r0, X+
    44ca:	01 92       	st	Z+, r0
    44cc:	81 50       	subi	r24, 0x01	; 1
    44ce:	e1 f7       	brne	.-8      	; 0x44c8 <uip_arp_out+0x122>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    44d0:	ae e1       	ldi	r26, 0x1E	; 30
    44d2:	b6 e0       	ldi	r27, 0x06	; 6
    44d4:	ed ea       	ldi	r30, 0xAD	; 173
    44d6:	f3 e0       	ldi	r31, 0x03	; 3
    44d8:	86 e0       	ldi	r24, 0x06	; 6
    44da:	01 90       	ld	r0, Z+
    44dc:	0d 92       	st	X+, r0
    44de:	81 50       	subi	r24, 0x01	; 1
    44e0:	e1 f7       	brne	.-8      	; 0x44da <uip_arp_out+0x134>
    
      uip_ipaddr_copy(BUF->dipaddr, ipaddr);
    44e2:	80 91 eb 03 	lds	r24, 0x03EB
    44e6:	90 91 ec 03 	lds	r25, 0x03EC
    44ea:	90 93 2f 06 	sts	0x062F, r25
    44ee:	80 93 2e 06 	sts	0x062E, r24
    44f2:	80 91 ed 03 	lds	r24, 0x03ED
    44f6:	90 91 ee 03 	lds	r25, 0x03EE
    44fa:	90 93 31 06 	sts	0x0631, r25
    44fe:	80 93 30 06 	sts	0x0630, r24
      uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);
    4502:	80 91 04 06 	lds	r24, 0x0604
    4506:	90 91 05 06 	lds	r25, 0x0605
    450a:	90 93 25 06 	sts	0x0625, r25
    450e:	80 93 24 06 	sts	0x0624, r24
    4512:	80 91 06 06 	lds	r24, 0x0606
    4516:	90 91 07 06 	lds	r25, 0x0607
    451a:	90 93 27 06 	sts	0x0627, r25
    451e:	80 93 26 06 	sts	0x0626, r24
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    4522:	80 e0       	ldi	r24, 0x00	; 0
    4524:	91 e0       	ldi	r25, 0x01	; 1
    4526:	90 93 1d 06 	sts	0x061D, r25
    452a:	80 93 1c 06 	sts	0x061C, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    452e:	90 93 17 06 	sts	0x0617, r25
    4532:	80 93 16 06 	sts	0x0616, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    4536:	88 e0       	ldi	r24, 0x08	; 8
    4538:	90 e0       	ldi	r25, 0x00	; 0
    453a:	90 93 19 06 	sts	0x0619, r25
    453e:	80 93 18 06 	sts	0x0618, r24
      BUF->hwlen = 6;
    4542:	86 e0       	ldi	r24, 0x06	; 6
    4544:	80 93 1a 06 	sts	0x061A, r24
      BUF->protolen = 4;
    4548:	84 e0       	ldi	r24, 0x04	; 4
    454a:	80 93 1b 06 	sts	0x061B, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    454e:	88 e0       	ldi	r24, 0x08	; 8
    4550:	96 e0       	ldi	r25, 0x06	; 6
    4552:	90 93 15 06 	sts	0x0615, r25
    4556:	80 93 14 06 	sts	0x0614, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    455a:	8e e3       	ldi	r24, 0x3E	; 62
    455c:	96 e0       	ldi	r25, 0x06	; 6
    455e:	90 93 6f 04 	sts	0x046F, r25
    4562:	80 93 6e 04 	sts	0x046E, r24
    
      uip_len = sizeof(struct arp_hdr);
    4566:	8a e2       	ldi	r24, 0x2A	; 42
    4568:	90 e0       	ldi	r25, 0x00	; 0
    456a:	1c c0       	rjmp	.+56     	; 0x45a4 <uip_arp_out+0x1fe>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    456c:	a8 e0       	ldi	r26, 0x08	; 8
    456e:	b6 e0       	ldi	r27, 0x06	; 6
    4570:	34 96       	adiw	r30, 0x04	; 4
    4572:	86 e0       	ldi	r24, 0x06	; 6
    4574:	01 90       	ld	r0, Z+
    4576:	0d 92       	st	X+, r0
    4578:	81 50       	subi	r24, 0x01	; 1
    457a:	e1 f7       	brne	.-8      	; 0x4574 <uip_arp_out+0x1ce>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    457c:	ae e0       	ldi	r26, 0x0E	; 14
    457e:	b6 e0       	ldi	r27, 0x06	; 6
    4580:	ed ea       	ldi	r30, 0xAD	; 173
    4582:	f3 e0       	ldi	r31, 0x03	; 3
    4584:	86 e0       	ldi	r24, 0x06	; 6
    4586:	01 90       	ld	r0, Z+
    4588:	0d 92       	st	X+, r0
    458a:	81 50       	subi	r24, 0x01	; 1
    458c:	e1 f7       	brne	.-8      	; 0x4586 <uip_arp_out+0x1e0>
  
  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    458e:	88 e0       	ldi	r24, 0x08	; 8
    4590:	90 e0       	ldi	r25, 0x00	; 0
    4592:	90 93 15 06 	sts	0x0615, r25
    4596:	80 93 14 06 	sts	0x0614, r24

  uip_len += sizeof(struct uip_eth_hdr);
    459a:	80 91 65 04 	lds	r24, 0x0465
    459e:	90 91 66 04 	lds	r25, 0x0466
    45a2:	0e 96       	adiw	r24, 0x0e	; 14
    45a4:	90 93 66 04 	sts	0x0466, r25
    45a8:	80 93 65 04 	sts	0x0465, r24
    45ac:	08 95       	ret

000045ae <uip_arp_timer>:
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
    45ae:	80 91 f1 03 	lds	r24, 0x03F1
    45b2:	8f 5f       	subi	r24, 0xFF	; 255
    45b4:	80 93 f1 03 	sts	0x03F1, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    45b8:	10 92 ef 03 	sts	0x03EF, r1
    tabptr = &arp_table[i];
    45bc:	4b e0       	ldi	r20, 0x0B	; 11
    45be:	1f c0       	rjmp	.+62     	; 0x45fe <uip_arp_timer+0x50>
    45c0:	24 9f       	mul	r18, r20
    45c2:	f0 01       	movw	r30, r0
    45c4:	11 24       	eor	r1, r1
    45c6:	e1 54       	subi	r30, 0x41	; 65
    45c8:	fc 4f       	sbci	r31, 0xFC	; 252
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
    45ca:	82 81       	ldd	r24, Z+2	; 0x02
    45cc:	93 81       	ldd	r25, Z+3	; 0x03
    45ce:	20 81       	ld	r18, Z
    45d0:	31 81       	ldd	r19, Z+1	; 0x01
    45d2:	82 2b       	or	r24, r18
    45d4:	93 2b       	or	r25, r19
    45d6:	89 2b       	or	r24, r25
    45d8:	69 f0       	breq	.+26     	; 0x45f4 <uip_arp_timer+0x46>
    45da:	80 91 f1 03 	lds	r24, 0x03F1
    45de:	90 e0       	ldi	r25, 0x00	; 0
    45e0:	22 85       	ldd	r18, Z+10	; 0x0a
    45e2:	82 1b       	sub	r24, r18
    45e4:	91 09       	sbc	r25, r1
    45e6:	88 37       	cpi	r24, 0x78	; 120
    45e8:	91 05       	cpc	r25, r1
    45ea:	24 f0       	brlt	.+8      	; 0x45f4 <uip_arp_timer+0x46>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    45ec:	10 82       	st	Z, r1
    45ee:	11 82       	std	Z+1, r1	; 0x01
    45f0:	12 82       	std	Z+2, r1	; 0x02
    45f2:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    45f4:	80 91 ef 03 	lds	r24, 0x03EF
    45f8:	8f 5f       	subi	r24, 0xFF	; 255
    45fa:	80 93 ef 03 	sts	0x03EF, r24
    45fe:	20 91 ef 03 	lds	r18, 0x03EF
    4602:	24 30       	cpi	r18, 0x04	; 4
    4604:	e8 f2       	brcs	.-70     	; 0x45c0 <uip_arp_timer+0x12>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    }
  }

}
    4606:	08 95       	ret

00004608 <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4608:	10 92 ef 03 	sts	0x03EF, r1
    memset(arp_table[i].ipaddr, 0, 4);
    460c:	9b e0       	ldi	r25, 0x0B	; 11
    460e:	0c c0       	rjmp	.+24     	; 0x4628 <uip_arp_init+0x20>
    4610:	89 9f       	mul	r24, r25
    4612:	f0 01       	movw	r30, r0
    4614:	11 24       	eor	r1, r1
    4616:	e1 54       	subi	r30, 0x41	; 65
    4618:	fc 4f       	sbci	r31, 0xFC	; 252
    461a:	10 82       	st	Z, r1
    461c:	11 82       	std	Z+1, r1	; 0x01
    461e:	12 82       	std	Z+2, r1	; 0x02
    4620:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4622:	8f 5f       	subi	r24, 0xFF	; 255
    4624:	80 93 ef 03 	sts	0x03EF, r24
    4628:	80 91 ef 03 	lds	r24, 0x03EF
    462c:	84 30       	cpi	r24, 0x04	; 4
    462e:	80 f3       	brcs	.-32     	; 0x4610 <uip_arp_init+0x8>
    memset(arp_table[i].ipaddr, 0, 4);
  }
}
    4630:	08 95       	ret

00004632 <uiplib_ipaddrconv>:


/*-----------------------------------------------------------------------------------*/
unsigned char
uiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)
{
    4632:	fc 01       	movw	r30, r24
    4634:	db 01       	movw	r26, r22
    4636:	20 e0       	ldi	r18, 0x00	; 0
    4638:	40 e0       	ldi	r20, 0x00	; 0
      if(c == '.' || c == 0) {
	*ipaddr = tmp;
	++ipaddr;
	tmp = 0;
      } else if(c >= '0' && c <= '9') {
	tmp = (tmp * 10) + (c - '0');
    463a:	5a e0       	ldi	r21, 0x0A	; 10


/*-----------------------------------------------------------------------------------*/
unsigned char
uiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)
{
    463c:	30 e0       	ldi	r19, 0x00	; 0
  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    j = 0;
    do {
      c = *addrstr;
    463e:	80 81       	ld	r24, Z
      ++j;
    4640:	3f 5f       	subi	r19, 0xFF	; 255
      if(j > 4) {
    4642:	35 30       	cpi	r19, 0x05	; 5
    4644:	c9 f0       	breq	.+50     	; 0x4678 <uiplib_ipaddrconv+0x46>
	return 0;
      }
      if(c == '.' || c == 0) {
    4646:	8e 32       	cpi	r24, 0x2E	; 46
    4648:	11 f0       	breq	.+4      	; 0x464e <uiplib_ipaddrconv+0x1c>
    464a:	88 23       	and	r24, r24
    464c:	19 f4       	brne	.+6      	; 0x4654 <uiplib_ipaddrconv+0x22>
	*ipaddr = tmp;
    464e:	2d 93       	st	X+, r18
	++ipaddr;
    4650:	20 e0       	ldi	r18, 0x00	; 0
    4652:	08 c0       	rjmp	.+16     	; 0x4664 <uiplib_ipaddrconv+0x32>
	tmp = 0;
      } else if(c >= '0' && c <= '9') {
    4654:	98 2f       	mov	r25, r24
    4656:	90 53       	subi	r25, 0x30	; 48
    4658:	9a 30       	cpi	r25, 0x0A	; 10
    465a:	70 f4       	brcc	.+28     	; 0x4678 <uiplib_ipaddrconv+0x46>
	tmp = (tmp * 10) + (c - '0');
    465c:	25 9f       	mul	r18, r21
    465e:	20 2d       	mov	r18, r0
    4660:	11 24       	eor	r1, r1
    4662:	29 0f       	add	r18, r25
      } else {
	return 0;
      }
      ++addrstr;
    4664:	31 96       	adiw	r30, 0x01	; 1
    } while(c != '.' && c != 0);
    4666:	8e 32       	cpi	r24, 0x2E	; 46
    4668:	11 f0       	breq	.+4      	; 0x466e <uiplib_ipaddrconv+0x3c>
    466a:	88 23       	and	r24, r24
    466c:	41 f7       	brne	.-48     	; 0x463e <uiplib_ipaddrconv+0xc>
  char c;
  unsigned char i, j;

  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    466e:	4f 5f       	subi	r20, 0xFF	; 255
    4670:	44 30       	cpi	r20, 0x04	; 4
    4672:	21 f7       	brne	.-56     	; 0x463c <uiplib_ipaddrconv+0xa>
    4674:	81 e0       	ldi	r24, 0x01	; 1
    4676:	08 95       	ret
    4678:	80 e0       	ldi	r24, 0x00	; 0
      }
      ++addrstr;
    } while(c != '.' && c != 0);
  }
  return 1;
}
    467a:	08 95       	ret

0000467c <data_acked>:
}

/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
    467c:	fc 01       	movw	r30, r24
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    467e:	84 89       	ldd	r24, Z+20	; 0x14
    4680:	86 30       	cpi	r24, 0x06	; 6
    4682:	49 f5       	brne	.+82     	; 0x46d6 <data_acked+0x5a>
    4684:	80 91 6d 04 	lds	r24, 0x046D
    4688:	80 ff       	sbrs	r24, 0
    468a:	25 c0       	rjmp	.+74     	; 0x46d6 <data_acked+0x5a>
    if(s->sendlen > uip_mss()) {
    468c:	82 85       	ldd	r24, Z+10	; 0x0a
    468e:	93 85       	ldd	r25, Z+11	; 0x0b
    4690:	a0 91 70 04 	lds	r26, 0x0470
    4694:	b0 91 71 04 	lds	r27, 0x0471
    4698:	52 96       	adiw	r26, 0x12	; 18
    469a:	4d 91       	ld	r20, X+
    469c:	5c 91       	ld	r21, X
    469e:	53 97       	sbiw	r26, 0x13	; 19
    46a0:	24 81       	ldd	r18, Z+4	; 0x04
    46a2:	35 81       	ldd	r19, Z+5	; 0x05
    46a4:	48 17       	cp	r20, r24
    46a6:	59 07       	cpc	r21, r25
    46a8:	68 f4       	brcc	.+26     	; 0x46c4 <data_acked+0x48>
      s->sendlen -= uip_mss();
    46aa:	84 1b       	sub	r24, r20
    46ac:	95 0b       	sbc	r25, r21
    46ae:	93 87       	std	Z+11, r25	; 0x0b
    46b0:	82 87       	std	Z+10, r24	; 0x0a
      s->sendptr += uip_mss();
    46b2:	52 96       	adiw	r26, 0x12	; 18
    46b4:	8d 91       	ld	r24, X+
    46b6:	9c 91       	ld	r25, X
    46b8:	53 97       	sbiw	r26, 0x13	; 19
    46ba:	28 0f       	add	r18, r24
    46bc:	39 1f       	adc	r19, r25
    46be:	35 83       	std	Z+5, r19	; 0x05
    46c0:	24 83       	std	Z+4, r18	; 0x04
    46c2:	06 c0       	rjmp	.+12     	; 0x46d0 <data_acked+0x54>
    } else {
      s->sendptr += s->sendlen;
    46c4:	28 0f       	add	r18, r24
    46c6:	39 1f       	adc	r19, r25
    46c8:	35 83       	std	Z+5, r19	; 0x05
    46ca:	24 83       	std	Z+4, r18	; 0x04
      s->sendlen = 0;
    46cc:	13 86       	std	Z+11, r1	; 0x0b
    46ce:	12 86       	std	Z+10, r1	; 0x0a
    }
    s->state = STATE_ACKED;
    46d0:	81 e0       	ldi	r24, 0x01	; 1
    46d2:	84 8b       	std	Z+20, r24	; 0x14
    46d4:	08 95       	ret
    return 1;
    46d6:	80 e0       	ldi	r24, 0x00	; 0
  }
  return 0;
}
    46d8:	08 95       	ret

000046da <psock_datalen>:
  PT_END(&s->psockpt);
}
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    46da:	fc 01       	movw	r30, r24
    46dc:	22 89       	ldd	r18, Z+18	; 0x12
    46de:	33 89       	ldd	r19, Z+19	; 0x13
    46e0:	80 89       	ldd	r24, Z+16	; 0x10
    46e2:	91 89       	ldd	r25, Z+17	; 0x11
    46e4:	28 1b       	sub	r18, r24
    46e6:	39 0b       	sbc	r19, r25
  return psock->bufsize - psock->buf.left;
}
    46e8:	c9 01       	movw	r24, r18
    46ea:	08 95       	ret

000046ec <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    46ec:	fc 01       	movw	r30, r24
  if(s->readlen > 0) {
    46ee:	84 85       	ldd	r24, Z+12	; 0x0c
    46f0:	95 85       	ldd	r25, Z+13	; 0x0d
    46f2:	89 2b       	or	r24, r25
    46f4:	11 f0       	breq	.+4      	; 0x46fa <psock_newdata+0xe>
    46f6:	81 e0       	ldi	r24, 0x01	; 1
    46f8:	08 95       	ret
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
  } else if(s->state == STATE_READ) {
    46fa:	84 89       	ldd	r24, Z+20	; 0x14
    46fc:	82 30       	cpi	r24, 0x02	; 2
    46fe:	21 f4       	brne	.+8      	; 0x4708 <psock_newdata+0x1c>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    4700:	83 e0       	ldi	r24, 0x03	; 3
    4702:	84 8b       	std	Z+20, r24	; 0x14
    4704:	80 e0       	ldi	r24, 0x00	; 0
    4706:	08 95       	ret
    return 0;
    4708:	80 91 6d 04 	lds	r24, 0x046D
    470c:	90 e0       	ldi	r25, 0x00	; 0
    470e:	96 95       	lsr	r25
    4710:	87 95       	ror	r24
    4712:	81 70       	andi	r24, 0x01	; 1
    return 1;
  } else {
    /* There is no new data. */
    return 0;
  }
}
    4714:	08 95       	ret

00004716 <psock_readto>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    4716:	1f 93       	push	r17
    4718:	cf 93       	push	r28
    471a:	df 93       	push	r29
    471c:	ec 01       	movw	r28, r24
    471e:	16 2f       	mov	r17, r22
  PT_BEGIN(&psock->psockpt);
    4720:	8a 81       	ldd	r24, Y+2	; 0x02
    4722:	9b 81       	ldd	r25, Y+3	; 0x03
    4724:	00 97       	sbiw	r24, 0x00	; 0
    4726:	29 f0       	breq	.+10     	; 0x4732 <psock_readto+0x1c>
    4728:	87 55       	subi	r24, 0x57	; 87
    472a:	91 40       	sbci	r25, 0x01	; 1
    472c:	09 f0       	breq	.+2      	; 0x4730 <psock_readto+0x1a>
    472e:	73 c0       	rjmp	.+230    	; 0x4816 <psock_readto+0x100>
    4730:	10 c0       	rjmp	.+32     	; 0x4752 <psock_readto+0x3c>

  buf_setup(&psock->buf, (u8_t *)psock->bufptr, psock->bufsize);
    4732:	2a 89       	ldd	r18, Y+18	; 0x12
    4734:	3b 89       	ldd	r19, Y+19	; 0x13
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    4736:	88 85       	ldd	r24, Y+8	; 0x08
    4738:	99 85       	ldd	r25, Y+9	; 0x09
    473a:	9f 87       	std	Y+15, r25	; 0x0f
    473c:	8e 87       	std	Y+14, r24	; 0x0e
  buf->left = bufsize;
    473e:	39 8b       	std	Y+17, r19	; 0x11
    4740:	28 8b       	std	Y+16, r18	; 0x10
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    4742:	8c 85       	ldd	r24, Y+12	; 0x0c
    4744:	9d 85       	ldd	r25, Y+13	; 0x0d
    4746:	89 2b       	or	r24, r25
    4748:	b9 f5       	brne	.+110    	; 0x47b8 <psock_readto+0xa2>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    474a:	87 e5       	ldi	r24, 0x57	; 87
    474c:	91 e0       	ldi	r25, 0x01	; 1
    474e:	9b 83       	std	Y+3, r25	; 0x03
    4750:	8a 83       	std	Y+2, r24	; 0x02
    4752:	ce 01       	movw	r24, r28
    4754:	0e 94 76 23 	call	0x46ec	; 0x46ec <psock_newdata>
    4758:	88 23       	and	r24, r24
    475a:	09 f4       	brne	.+2      	; 0x475e <psock_readto+0x48>
    475c:	5f c0       	rjmp	.+190    	; 0x481c <psock_readto+0x106>
      psock->state = STATE_READ;
    475e:	82 e0       	ldi	r24, 0x02	; 2
    4760:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    4762:	80 91 6e 04 	lds	r24, 0x046E
    4766:	90 91 6f 04 	lds	r25, 0x046F
    476a:	9f 83       	std	Y+7, r25	; 0x07
    476c:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    476e:	80 91 65 04 	lds	r24, 0x0465
    4772:	90 91 66 04 	lds	r25, 0x0466
    4776:	9d 87       	std	Y+13, r25	; 0x0d
    4778:	8c 87       	std	Y+12, r24	; 0x0c
    477a:	1e c0       	rjmp	.+60     	; 0x47b8 <psock_readto+0xa2>
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    c = *buf->ptr = **dataptr;
    477c:	ee 81       	ldd	r30, Y+6	; 0x06
    477e:	ff 81       	ldd	r31, Y+7	; 0x07
    4780:	20 81       	ld	r18, Z
    4782:	ee 85       	ldd	r30, Y+14	; 0x0e
    4784:	ff 85       	ldd	r31, Y+15	; 0x0f
    4786:	20 83       	st	Z, r18
    ++*dataptr;
    4788:	8e 81       	ldd	r24, Y+6	; 0x06
    478a:	9f 81       	ldd	r25, Y+7	; 0x07
    478c:	01 96       	adiw	r24, 0x01	; 1
    478e:	9f 83       	std	Y+7, r25	; 0x07
    4790:	8e 83       	std	Y+6, r24	; 0x06
    ++buf->ptr;
    4792:	8e 85       	ldd	r24, Y+14	; 0x0e
    4794:	9f 85       	ldd	r25, Y+15	; 0x0f
    4796:	01 96       	adiw	r24, 0x01	; 1
    4798:	9f 87       	std	Y+15, r25	; 0x0f
    479a:	8e 87       	std	Y+14, r24	; 0x0e
    --*datalen;
    479c:	8c 85       	ldd	r24, Y+12	; 0x0c
    479e:	9d 85       	ldd	r25, Y+13	; 0x0d
    47a0:	01 97       	sbiw	r24, 0x01	; 1
    47a2:	9d 87       	std	Y+13, r25	; 0x0d
    47a4:	8c 87       	std	Y+12, r24	; 0x0c
    --buf->left;
    47a6:	88 89       	ldd	r24, Y+16	; 0x10
    47a8:	99 89       	ldd	r25, Y+17	; 0x11
    47aa:	01 97       	sbiw	r24, 0x01	; 1
    47ac:	99 8b       	std	Y+17, r25	; 0x11
    47ae:	88 8b       	std	Y+16, r24	; 0x10
    
    if(c == endmarker) {
    47b0:	21 17       	cp	r18, r17
    47b2:	11 f4       	brne	.+4      	; 0x47b8 <psock_readto+0xa2>
    47b4:	82 e0       	ldi	r24, 0x02	; 2
    47b6:	21 c0       	rjmp	.+66     	; 0x47fa <psock_readto+0xe4>
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    47b8:	88 89       	ldd	r24, Y+16	; 0x10
    47ba:	99 89       	ldd	r25, Y+17	; 0x11
    47bc:	89 2b       	or	r24, r25
    47be:	21 f0       	breq	.+8      	; 0x47c8 <psock_readto+0xb2>
    47c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    47c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    47c4:	89 2b       	or	r24, r25
    47c6:	d1 f6       	brne	.-76     	; 0x477c <psock_readto+0x66>
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    47c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    47ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    47cc:	89 2b       	or	r24, r25
    47ce:	79 f4       	brne	.+30     	; 0x47ee <psock_readto+0xd8>
    47d0:	80 e0       	ldi	r24, 0x00	; 0
    47d2:	13 c0       	rjmp	.+38     	; 0x47fa <psock_readto+0xe4>
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    c = **dataptr;
    47d4:	ee 81       	ldd	r30, Y+6	; 0x06
    47d6:	ff 81       	ldd	r31, Y+7	; 0x07
    47d8:	81 91       	ld	r24, Z+
    --*datalen;
    47da:	21 50       	subi	r18, 0x01	; 1
    47dc:	30 40       	sbci	r19, 0x00	; 0
    47de:	3d 87       	std	Y+13, r19	; 0x0d
    47e0:	2c 87       	std	Y+12, r18	; 0x0c
    ++*dataptr;
    47e2:	ff 83       	std	Y+7, r31	; 0x07
    47e4:	ee 83       	std	Y+6, r30	; 0x06
    
    if(c == endmarker) {
    47e6:	81 17       	cp	r24, r17
    47e8:	11 f4       	brne	.+4      	; 0x47ee <psock_readto+0xd8>
    47ea:	83 e0       	ldi	r24, 0x03	; 3
    47ec:	06 c0       	rjmp	.+12     	; 0x47fa <psock_readto+0xe4>

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    47ee:	2c 85       	ldd	r18, Y+12	; 0x0c
    47f0:	3d 85       	ldd	r19, Y+13	; 0x0d
    47f2:	21 15       	cp	r18, r1
    47f4:	31 05       	cpc	r19, r1
    47f6:	71 f7       	brne	.-36     	; 0x47d4 <psock_readto+0xbe>
    47f8:	81 e0       	ldi	r24, 0x01	; 1
      psock->readptr = (u8_t *)uip_appdata;
      psock->readlen = uip_datalen();
    }
  } while((buf_bufto(&psock->buf, c,
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
    47fa:	81 ff       	sbrs	r24, 1
    47fc:	a2 cf       	rjmp	.-188    	; 0x4742 <psock_readto+0x2c>
  
  if(psock_datalen(psock) == 0) {
    47fe:	2a 89       	ldd	r18, Y+18	; 0x12
    4800:	3b 89       	ldd	r19, Y+19	; 0x13
    4802:	88 89       	ldd	r24, Y+16	; 0x10
    4804:	99 89       	ldd	r25, Y+17	; 0x11
    4806:	28 17       	cp	r18, r24
    4808:	39 07       	cpc	r19, r25
    480a:	29 f4       	brne	.+10     	; 0x4816 <psock_readto+0x100>
    psock->state = STATE_NONE;
    480c:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    480e:	1b 82       	std	Y+3, r1	; 0x03
    4810:	1a 82       	std	Y+2, r1	; 0x02
    4812:	80 e0       	ldi	r24, 0x00	; 0
    4814:	03 c0       	rjmp	.+6      	; 0x481c <psock_readto+0x106>
  }
  PT_END(&psock->psockpt);
    4816:	1b 82       	std	Y+3, r1	; 0x03
    4818:	1a 82       	std	Y+2, r1	; 0x02
    481a:	82 e0       	ldi	r24, 0x02	; 2
}
    481c:	df 91       	pop	r29
    481e:	cf 91       	pop	r28
    4820:	1f 91       	pop	r17
    4822:	08 95       	ret

00004824 <psock_init>:
  PT_END(&psock->psockpt);
}
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    4824:	fc 01       	movw	r30, r24
  psock->state = STATE_NONE;
    4826:	14 8a       	std	Z+20, r1	; 0x14
  psock->readlen = 0;
    4828:	15 86       	std	Z+13, r1	; 0x0d
    482a:	14 86       	std	Z+12, r1	; 0x0c
  psock->bufptr = buffer;
    482c:	71 87       	std	Z+9, r23	; 0x09
    482e:	60 87       	std	Z+8, r22	; 0x08
  psock->bufsize = buffersize;
    4830:	53 8b       	std	Z+19, r21	; 0x13
    4832:	42 8b       	std	Z+18, r20	; 0x12
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    4834:	77 87       	std	Z+15, r23	; 0x0f
    4836:	66 87       	std	Z+14, r22	; 0x0e
  buf->left = bufsize;
    4838:	51 8b       	std	Z+17, r21	; 0x11
    483a:	40 8b       	std	Z+16, r20	; 0x10
  psock->state = STATE_NONE;
  psock->readlen = 0;
  psock->bufptr = buffer;
  psock->bufsize = buffersize;
  buf_setup(&psock->buf, (u8_t *) buffer, buffersize);
  PT_INIT(&psock->pt);
    483c:	11 82       	std	Z+1, r1	; 0x01
    483e:	10 82       	st	Z, r1
  PT_INIT(&psock->psockpt);
    4840:	13 82       	std	Z+3, r1	; 0x03
    4842:	12 82       	std	Z+2, r1	; 0x02
}
    4844:	08 95       	ret

00004846 <psock_readbuf>:
  }
  PT_END(&psock->psockpt);
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    4846:	cf 93       	push	r28
    4848:	df 93       	push	r29
    484a:	ec 01       	movw	r28, r24
  PT_BEGIN(&psock->psockpt);
    484c:	8a 81       	ldd	r24, Y+2	; 0x02
    484e:	9b 81       	ldd	r25, Y+3	; 0x03
    4850:	00 97       	sbiw	r24, 0x00	; 0
    4852:	29 f0       	breq	.+10     	; 0x485e <psock_readbuf+0x18>
    4854:	82 57       	subi	r24, 0x72	; 114
    4856:	91 40       	sbci	r25, 0x01	; 1
    4858:	09 f0       	breq	.+2      	; 0x485c <psock_readbuf+0x16>
    485a:	86 c0       	rjmp	.+268    	; 0x4968 <psock_readbuf+0x122>
    485c:	10 c0       	rjmp	.+32     	; 0x487e <psock_readbuf+0x38>

  buf_setup(&psock->buf, (u8_t *)psock->bufptr, psock->bufsize);
    485e:	2a 89       	ldd	r18, Y+18	; 0x12
    4860:	3b 89       	ldd	r19, Y+19	; 0x13
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    4862:	88 85       	ldd	r24, Y+8	; 0x08
    4864:	99 85       	ldd	r25, Y+9	; 0x09
    4866:	9f 87       	std	Y+15, r25	; 0x0f
    4868:	8e 87       	std	Y+14, r24	; 0x0e
  buf->left = bufsize;
    486a:	39 8b       	std	Y+17, r19	; 0x11
    486c:	28 8b       	std	Y+16, r18	; 0x10
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    486e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4870:	9d 85       	ldd	r25, Y+13	; 0x0d
    4872:	89 2b       	or	r24, r25
    4874:	c1 f4       	brne	.+48     	; 0x48a6 <psock_readbuf+0x60>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    4876:	82 e7       	ldi	r24, 0x72	; 114
    4878:	91 e0       	ldi	r25, 0x01	; 1
    487a:	9b 83       	std	Y+3, r25	; 0x03
    487c:	8a 83       	std	Y+2, r24	; 0x02
    487e:	ce 01       	movw	r24, r28
    4880:	0e 94 76 23 	call	0x46ec	; 0x46ec <psock_newdata>
    4884:	88 23       	and	r24, r24
    4886:	09 f4       	brne	.+2      	; 0x488a <psock_readbuf+0x44>
    4888:	72 c0       	rjmp	.+228    	; 0x496e <psock_readbuf+0x128>
      //printf("Waited for newdata\n");
      psock->state = STATE_READ;
    488a:	82 e0       	ldi	r24, 0x02	; 2
    488c:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    488e:	80 91 6e 04 	lds	r24, 0x046E
    4892:	90 91 6f 04 	lds	r25, 0x046F
    4896:	9f 83       	std	Y+7, r25	; 0x07
    4898:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    489a:	80 91 65 04 	lds	r24, 0x0465
    489e:	90 91 66 04 	lds	r25, 0x0466
    48a2:	9d 87       	std	Y+13, r25	; 0x0d
    48a4:	8c 87       	std	Y+12, r24	; 0x0c
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
  if(*datalen < buf->left) {
    48a6:	ec 85       	ldd	r30, Y+12	; 0x0c
    48a8:	fd 85       	ldd	r31, Y+13	; 0x0d
    48aa:	28 89       	ldd	r18, Y+16	; 0x10
    48ac:	39 89       	ldd	r19, Y+17	; 0x11
    48ae:	e2 17       	cp	r30, r18
    48b0:	f3 07       	cpc	r31, r19
    48b2:	f0 f4       	brcc	.+60     	; 0x48f0 <psock_readbuf+0xaa>
    memcpy(buf->ptr, *dataptr, *datalen);
    48b4:	6e 81       	ldd	r22, Y+6	; 0x06
    48b6:	7f 81       	ldd	r23, Y+7	; 0x07
    48b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    48ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    48bc:	af 01       	movw	r20, r30
    48be:	0e 94 38 2f 	call	0x5e70	; 0x5e70 <memcpy>
    buf->ptr += *datalen;
    48c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    48c4:	9f 85       	ldd	r25, Y+15	; 0x0f
    48c6:	2c 85       	ldd	r18, Y+12	; 0x0c
    48c8:	3d 85       	ldd	r19, Y+13	; 0x0d
    48ca:	82 0f       	add	r24, r18
    48cc:	93 1f       	adc	r25, r19
    48ce:	9f 87       	std	Y+15, r25	; 0x0f
    48d0:	8e 87       	std	Y+14, r24	; 0x0e
    buf->left -= *datalen;
    48d2:	88 89       	ldd	r24, Y+16	; 0x10
    48d4:	99 89       	ldd	r25, Y+17	; 0x11
    48d6:	82 1b       	sub	r24, r18
    48d8:	93 0b       	sbc	r25, r19
    48da:	99 8b       	std	Y+17, r25	; 0x11
    48dc:	88 8b       	std	Y+16, r24	; 0x10
    *dataptr += *datalen;
    48de:	8e 81       	ldd	r24, Y+6	; 0x06
    48e0:	9f 81       	ldd	r25, Y+7	; 0x07
    48e2:	82 0f       	add	r24, r18
    48e4:	93 1f       	adc	r25, r19
    48e6:	9f 83       	std	Y+7, r25	; 0x07
    48e8:	8e 83       	std	Y+6, r24	; 0x06
    *datalen = 0;
    48ea:	1d 86       	std	Y+13, r1	; 0x0d
    48ec:	1c 86       	std	Y+12, r1	; 0x0c
    48ee:	bf cf       	rjmp	.-130    	; 0x486e <psock_readbuf+0x28>
    48f0:	8e 85       	ldd	r24, Y+14	; 0x0e
    48f2:	9f 85       	ldd	r25, Y+15	; 0x0f
    48f4:	6e 81       	ldd	r22, Y+6	; 0x06
    48f6:	7f 81       	ldd	r23, Y+7	; 0x07
    return BUF_NOT_FULL;
  } else if(*datalen == buf->left) {
    48f8:	e2 17       	cp	r30, r18
    48fa:	f3 07       	cpc	r31, r19
    48fc:	b1 f4       	brne	.+44     	; 0x492a <psock_readbuf+0xe4>
    memcpy(buf->ptr, *dataptr, *datalen);
    48fe:	af 01       	movw	r20, r30
    4900:	0e 94 38 2f 	call	0x5e70	; 0x5e70 <memcpy>
    buf->ptr += *datalen;
    4904:	8e 85       	ldd	r24, Y+14	; 0x0e
    4906:	9f 85       	ldd	r25, Y+15	; 0x0f
    4908:	2c 85       	ldd	r18, Y+12	; 0x0c
    490a:	3d 85       	ldd	r19, Y+13	; 0x0d
    490c:	82 0f       	add	r24, r18
    490e:	93 1f       	adc	r25, r19
    4910:	9f 87       	std	Y+15, r25	; 0x0f
    4912:	8e 87       	std	Y+14, r24	; 0x0e
    buf->left = 0;
    4914:	19 8a       	std	Y+17, r1	; 0x11
    4916:	18 8a       	std	Y+16, r1	; 0x10
    *dataptr += *datalen;
    4918:	8e 81       	ldd	r24, Y+6	; 0x06
    491a:	9f 81       	ldd	r25, Y+7	; 0x07
    491c:	82 0f       	add	r24, r18
    491e:	93 1f       	adc	r25, r19
    4920:	9f 83       	std	Y+7, r25	; 0x07
    4922:	8e 83       	std	Y+6, r24	; 0x06
    *datalen = 0;
    4924:	1d 86       	std	Y+13, r1	; 0x0d
    4926:	1c 86       	std	Y+12, r1	; 0x0c
    4928:	25 c0       	rjmp	.+74     	; 0x4974 <psock_readbuf+0x12e>
    return BUF_FULL;
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    492a:	a9 01       	movw	r20, r18
    492c:	0e 94 38 2f 	call	0x5e70	; 0x5e70 <memcpy>
    buf->ptr += buf->left;
    4930:	8e 85       	ldd	r24, Y+14	; 0x0e
    4932:	9f 85       	ldd	r25, Y+15	; 0x0f
    4934:	28 89       	ldd	r18, Y+16	; 0x10
    4936:	39 89       	ldd	r19, Y+17	; 0x11
    4938:	82 0f       	add	r24, r18
    493a:	93 1f       	adc	r25, r19
    493c:	9f 87       	std	Y+15, r25	; 0x0f
    493e:	8e 87       	std	Y+14, r24	; 0x0e
    *datalen -= buf->left;
    4940:	8c 85       	ldd	r24, Y+12	; 0x0c
    4942:	9d 85       	ldd	r25, Y+13	; 0x0d
    4944:	82 1b       	sub	r24, r18
    4946:	93 0b       	sbc	r25, r19
    4948:	9d 87       	std	Y+13, r25	; 0x0d
    494a:	8c 87       	std	Y+12, r24	; 0x0c
    *dataptr += buf->left;
    494c:	8e 81       	ldd	r24, Y+6	; 0x06
    494e:	9f 81       	ldd	r25, Y+7	; 0x07
    4950:	82 0f       	add	r24, r18
    4952:	93 1f       	adc	r25, r19
    4954:	9f 83       	std	Y+7, r25	; 0x07
    4956:	8e 83       	std	Y+6, r24	; 0x06
    buf->left = 0;
    4958:	19 8a       	std	Y+17, r1	; 0x11
    495a:	18 8a       	std	Y+16, r1	; 0x10
    495c:	0b c0       	rjmp	.+22     	; 0x4974 <psock_readbuf+0x12e>
  } while(buf_bufdata(&psock->buf, psock->bufsize,
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);

  if(psock_datalen(psock) == 0) {
    psock->state = STATE_NONE;
    495e:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    4960:	1b 82       	std	Y+3, r1	; 0x03
    4962:	1a 82       	std	Y+2, r1	; 0x02
    4964:	80 e0       	ldi	r24, 0x00	; 0
    4966:	03 c0       	rjmp	.+6      	; 0x496e <psock_readbuf+0x128>
  }
  PT_END(&psock->psockpt);
    4968:	1b 82       	std	Y+3, r1	; 0x03
    496a:	1a 82       	std	Y+2, r1	; 0x02
    496c:	82 e0       	ldi	r24, 0x02	; 2
}
    496e:	df 91       	pop	r29
    4970:	cf 91       	pop	r28
    4972:	08 95       	ret
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);

  if(psock_datalen(psock) == 0) {
    4974:	2a 89       	ldd	r18, Y+18	; 0x12
    4976:	3b 89       	ldd	r19, Y+19	; 0x13
    4978:	88 89       	ldd	r24, Y+16	; 0x10
    497a:	99 89       	ldd	r25, Y+17	; 0x11
    497c:	28 17       	cp	r18, r24
    497e:	39 07       	cpc	r19, r25
    4980:	99 f7       	brne	.-26     	; 0x4968 <psock_readbuf+0x122>
    4982:	ed cf       	rjmp	.-38     	; 0x495e <psock_readbuf+0x118>

00004984 <send_data>:
  return BUF_FULL;
}
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    4984:	cf 93       	push	r28
    4986:	df 93       	push	r29
    4988:	ec 01       	movw	r28, r24
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    498a:	8c 89       	ldd	r24, Y+20	; 0x14
    498c:	86 30       	cpi	r24, 0x06	; 6
    498e:	31 f4       	brne	.+12     	; 0x499c <send_data+0x18>
    4990:	80 91 6d 04 	lds	r24, 0x046D
    4994:	82 fd       	sbrc	r24, 2
    4996:	02 c0       	rjmp	.+4      	; 0x499c <send_data+0x18>
    4998:	80 e0       	ldi	r24, 0x00	; 0
    499a:	13 c0       	rjmp	.+38     	; 0x49c2 <send_data+0x3e>
    if(s->sendlen > uip_mss()) {
    499c:	2a 85       	ldd	r18, Y+10	; 0x0a
    499e:	3b 85       	ldd	r19, Y+11	; 0x0b
    49a0:	e0 91 70 04 	lds	r30, 0x0470
    49a4:	f0 91 71 04 	lds	r31, 0x0471
    49a8:	62 89       	ldd	r22, Z+18	; 0x12
    49aa:	73 89       	ldd	r23, Z+19	; 0x13
    49ac:	8c 81       	ldd	r24, Y+4	; 0x04
    49ae:	9d 81       	ldd	r25, Y+5	; 0x05
    49b0:	62 17       	cp	r22, r18
    49b2:	73 07       	cpc	r23, r19
    49b4:	08 f0       	brcs	.+2      	; 0x49b8 <send_data+0x34>
      uip_send(s->sendptr, uip_mss());
    } else {
      uip_send(s->sendptr, s->sendlen);
    49b6:	b9 01       	movw	r22, r18
    49b8:	0e 94 ef 18 	call	0x31de	; 0x31de <uip_send>
    }
    s->state = STATE_DATA_SENT;
    49bc:	86 e0       	ldi	r24, 0x06	; 6
    49be:	8c 8b       	std	Y+20, r24	; 0x14
    49c0:	81 e0       	ldi	r24, 0x01	; 1
    return 1;
  }
  return 0;
}
    49c2:	df 91       	pop	r29
    49c4:	cf 91       	pop	r28
    49c6:	08 95       	ret

000049c8 <psock_generator_send>:
  PT_END(&s->psockpt);
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    49c8:	cf 92       	push	r12
    49ca:	df 92       	push	r13
    49cc:	ef 92       	push	r14
    49ce:	ff 92       	push	r15
    49d0:	1f 93       	push	r17
    49d2:	cf 93       	push	r28
    49d4:	df 93       	push	r29
    49d6:	ec 01       	movw	r28, r24
    49d8:	7b 01       	movw	r14, r22
    49da:	6a 01       	movw	r12, r20
  PT_BEGIN(&s->psockpt);
    49dc:	8a 81       	ldd	r24, Y+2	; 0x02
    49de:	9b 81       	ldd	r25, Y+3	; 0x03
    49e0:	00 97       	sbiw	r24, 0x00	; 0
    49e2:	21 f0       	breq	.+8      	; 0x49ec <psock_generator_send+0x24>
    49e4:	8a 52       	subi	r24, 0x2A	; 42
    49e6:	91 40       	sbci	r25, 0x01	; 1
    49e8:	79 f5       	brne	.+94     	; 0x4a48 <psock_generator_send+0x80>
    49ea:	1e c0       	rjmp	.+60     	; 0x4a28 <psock_generator_send+0x60>

  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    49ec:	61 15       	cp	r22, r1
    49ee:	71 05       	cpc	r23, r1
    49f0:	21 f4       	brne	.+8      	; 0x49fa <psock_generator_send+0x32>
    PT_EXIT(&s->psockpt);
    49f2:	1b 82       	std	Y+3, r1	; 0x03
    49f4:	1a 82       	std	Y+2, r1	; 0x02
    49f6:	81 e0       	ldi	r24, 0x01	; 1
    49f8:	2a c0       	rjmp	.+84     	; 0x4a4e <psock_generator_send+0x86>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
    49fa:	ca 01       	movw	r24, r20
    49fc:	fb 01       	movw	r30, r22
    49fe:	09 95       	icall
    4a00:	9b 87       	std	Y+11, r25	; 0x0b
    4a02:	8a 87       	std	Y+10, r24	; 0x0a
  s->sendptr = uip_appdata;
    4a04:	80 91 6e 04 	lds	r24, 0x046E
    4a08:	90 91 6f 04 	lds	r25, 0x046F
    4a0c:	9d 83       	std	Y+5, r25	; 0x05
    4a0e:	8c 83       	std	Y+4, r24	; 0x04

  s->state = STATE_NONE;  
    4a10:	1c 8a       	std	Y+20, r1	; 0x14
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
    4a12:	80 91 6d 04 	lds	r24, 0x046D
    4a16:	82 ff       	sbrs	r24, 2
    4a18:	03 c0       	rjmp	.+6      	; 0x4a20 <psock_generator_send+0x58>
      generate(arg);
    4a1a:	c6 01       	movw	r24, r12
    4a1c:	f7 01       	movw	r30, r14
    4a1e:	09 95       	icall
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    4a20:	8a e2       	ldi	r24, 0x2A	; 42
    4a22:	91 e0       	ldi	r25, 0x01	; 1
    4a24:	9b 83       	std	Y+3, r25	; 0x03
    4a26:	8a 83       	std	Y+2, r24	; 0x02
    4a28:	ce 01       	movw	r24, r28
    4a2a:	0e 94 3e 23 	call	0x467c	; 0x467c <data_acked>
    4a2e:	18 2f       	mov	r17, r24
    4a30:	ce 01       	movw	r24, r28
    4a32:	0e 94 c2 24 	call	0x4984	; 0x4984 <send_data>
    4a36:	18 23       	and	r17, r24
    4a38:	11 f4       	brne	.+4      	; 0x4a3e <psock_generator_send+0x76>
    4a3a:	80 e0       	ldi	r24, 0x00	; 0
    4a3c:	08 c0       	rjmp	.+16     	; 0x4a4e <psock_generator_send+0x86>
  } while(s->sendlen > 0);
    4a3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4a40:	9b 85       	ldd	r25, Y+11	; 0x0b
    4a42:	89 2b       	or	r24, r25
    4a44:	31 f7       	brne	.-52     	; 0x4a12 <psock_generator_send+0x4a>
  
  s->state = STATE_NONE;
    4a46:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    4a48:	1b 82       	std	Y+3, r1	; 0x03
    4a4a:	1a 82       	std	Y+2, r1	; 0x02
    4a4c:	82 e0       	ldi	r24, 0x02	; 2
}
    4a4e:	df 91       	pop	r29
    4a50:	cf 91       	pop	r28
    4a52:	1f 91       	pop	r17
    4a54:	ff 90       	pop	r15
    4a56:	ef 90       	pop	r14
    4a58:	df 90       	pop	r13
    4a5a:	cf 90       	pop	r12
    4a5c:	08 95       	ret

00004a5e <psock_send>:
  return 0;
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s,  const char *buf,
		     unsigned int len))
{
    4a5e:	1f 93       	push	r17
    4a60:	cf 93       	push	r28
    4a62:	df 93       	push	r29
    4a64:	ec 01       	movw	r28, r24
	PT_BEGIN(&s->psockpt);
    4a66:	8a 81       	ldd	r24, Y+2	; 0x02
    4a68:	9b 81       	ldd	r25, Y+3	; 0x03
    4a6a:	00 97       	sbiw	r24, 0x00	; 0
    4a6c:	21 f0       	breq	.+8      	; 0x4a76 <psock_send+0x18>
    4a6e:	82 3e       	cpi	r24, 0xE2	; 226
    4a70:	91 05       	cpc	r25, r1
    4a72:	11 f5       	brne	.+68     	; 0x4ab8 <psock_send+0x5a>
    4a74:	11 c0       	rjmp	.+34     	; 0x4a98 <psock_send+0x3a>
	
	/* If there is no data to send, we exit immediately. */
  if(len == 0) {
    4a76:	41 15       	cp	r20, r1
    4a78:	51 05       	cpc	r21, r1
    4a7a:	21 f4       	brne	.+8      	; 0x4a84 <psock_send+0x26>
    PT_EXIT(&s->psockpt);
    4a7c:	1b 82       	std	Y+3, r1	; 0x03
    4a7e:	1a 82       	std	Y+2, r1	; 0x02
    4a80:	81 e0       	ldi	r24, 0x01	; 1
    4a82:	1d c0       	rjmp	.+58     	; 0x4abe <psock_send+0x60>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (u8_t *) buf;
    4a84:	7d 83       	std	Y+5, r23	; 0x05
    4a86:	6c 83       	std	Y+4, r22	; 0x04
  s->sendlen = len;
    4a88:	5b 87       	std	Y+11, r21	; 0x0b
    4a8a:	4a 87       	std	Y+10, r20	; 0x0a
	
  s->state = STATE_NONE;
    4a8c:	1c 8a       	std	Y+20, r1	; 0x14
    4a8e:	0f c0       	rjmp	.+30     	; 0x4aae <psock_send+0x50>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    4a90:	82 ee       	ldi	r24, 0xE2	; 226
    4a92:	90 e0       	ldi	r25, 0x00	; 0
    4a94:	9b 83       	std	Y+3, r25	; 0x03
    4a96:	8a 83       	std	Y+2, r24	; 0x02
    4a98:	ce 01       	movw	r24, r28
    4a9a:	0e 94 3e 23 	call	0x467c	; 0x467c <data_acked>
    4a9e:	18 2f       	mov	r17, r24
    4aa0:	ce 01       	movw	r24, r28
    4aa2:	0e 94 c2 24 	call	0x4984	; 0x4984 <send_data>
    4aa6:	18 23       	and	r17, r24
    4aa8:	11 f4       	brne	.+4      	; 0x4aae <psock_send+0x50>
    4aaa:	80 e0       	ldi	r24, 0x00	; 0
    4aac:	08 c0       	rjmp	.+16     	; 0x4abe <psock_send+0x60>
	
  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    4aae:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ab0:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ab2:	89 2b       	or	r24, r25
    4ab4:	69 f7       	brne	.-38     	; 0x4a90 <psock_send+0x32>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
  }

  s->state = STATE_NONE;
    4ab6:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    4ab8:	1b 82       	std	Y+3, r1	; 0x03
    4aba:	1a 82       	std	Y+2, r1	; 0x02
    4abc:	82 e0       	ldi	r24, 0x02	; 2
}
    4abe:	df 91       	pop	r29
    4ac0:	cf 91       	pop	r28
    4ac2:	1f 91       	pop	r17
    4ac4:	08 95       	ret

00004ac6 <psock_send_P>:

/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send_P(register struct psock *s, const char *buf,
		     unsigned int len))
{
    4ac6:	1f 93       	push	r17
    4ac8:	cf 93       	push	r28
    4aca:	df 93       	push	r29
    4acc:	ec 01       	movw	r28, r24
	PT_BEGIN(&s->psockpt);
    4ace:	8a 81       	ldd	r24, Y+2	; 0x02
    4ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    4ad2:	00 97       	sbiw	r24, 0x00	; 0
    4ad4:	21 f0       	breq	.+8      	; 0x4ade <psock_send_P+0x18>
    4ad6:	8b 50       	subi	r24, 0x0B	; 11
    4ad8:	91 40       	sbci	r25, 0x01	; 1
    4ada:	c9 f5       	brne	.+114    	; 0x4b4e <psock_send_P+0x88>
    4adc:	11 c0       	rjmp	.+34     	; 0x4b00 <psock_send_P+0x3a>
	
	/* If there is no data to send, we exit immediately. */
  if(len == 0) {
    4ade:	41 15       	cp	r20, r1
    4ae0:	51 05       	cpc	r21, r1
    4ae2:	21 f4       	brne	.+8      	; 0x4aec <psock_send_P+0x26>
    PT_EXIT(&s->psockpt);
    4ae4:	1b 82       	std	Y+3, r1	; 0x03
    4ae6:	1a 82       	std	Y+2, r1	; 0x02
    4ae8:	81 e0       	ldi	r24, 0x01	; 1
    4aea:	34 c0       	rjmp	.+104    	; 0x4b54 <psock_send_P+0x8e>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (u8_t *) buf;
    4aec:	7d 83       	std	Y+5, r23	; 0x05
    4aee:	6c 83       	std	Y+4, r22	; 0x04
  s->sendlen = len;
    4af0:	5b 87       	std	Y+11, r21	; 0x0b
    4af2:	4a 87       	std	Y+10, r20	; 0x0a
	
	
  s->state = STATE_NONE;
    4af4:	1c 8a       	std	Y+20, r1	; 0x14
    4af6:	26 c0       	rjmp	.+76     	; 0x4b44 <psock_send_P+0x7e>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
    4af8:	8b e0       	ldi	r24, 0x0B	; 11
    4afa:	91 e0       	ldi	r25, 0x01	; 1
    4afc:	9b 83       	std	Y+3, r25	; 0x03
    4afe:	8a 83       	std	Y+2, r24	; 0x02
    4b00:	ce 01       	movw	r24, r28
    4b02:	0e 94 3e 23 	call	0x467c	; 0x467c <data_acked>
    4b06:	18 2f       	mov	r17, r24
}
/*---------------------------------------------------------------------------*/
static char
send_data_P(register struct psock *s)
{
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    4b08:	8c 89       	ldd	r24, Y+20	; 0x14
    4b0a:	86 30       	cpi	r24, 0x06	; 6
    4b0c:	31 f4       	brne	.+12     	; 0x4b1a <psock_send_P+0x54>
    4b0e:	80 91 6d 04 	lds	r24, 0x046D
    4b12:	82 fd       	sbrc	r24, 2
    4b14:	02 c0       	rjmp	.+4      	; 0x4b1a <psock_send_P+0x54>
    4b16:	80 e0       	ldi	r24, 0x00	; 0
    4b18:	13 c0       	rjmp	.+38     	; 0x4b40 <psock_send_P+0x7a>
    if(s->sendlen > uip_mss()) {
    4b1a:	2a 85       	ldd	r18, Y+10	; 0x0a
    4b1c:	3b 85       	ldd	r19, Y+11	; 0x0b
    4b1e:	e0 91 70 04 	lds	r30, 0x0470
    4b22:	f0 91 71 04 	lds	r31, 0x0471
    4b26:	62 89       	ldd	r22, Z+18	; 0x12
    4b28:	73 89       	ldd	r23, Z+19	; 0x13
    4b2a:	8c 81       	ldd	r24, Y+4	; 0x04
    4b2c:	9d 81       	ldd	r25, Y+5	; 0x05
    4b2e:	62 17       	cp	r22, r18
    4b30:	73 07       	cpc	r23, r19
    4b32:	08 f0       	brcs	.+2      	; 0x4b36 <psock_send_P+0x70>
      uip_send_P(s->sendptr, uip_mss());
    } else {
      uip_send_P(s->sendptr, s->sendlen);
    4b34:	b9 01       	movw	r22, r18
    4b36:	0e 94 05 19 	call	0x320a	; 0x320a <uip_send_P>
    }
    s->state = STATE_DATA_SENT;
    4b3a:	86 e0       	ldi	r24, 0x06	; 6
    4b3c:	8c 8b       	std	Y+20, r24	; 0x14
    4b3e:	81 e0       	ldi	r24, 0x01	; 1
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
    4b40:	81 23       	and	r24, r17
    4b42:	41 f0       	breq	.+16     	; 0x4b54 <psock_send_P+0x8e>
	
  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    4b44:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b46:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b48:	89 2b       	or	r24, r25
    4b4a:	b1 f6       	brne	.-84     	; 0x4af8 <psock_send_P+0x32>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
  }

  s->state = STATE_NONE;
    4b4c:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    4b4e:	1b 82       	std	Y+3, r1	; 0x03
    4b50:	1a 82       	std	Y+2, r1	; 0x02
    4b52:	82 e0       	ldi	r24, 0x02	; 2
}
    4b54:	df 91       	pop	r29
    4b56:	cf 91       	pop	r28
    4b58:	1f 91       	pop	r17
    4b5a:	08 95       	ret

00004b5c <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    4b5c:	fc 01       	movw	r30, r24
  t->start += t->interval;
    4b5e:	80 81       	ld	r24, Z
    4b60:	91 81       	ldd	r25, Z+1	; 0x01
    4b62:	22 81       	ldd	r18, Z+2	; 0x02
    4b64:	33 81       	ldd	r19, Z+3	; 0x03
    4b66:	82 0f       	add	r24, r18
    4b68:	93 1f       	adc	r25, r19
    4b6a:	91 83       	std	Z+1, r25	; 0x01
    4b6c:	80 83       	st	Z, r24
}
    4b6e:	08 95       	ret

00004b70 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    4b70:	0f 93       	push	r16
    4b72:	1f 93       	push	r17
    4b74:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    4b76:	0e 94 c8 10 	call	0x2190	; 0x2190 <clock_time>
    4b7a:	40 e0       	ldi	r20, 0x00	; 0
    4b7c:	50 e0       	ldi	r21, 0x00	; 0
    4b7e:	f8 01       	movw	r30, r16
    4b80:	20 81       	ld	r18, Z
    4b82:	31 81       	ldd	r19, Z+1	; 0x01
    4b84:	82 1b       	sub	r24, r18
    4b86:	93 0b       	sbc	r25, r19
    4b88:	22 81       	ldd	r18, Z+2	; 0x02
    4b8a:	33 81       	ldd	r19, Z+3	; 0x03
    4b8c:	82 17       	cp	r24, r18
    4b8e:	93 07       	cpc	r25, r19
    4b90:	14 f0       	brlt	.+4      	; 0x4b96 <timer_expired+0x26>
    4b92:	41 e0       	ldi	r20, 0x01	; 1
    4b94:	50 e0       	ldi	r21, 0x00	; 0
}
    4b96:	ca 01       	movw	r24, r20
    4b98:	1f 91       	pop	r17
    4b9a:	0f 91       	pop	r16
    4b9c:	08 95       	ret

00004b9e <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    4b9e:	0f 93       	push	r16
    4ba0:	1f 93       	push	r17
    4ba2:	8c 01       	movw	r16, r24
  t->start = clock_time();
    4ba4:	0e 94 c8 10 	call	0x2190	; 0x2190 <clock_time>
    4ba8:	f8 01       	movw	r30, r16
    4baa:	91 83       	std	Z+1, r25	; 0x01
    4bac:	80 83       	st	Z, r24
}
    4bae:	1f 91       	pop	r17
    4bb0:	0f 91       	pop	r16
    4bb2:	08 95       	ret

00004bb4 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    4bb4:	0f 93       	push	r16
    4bb6:	1f 93       	push	r17
    4bb8:	8c 01       	movw	r16, r24
  t->interval = interval;
    4bba:	fc 01       	movw	r30, r24
    4bbc:	73 83       	std	Z+3, r23	; 0x03
    4bbe:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    4bc0:	0e 94 c8 10 	call	0x2190	; 0x2190 <clock_time>
    4bc4:	f8 01       	movw	r30, r16
    4bc6:	91 83       	std	Z+1, r25	; 0x01
    4bc8:	80 83       	st	Z, r24
}
    4bca:	1f 91       	pop	r17
    4bcc:	0f 91       	pop	r16
    4bce:	08 95       	ret

00004bd0 <uip_neighbor_init>:
static struct neighbor_entry entries[ENTRIES];

/*---------------------------------------------------------------------------*/
void
uip_neighbor_init(void)
{
    4bd0:	ed ef       	ldi	r30, 0xFD	; 253
    4bd2:	f3 e0       	ldi	r31, 0x03	; 3
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    entries[i].time = MAX_TIME;
    4bd4:	80 e8       	ldi	r24, 0x80	; 128
    4bd6:	80 83       	st	Z, r24
    4bd8:	3b 96       	adiw	r30, 0x0b	; 11
void
uip_neighbor_init(void)
{
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    4bda:	94 e0       	ldi	r25, 0x04	; 4
    4bdc:	e5 35       	cpi	r30, 0x55	; 85
    4bde:	f9 07       	cpc	r31, r25
    4be0:	d1 f7       	brne	.-12     	; 0x4bd6 <uip_neighbor_init+0x6>
    entries[i].time = MAX_TIME;
  }
}
    4be2:	08 95       	ret

00004be4 <uip_neighbor_periodic>:
/*---------------------------------------------------------------------------*/
void
uip_neighbor_periodic(void)
{
    4be4:	ed ef       	ldi	r30, 0xFD	; 253
    4be6:	f3 e0       	ldi	r31, 0x03	; 3
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    if(entries[i].time < MAX_TIME) {
    4be8:	80 81       	ld	r24, Z
    4bea:	87 fd       	sbrc	r24, 7
    4bec:	02 c0       	rjmp	.+4      	; 0x4bf2 <uip_neighbor_periodic+0xe>
      entries[i].time++;
    4bee:	8f 5f       	subi	r24, 0xFF	; 255
    4bf0:	80 83       	st	Z, r24
    4bf2:	3b 96       	adiw	r30, 0x0b	; 11
void
uip_neighbor_periodic(void)
{
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    4bf4:	84 e0       	ldi	r24, 0x04	; 4
    4bf6:	e5 35       	cpi	r30, 0x55	; 85
    4bf8:	f8 07       	cpc	r31, r24
    4bfa:	b1 f7       	brne	.-20     	; 0x4be8 <uip_neighbor_periodic+0x4>
    if(entries[i].time < MAX_TIME) {
      entries[i].time++;
    }
  }
}
    4bfc:	08 95       	ret

00004bfe <uip_neighbor_update>:
  return NULL;
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_update(uip_ipaddr_t ipaddr)
{
    4bfe:	dc 01       	movw	r26, r24
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
    4c00:	6d 91       	ld	r22, X+
    4c02:	7c 91       	ld	r23, X
    4c04:	11 97       	sbiw	r26, 0x01	; 1
    4c06:	e3 ef       	ldi	r30, 0xF3	; 243
    4c08:	f3 e0       	ldi	r31, 0x03	; 3
    4c0a:	40 e0       	ldi	r20, 0x00	; 0
    4c0c:	50 e0       	ldi	r21, 0x00	; 0
    4c0e:	80 81       	ld	r24, Z
    4c10:	91 81       	ldd	r25, Z+1	; 0x01
    4c12:	86 17       	cp	r24, r22
    4c14:	97 07       	cpc	r25, r23
    4c16:	b1 f4       	brne	.+44     	; 0x4c44 <uip_neighbor_update+0x46>
    4c18:	22 81       	ldd	r18, Z+2	; 0x02
    4c1a:	33 81       	ldd	r19, Z+3	; 0x03
    4c1c:	12 96       	adiw	r26, 0x02	; 2
    4c1e:	8d 91       	ld	r24, X+
    4c20:	9c 91       	ld	r25, X
    4c22:	13 97       	sbiw	r26, 0x03	; 3
    4c24:	28 17       	cp	r18, r24
    4c26:	39 07       	cpc	r19, r25
    4c28:	69 f4       	brne	.+26     	; 0x4c44 <uip_neighbor_update+0x46>
      return &entries[i];
    4c2a:	8b e0       	ldi	r24, 0x0B	; 11
    4c2c:	90 e0       	ldi	r25, 0x00	; 0
    4c2e:	48 9f       	mul	r20, r24
    4c30:	f0 01       	movw	r30, r0
    4c32:	49 9f       	mul	r20, r25
    4c34:	f0 0d       	add	r31, r0
    4c36:	58 9f       	mul	r21, r24
    4c38:	f0 0d       	add	r31, r0
    4c3a:	11 24       	eor	r1, r1
    4c3c:	ed 50       	subi	r30, 0x0D	; 13
    4c3e:	fc 4f       	sbci	r31, 0xFC	; 252
uip_neighbor_update(uip_ipaddr_t ipaddr)
{
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    4c40:	41 f4       	brne	.+16     	; 0x4c52 <uip_neighbor_update+0x54>
    4c42:	08 95       	ret
static struct neighbor_entry *
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    4c44:	4f 5f       	subi	r20, 0xFF	; 255
    4c46:	5f 4f       	sbci	r21, 0xFF	; 255
    4c48:	3b 96       	adiw	r30, 0x0b	; 11
    4c4a:	48 30       	cpi	r20, 0x08	; 8
    4c4c:	51 05       	cpc	r21, r1
    4c4e:	f9 f6       	brne	.-66     	; 0x4c0e <uip_neighbor_update+0x10>
    4c50:	08 95       	ret
{
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    e->time = 0;
    4c52:	12 86       	std	Z+10, r1	; 0x0a
    4c54:	08 95       	ret

00004c56 <uip_neighbor_lookup>:
  }
}
/*---------------------------------------------------------------------------*/
struct uip_neighbor_addr *
uip_neighbor_lookup(uip_ipaddr_t ipaddr)
{
    4c56:	dc 01       	movw	r26, r24
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
    4c58:	6d 91       	ld	r22, X+
    4c5a:	7c 91       	ld	r23, X
    4c5c:	11 97       	sbiw	r26, 0x01	; 1
    4c5e:	e3 ef       	ldi	r30, 0xF3	; 243
    4c60:	f3 e0       	ldi	r31, 0x03	; 3
    4c62:	40 e0       	ldi	r20, 0x00	; 0
    4c64:	50 e0       	ldi	r21, 0x00	; 0
    4c66:	80 81       	ld	r24, Z
    4c68:	91 81       	ldd	r25, Z+1	; 0x01
    4c6a:	86 17       	cp	r24, r22
    4c6c:	97 07       	cpc	r25, r23
    4c6e:	b1 f4       	brne	.+44     	; 0x4c9c <uip_neighbor_lookup+0x46>
    4c70:	22 81       	ldd	r18, Z+2	; 0x02
    4c72:	33 81       	ldd	r19, Z+3	; 0x03
    4c74:	12 96       	adiw	r26, 0x02	; 2
    4c76:	8d 91       	ld	r24, X+
    4c78:	9c 91       	ld	r25, X
    4c7a:	13 97       	sbiw	r26, 0x03	; 3
    4c7c:	28 17       	cp	r18, r24
    4c7e:	39 07       	cpc	r19, r25
    4c80:	69 f4       	brne	.+26     	; 0x4c9c <uip_neighbor_lookup+0x46>
      return &entries[i];
    4c82:	8b e0       	ldi	r24, 0x0B	; 11
    4c84:	90 e0       	ldi	r25, 0x00	; 0
    4c86:	48 9f       	mul	r20, r24
    4c88:	90 01       	movw	r18, r0
    4c8a:	49 9f       	mul	r20, r25
    4c8c:	30 0d       	add	r19, r0
    4c8e:	58 9f       	mul	r21, r24
    4c90:	30 0d       	add	r19, r0
    4c92:	11 24       	eor	r1, r1
    4c94:	2d 50       	subi	r18, 0x0D	; 13
    4c96:	3c 4f       	sbci	r19, 0xFC	; 252
uip_neighbor_lookup(uip_ipaddr_t ipaddr)
{
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    4c98:	41 f4       	brne	.+16     	; 0x4caa <uip_neighbor_lookup+0x54>
    4c9a:	0a c0       	rjmp	.+20     	; 0x4cb0 <uip_neighbor_lookup+0x5a>
static struct neighbor_entry *
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    4c9c:	4f 5f       	subi	r20, 0xFF	; 255
    4c9e:	5f 4f       	sbci	r21, 0xFF	; 255
    4ca0:	3b 96       	adiw	r30, 0x0b	; 11
    4ca2:	48 30       	cpi	r20, 0x08	; 8
    4ca4:	51 05       	cpc	r21, r1
    4ca6:	f9 f6       	brne	.-66     	; 0x4c66 <uip_neighbor_lookup+0x10>
    4ca8:	03 c0       	rjmp	.+6      	; 0x4cb0 <uip_neighbor_lookup+0x5a>
  if(e != NULL) {
    /*    printf("Lookup neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n",
	   e->addr.addr.addr[0], e->addr.addr.addr[1], e->addr.addr.addr[2], e->addr.addr.addr[3],
	   e->addr.addr.addr[4], e->addr.addr.addr[5]);*/

    return &e->addr;
    4caa:	2c 5f       	subi	r18, 0xFC	; 252
    4cac:	3f 4f       	sbci	r19, 0xFF	; 255
    4cae:	02 c0       	rjmp	.+4      	; 0x4cb4 <uip_neighbor_lookup+0x5e>
    4cb0:	20 e0       	ldi	r18, 0x00	; 0
    4cb2:	30 e0       	ldi	r19, 0x00	; 0
  }
  return NULL;
}
    4cb4:	c9 01       	movw	r24, r18
    4cb6:	08 95       	ret

00004cb8 <uip_neighbor_add>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr)
{
    4cb8:	ef 92       	push	r14
    4cba:	ff 92       	push	r15
    4cbc:	0f 93       	push	r16
    4cbe:	1f 93       	push	r17
    4cc0:	cf 93       	push	r28
    4cc2:	df 93       	push	r29
    4cc4:	ec 01       	movw	r28, r24
    4cc6:	f6 2e       	mov	r15, r22
    4cc8:	e7 2e       	mov	r14, r23
    4cca:	a3 ef       	ldi	r26, 0xF3	; 243
    4ccc:	b3 e0       	ldi	r27, 0x03	; 3
    4cce:	40 e0       	ldi	r20, 0x00	; 0
    4cd0:	50 e0       	ldi	r21, 0x00	; 0
    4cd2:	60 e0       	ldi	r22, 0x00	; 0
    4cd4:	70 e0       	ldi	r23, 0x00	; 0
    4cd6:	00 e0       	ldi	r16, 0x00	; 0
  
  /* Find the first unused entry or the oldest used entry. */
  oldest_time = 0;
  oldest = 0;
  for(i = 0; i < ENTRIES; ++i) {
    if(entries[i].time == MAX_TIME) {
    4cd8:	1a 96       	adiw	r26, 0x0a	; 10
    4cda:	1c 91       	ld	r17, X
    4cdc:	1a 97       	sbiw	r26, 0x0a	; 10
    4cde:	10 38       	cpi	r17, 0x80	; 128
    4ce0:	01 f1       	breq	.+64     	; 0x4d22 <uip_neighbor_add+0x6a>
      oldest = i;
      break;
    }
    if(uip_ipaddr_cmp(entries[i].ipaddr, addr)) {
    4ce2:	ef 2d       	mov	r30, r15
    4ce4:	fe 2d       	mov	r31, r14
    4ce6:	2d 91       	ld	r18, X+
    4ce8:	3c 91       	ld	r19, X
    4cea:	11 97       	sbiw	r26, 0x01	; 1
    4cec:	80 81       	ld	r24, Z
    4cee:	91 81       	ldd	r25, Z+1	; 0x01
    4cf0:	28 17       	cp	r18, r24
    4cf2:	39 07       	cpc	r19, r25
    4cf4:	49 f4       	brne	.+18     	; 0x4d08 <uip_neighbor_add+0x50>
    4cf6:	12 96       	adiw	r26, 0x02	; 2
    4cf8:	2d 91       	ld	r18, X+
    4cfa:	3c 91       	ld	r19, X
    4cfc:	13 97       	sbiw	r26, 0x03	; 3
    4cfe:	82 81       	ldd	r24, Z+2	; 0x02
    4d00:	93 81       	ldd	r25, Z+3	; 0x03
    4d02:	28 17       	cp	r18, r24
    4d04:	39 07       	cpc	r19, r25
    4d06:	69 f0       	breq	.+26     	; 0x4d22 <uip_neighbor_add+0x6a>
      oldest = i;
      break;
    }
    if(entries[i].time > oldest_time) {
    4d08:	01 17       	cp	r16, r17
    4d0a:	10 f0       	brcs	.+4      	; 0x4d10 <uip_neighbor_add+0x58>
    4d0c:	10 2f       	mov	r17, r16
    4d0e:	01 c0       	rjmp	.+2      	; 0x4d12 <uip_neighbor_add+0x5a>
    4d10:	ba 01       	movw	r22, r20
	 //addr->addr.addr[4], addr->addr.addr[5]);
  
  /* Find the first unused entry or the oldest used entry. */
  oldest_time = 0;
  oldest = 0;
  for(i = 0; i < ENTRIES; ++i) {
    4d12:	4f 5f       	subi	r20, 0xFF	; 255
    4d14:	5f 4f       	sbci	r21, 0xFF	; 255
    4d16:	1b 96       	adiw	r26, 0x0b	; 11
    4d18:	48 30       	cpi	r20, 0x08	; 8
    4d1a:	51 05       	cpc	r21, r1
    4d1c:	19 f0       	breq	.+6      	; 0x4d24 <uip_neighbor_add+0x6c>
    4d1e:	01 2f       	mov	r16, r17
    4d20:	db cf       	rjmp	.-74     	; 0x4cd8 <uip_neighbor_add+0x20>
    4d22:	ba 01       	movw	r22, r20
    }
  }

  /* Use the oldest or first free entry (either pointed to by the
     "oldest" variable). */
  entries[oldest].time = 0;
    4d24:	8b e0       	ldi	r24, 0x0B	; 11
    4d26:	90 e0       	ldi	r25, 0x00	; 0
    4d28:	68 9f       	mul	r22, r24
    4d2a:	90 01       	movw	r18, r0
    4d2c:	69 9f       	mul	r22, r25
    4d2e:	30 0d       	add	r19, r0
    4d30:	78 9f       	mul	r23, r24
    4d32:	30 0d       	add	r19, r0
    4d34:	11 24       	eor	r1, r1
    4d36:	f9 01       	movw	r30, r18
    4d38:	ed 50       	subi	r30, 0x0D	; 13
    4d3a:	fc 4f       	sbci	r31, 0xFC	; 252
    4d3c:	12 86       	std	Z+10, r1	; 0x0a
  uip_ipaddr_copy(entries[oldest].ipaddr, ipaddr);
    4d3e:	88 81       	ld	r24, Y
    4d40:	99 81       	ldd	r25, Y+1	; 0x01
    4d42:	91 83       	std	Z+1, r25	; 0x01
    4d44:	80 83       	st	Z, r24
    4d46:	8a 81       	ldd	r24, Y+2	; 0x02
    4d48:	9b 81       	ldd	r25, Y+3	; 0x03
    4d4a:	93 83       	std	Z+3, r25	; 0x03
    4d4c:	82 83       	std	Z+2, r24	; 0x02
  memcpy(&entries[oldest].addr, addr, sizeof(struct uip_neighbor_addr));
    4d4e:	d9 01       	movw	r26, r18
    4d50:	a9 50       	subi	r26, 0x09	; 9
    4d52:	bc 4f       	sbci	r27, 0xFC	; 252
    4d54:	2f 2d       	mov	r18, r15
    4d56:	3e 2d       	mov	r19, r14
    4d58:	c9 01       	movw	r24, r18
    4d5a:	fc 01       	movw	r30, r24
    4d5c:	86 e0       	ldi	r24, 0x06	; 6
    4d5e:	01 90       	ld	r0, Z+
    4d60:	0d 92       	st	X+, r0
    4d62:	81 50       	subi	r24, 0x01	; 1
    4d64:	e1 f7       	brne	.-8      	; 0x4d5e <uip_neighbor_add+0xa6>
}
    4d66:	df 91       	pop	r29
    4d68:	cf 91       	pop	r28
    4d6a:	1f 91       	pop	r17
    4d6c:	0f 91       	pop	r16
    4d6e:	ff 90       	pop	r15
    4d70:	ef 90       	pop	r14
    4d72:	08 95       	ret

00004d74 <httpd_init>:
 *             called at system boot-up.
 */
void
httpd_init(void)
{
  uip_listen(HTONS(80));
    4d74:	80 e0       	ldi	r24, 0x00	; 0
    4d76:	90 e5       	ldi	r25, 0x50	; 80
    4d78:	0e 94 b6 18 	call	0x316c	; 0x316c <uip_listen>
}
    4d7c:	08 95       	ret

00004d7e <send_headers>:
  PT_END(&s->scriptpt);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_headers(struct httpd_state *s, const char *statushdr))
{
    4d7e:	0f 93       	push	r16
    4d80:	1f 93       	push	r17
    4d82:	cf 93       	push	r28
    4d84:	df 93       	push	r29
    4d86:	8c 01       	movw	r16, r24
    4d88:	eb 01       	movw	r28, r22
  char *ptr;
  PSOCK_BEGIN(&s->sout);
    4d8a:	fc 01       	movw	r30, r24
    4d8c:	86 89       	ldd	r24, Z+22	; 0x16
    4d8e:	97 89       	ldd	r25, Z+23	; 0x17
    4d90:	89 3e       	cpi	r24, 0xE9	; 233
    4d92:	91 05       	cpc	r25, r1
    4d94:	09 f4       	brne	.+2      	; 0x4d98 <send_headers+0x1a>
    4d96:	81 c0       	rjmp	.+258    	; 0x4e9a <send_headers+0x11c>
    4d98:	8a 3e       	cpi	r24, 0xEA	; 234
    4d9a:	91 05       	cpc	r25, r1
    4d9c:	88 f4       	brcc	.+34     	; 0x4dc0 <send_headers+0x42>
    4d9e:	8f 3d       	cpi	r24, 0xDF	; 223
    4da0:	91 05       	cpc	r25, r1
    4da2:	41 f1       	breq	.+80     	; 0x4df4 <send_headers+0x76>
    4da4:	80 3e       	cpi	r24, 0xE0	; 224
    4da6:	91 05       	cpc	r25, r1
    4da8:	18 f4       	brcc	.+6      	; 0x4db0 <send_headers+0x32>
    4daa:	89 2b       	or	r24, r25
    4dac:	f1 f0       	breq	.+60     	; 0x4dea <send_headers+0x6c>
    4dae:	d9 c0       	rjmp	.+434    	; 0x4f62 <send_headers+0x1e4>
    4db0:	84 3e       	cpi	r24, 0xE4	; 228
    4db2:	91 05       	cpc	r25, r1
    4db4:	d1 f1       	breq	.+116    	; 0x4e2a <send_headers+0xac>
    4db6:	87 3e       	cpi	r24, 0xE7	; 231
    4db8:	91 05       	cpc	r25, r1
    4dba:	09 f0       	breq	.+2      	; 0x4dbe <send_headers+0x40>
    4dbc:	d2 c0       	rjmp	.+420    	; 0x4f62 <send_headers+0x1e4>
    4dbe:	55 c0       	rjmp	.+170    	; 0x4e6a <send_headers+0xec>
    4dc0:	8d 3e       	cpi	r24, 0xED	; 237
    4dc2:	91 05       	cpc	r25, r1
    4dc4:	09 f4       	brne	.+2      	; 0x4dc8 <send_headers+0x4a>
    4dc6:	99 c0       	rjmp	.+306    	; 0x4efa <send_headers+0x17c>
    4dc8:	8e 3e       	cpi	r24, 0xEE	; 238
    4dca:	91 05       	cpc	r25, r1
    4dcc:	28 f4       	brcc	.+10     	; 0x4dd8 <send_headers+0x5a>
    4dce:	8b 3e       	cpi	r24, 0xEB	; 235
    4dd0:	91 05       	cpc	r25, r1
    4dd2:	09 f0       	breq	.+2      	; 0x4dd6 <send_headers+0x58>
    4dd4:	c6 c0       	rjmp	.+396    	; 0x4f62 <send_headers+0x1e4>
    4dd6:	79 c0       	rjmp	.+242    	; 0x4eca <send_headers+0x14c>
    4dd8:	8f 3e       	cpi	r24, 0xEF	; 239
    4dda:	91 05       	cpc	r25, r1
    4ddc:	09 f4       	brne	.+2      	; 0x4de0 <send_headers+0x62>
    4dde:	a5 c0       	rjmp	.+330    	; 0x4f2a <send_headers+0x1ac>
    4de0:	81 3f       	cpi	r24, 0xF1	; 241
    4de2:	91 05       	cpc	r25, r1
    4de4:	09 f0       	breq	.+2      	; 0x4de8 <send_headers+0x6a>
    4de6:	bd c0       	rjmp	.+378    	; 0x4f62 <send_headers+0x1e4>
    4de8:	af c0       	rjmp	.+350    	; 0x4f48 <send_headers+0x1ca>
  PSOCK_SEND_STR_P(&s->sout, statushdr);
    4dea:	8f ed       	ldi	r24, 0xDF	; 223
    4dec:	90 e0       	ldi	r25, 0x00	; 0
    4dee:	f8 01       	movw	r30, r16
    4df0:	97 8b       	std	Z+23, r25	; 0x17
    4df2:	86 8b       	std	Z+22, r24	; 0x16
    4df4:	ce 01       	movw	r24, r28
    4df6:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4dfa:	ac 01       	movw	r20, r24
    4dfc:	c8 01       	movw	r24, r16
    4dfe:	46 96       	adiw	r24, 0x16	; 22
    4e00:	be 01       	movw	r22, r28
    4e02:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <psock_send_P>
    4e06:	88 23       	and	r24, r24
    4e08:	09 f4       	brne	.+2      	; 0x4e0c <send_headers+0x8e>
    4e0a:	b0 c0       	rjmp	.+352    	; 0x4f6c <send_headers+0x1ee>
	
  ptr = strrchr(s->filename, ISO_period);
    4e0c:	c8 01       	movw	r24, r16
    4e0e:	80 59       	subi	r24, 0x90	; 144
    4e10:	9f 4f       	sbci	r25, 0xFF	; 255
    4e12:	6e e2       	ldi	r22, 0x2E	; 46
    4e14:	70 e0       	ldi	r23, 0x00	; 0
    4e16:	0e 94 70 2f 	call	0x5ee0	; 0x5ee0 <strrchr>
    4e1a:	ec 01       	movw	r28, r24
	
	if(ptr == NULL) {
    4e1c:	00 97       	sbiw	r24, 0x00	; 0
    4e1e:	79 f4       	brne	.+30     	; 0x4e3e <send_headers+0xc0>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_binary);
    4e20:	84 ee       	ldi	r24, 0xE4	; 228
    4e22:	90 e0       	ldi	r25, 0x00	; 0
    4e24:	f8 01       	movw	r30, r16
    4e26:	97 8b       	std	Z+23, r25	; 0x17
    4e28:	86 8b       	std	Z+22, r24	; 0x16
    4e2a:	8a ee       	ldi	r24, 0xEA	; 234
    4e2c:	94 e0       	ldi	r25, 0x04	; 4
    4e2e:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4e32:	ac 01       	movw	r20, r24
    4e34:	c8 01       	movw	r24, r16
    4e36:	46 96       	adiw	r24, 0x16	; 22
    4e38:	6a ee       	ldi	r22, 0xEA	; 234
    4e3a:	74 e0       	ldi	r23, 0x04	; 4
    4e3c:	8e c0       	rjmp	.+284    	; 0x4f5a <send_headers+0x1dc>
  } else if(strncmp_P(ptr, http_html, 5) == 0 ||
    4e3e:	65 e1       	ldi	r22, 0x15	; 21
    4e40:	75 e0       	ldi	r23, 0x05	; 5
    4e42:	45 e0       	ldi	r20, 0x05	; 5
    4e44:	50 e0       	ldi	r21, 0x00	; 0
    4e46:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    4e4a:	89 2b       	or	r24, r25
    4e4c:	49 f0       	breq	.+18     	; 0x4e60 <send_headers+0xe2>
    4e4e:	ce 01       	movw	r24, r28
    4e50:	6b e1       	ldi	r22, 0x1B	; 27
    4e52:	75 e0       	ldi	r23, 0x05	; 5
    4e54:	46 e0       	ldi	r20, 0x06	; 6
    4e56:	50 e0       	ldi	r21, 0x00	; 0
    4e58:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    4e5c:	89 2b       	or	r24, r25
    4e5e:	79 f4       	brne	.+30     	; 0x4e7e <send_headers+0x100>
	    strncmp_P(ptr, http_shtml, 6) == 0) {
	  PSOCK_SEND_STR_P(&s->sout, http_content_type_html);
    4e60:	87 ee       	ldi	r24, 0xE7	; 231
    4e62:	90 e0       	ldi	r25, 0x00	; 0
    4e64:	f8 01       	movw	r30, r16
    4e66:	97 8b       	std	Z+23, r25	; 0x17
    4e68:	86 8b       	std	Z+22, r24	; 0x16
    4e6a:	82 e4       	ldi	r24, 0x42	; 66
    4e6c:	94 e0       	ldi	r25, 0x04	; 4
    4e6e:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4e72:	ac 01       	movw	r20, r24
    4e74:	c8 01       	movw	r24, r16
    4e76:	46 96       	adiw	r24, 0x16	; 22
    4e78:	62 e4       	ldi	r22, 0x42	; 66
    4e7a:	74 e0       	ldi	r23, 0x04	; 4
    4e7c:	6e c0       	rjmp	.+220    	; 0x4f5a <send_headers+0x1dc>
  } else if(strncmp_P(ptr, http_css, 4) == 0) {
    4e7e:	ce 01       	movw	r24, r28
    4e80:	67 e2       	ldi	r22, 0x27	; 39
    4e82:	75 e0       	ldi	r23, 0x05	; 5
    4e84:	44 e0       	ldi	r20, 0x04	; 4
    4e86:	50 e0       	ldi	r21, 0x00	; 0
    4e88:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    4e8c:	89 2b       	or	r24, r25
    4e8e:	79 f4       	brne	.+30     	; 0x4eae <send_headers+0x130>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_css);
    4e90:	89 ee       	ldi	r24, 0xE9	; 233
    4e92:	90 e0       	ldi	r25, 0x00	; 0
    4e94:	f8 01       	movw	r30, r16
    4e96:	97 8b       	std	Z+23, r25	; 0x17
    4e98:	86 8b       	std	Z+22, r24	; 0x16
    4e9a:	8e e5       	ldi	r24, 0x5E	; 94
    4e9c:	94 e0       	ldi	r25, 0x04	; 4
    4e9e:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4ea2:	ac 01       	movw	r20, r24
    4ea4:	c8 01       	movw	r24, r16
    4ea6:	46 96       	adiw	r24, 0x16	; 22
    4ea8:	6e e5       	ldi	r22, 0x5E	; 94
    4eaa:	74 e0       	ldi	r23, 0x04	; 4
    4eac:	56 c0       	rjmp	.+172    	; 0x4f5a <send_headers+0x1dc>
  } else if(strncmp_P(ptr, http_png, 4) == 0) {
    4eae:	ce 01       	movw	r24, r28
    4eb0:	6c e2       	ldi	r22, 0x2C	; 44
    4eb2:	75 e0       	ldi	r23, 0x05	; 5
    4eb4:	44 e0       	ldi	r20, 0x04	; 4
    4eb6:	50 e0       	ldi	r21, 0x00	; 0
    4eb8:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    4ebc:	89 2b       	or	r24, r25
    4ebe:	79 f4       	brne	.+30     	; 0x4ede <send_headers+0x160>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_png);
    4ec0:	8b ee       	ldi	r24, 0xEB	; 235
    4ec2:	90 e0       	ldi	r25, 0x00	; 0
    4ec4:	f8 01       	movw	r30, r16
    4ec6:	97 8b       	std	Z+23, r25	; 0x17
    4ec8:	86 8b       	std	Z+22, r24	; 0x16
    4eca:	85 e9       	ldi	r24, 0x95	; 149
    4ecc:	94 e0       	ldi	r25, 0x04	; 4
    4ece:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4ed2:	ac 01       	movw	r20, r24
    4ed4:	c8 01       	movw	r24, r16
    4ed6:	46 96       	adiw	r24, 0x16	; 22
    4ed8:	65 e9       	ldi	r22, 0x95	; 149
    4eda:	74 e0       	ldi	r23, 0x04	; 4
    4edc:	3e c0       	rjmp	.+124    	; 0x4f5a <send_headers+0x1dc>
  } else if(strncmp_P(ptr, http_gif, 4) == 0) {
    4ede:	ce 01       	movw	r24, r28
    4ee0:	61 e3       	ldi	r22, 0x31	; 49
    4ee2:	75 e0       	ldi	r23, 0x05	; 5
    4ee4:	44 e0       	ldi	r20, 0x04	; 4
    4ee6:	50 e0       	ldi	r21, 0x00	; 0
    4ee8:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    4eec:	89 2b       	or	r24, r25
    4eee:	79 f4       	brne	.+30     	; 0x4f0e <send_headers+0x190>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_gif);
    4ef0:	8d ee       	ldi	r24, 0xED	; 237
    4ef2:	90 e0       	ldi	r25, 0x00	; 0
    4ef4:	f8 01       	movw	r30, r16
    4ef6:	97 8b       	std	Z+23, r25	; 0x17
    4ef8:	86 8b       	std	Z+22, r24	; 0x16
    4efa:	81 eb       	ldi	r24, 0xB1	; 177
    4efc:	94 e0       	ldi	r25, 0x04	; 4
    4efe:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4f02:	ac 01       	movw	r20, r24
    4f04:	c8 01       	movw	r24, r16
    4f06:	46 96       	adiw	r24, 0x16	; 22
    4f08:	61 eb       	ldi	r22, 0xB1	; 177
    4f0a:	74 e0       	ldi	r23, 0x04	; 4
    4f0c:	26 c0       	rjmp	.+76     	; 0x4f5a <send_headers+0x1dc>
  } else if(strncmp_P(ptr, http_jpg, 4) == 0) {
    4f0e:	ce 01       	movw	r24, r28
    4f10:	66 e3       	ldi	r22, 0x36	; 54
    4f12:	75 e0       	ldi	r23, 0x05	; 5
    4f14:	44 e0       	ldi	r20, 0x04	; 4
    4f16:	50 e0       	ldi	r21, 0x00	; 0
    4f18:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    4f1c:	89 2b       	or	r24, r25
    4f1e:	79 f4       	brne	.+30     	; 0x4f3e <send_headers+0x1c0>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_jpg);
    4f20:	8f ee       	ldi	r24, 0xEF	; 239
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	f8 01       	movw	r30, r16
    4f26:	97 8b       	std	Z+23, r25	; 0x17
    4f28:	86 8b       	std	Z+22, r24	; 0x16
    4f2a:	8d ec       	ldi	r24, 0xCD	; 205
    4f2c:	94 e0       	ldi	r25, 0x04	; 4
    4f2e:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4f32:	ac 01       	movw	r20, r24
    4f34:	c8 01       	movw	r24, r16
    4f36:	46 96       	adiw	r24, 0x16	; 22
    4f38:	6d ec       	ldi	r22, 0xCD	; 205
    4f3a:	74 e0       	ldi	r23, 0x04	; 4
    4f3c:	0e c0       	rjmp	.+28     	; 0x4f5a <send_headers+0x1dc>
  } else {
    PSOCK_SEND_STR_P(&s->sout, http_content_type_plain);
    4f3e:	81 ef       	ldi	r24, 0xF1	; 241
    4f40:	90 e0       	ldi	r25, 0x00	; 0
    4f42:	f8 01       	movw	r30, r16
    4f44:	97 8b       	std	Z+23, r25	; 0x17
    4f46:	86 8b       	std	Z+22, r24	; 0x16
    4f48:	85 e2       	ldi	r24, 0x25	; 37
    4f4a:	94 e0       	ldi	r25, 0x04	; 4
    4f4c:	0e 94 12 2f 	call	0x5e24	; 0x5e24 <strlen_P>
    4f50:	ac 01       	movw	r20, r24
    4f52:	c8 01       	movw	r24, r16
    4f54:	46 96       	adiw	r24, 0x16	; 22
    4f56:	65 e2       	ldi	r22, 0x25	; 37
    4f58:	74 e0       	ldi	r23, 0x04	; 4
    4f5a:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <psock_send_P>
    4f5e:	88 23       	and	r24, r24
    4f60:	29 f0       	breq	.+10     	; 0x4f6c <send_headers+0x1ee>
  }
  PSOCK_END(&s->sout);
    4f62:	f8 01       	movw	r30, r16
    4f64:	17 8a       	std	Z+23, r1	; 0x17
    4f66:	16 8a       	std	Z+22, r1	; 0x16
    4f68:	82 e0       	ldi	r24, 0x02	; 2
    4f6a:	01 c0       	rjmp	.+2      	; 0x4f6e <send_headers+0x1f0>
    4f6c:	80 e0       	ldi	r24, 0x00	; 0
}
    4f6e:	df 91       	pop	r29
    4f70:	cf 91       	pop	r28
    4f72:	1f 91       	pop	r17
    4f74:	0f 91       	pop	r16
    4f76:	08 95       	ret

00004f78 <send_file>:
  return s->len;
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_file(struct httpd_state *s))
{
    4f78:	cf 93       	push	r28
    4f7a:	df 93       	push	r29
    4f7c:	ec 01       	movw	r28, r24
	PSOCK_BEGIN(&s->sout);
    4f7e:	8e 89       	ldd	r24, Y+22	; 0x16
    4f80:	9f 89       	ldd	r25, Y+23	; 0x17
    4f82:	00 97       	sbiw	r24, 0x00	; 0
    4f84:	21 f0       	breq	.+8      	; 0x4f8e <send_file+0x16>
    4f86:	83 37       	cpi	r24, 0x73	; 115
    4f88:	91 05       	cpc	r25, r1
    4f8a:	49 f5       	brne	.+82     	; 0x4fde <send_file+0x66>
    4f8c:	04 c0       	rjmp	.+8      	; 0x4f96 <send_file+0x1e>
	//uart_puts_P(PSTR("\n\r\x1B[1mSend File\x1B[0m"));
	do {
    PSOCK_GENERATOR_SEND(&s->sout, generate_part_of_file, s);
    4f8e:	83 e7       	ldi	r24, 0x73	; 115
    4f90:	90 e0       	ldi	r25, 0x00	; 0
    4f92:	9f 8b       	std	Y+23, r25	; 0x17
    4f94:	8e 8b       	std	Y+22, r24	; 0x16
    4f96:	ce 01       	movw	r24, r28
    4f98:	46 96       	adiw	r24, 0x16	; 22
    4f9a:	6a eb       	ldi	r22, 0xBA	; 186
    4f9c:	7a e2       	ldi	r23, 0x2A	; 42
    4f9e:	ae 01       	movw	r20, r28
    4fa0:	0e 94 e4 24 	call	0x49c8	; 0x49c8 <psock_generator_send>
    4fa4:	88 23       	and	r24, r24
    4fa6:	f1 f0       	breq	.+60     	; 0x4fe4 <send_file+0x6c>
    s->file.len -= s->len;
    4fa8:	fe 01       	movw	r30, r28
    4faa:	e9 57       	subi	r30, 0x79	; 121
    4fac:	ff 4f       	sbci	r31, 0xFF	; 255
    4fae:	c7 57       	subi	r28, 0x77	; 119
    4fb0:	df 4f       	sbci	r29, 0xFF	; 255
    4fb2:	20 81       	ld	r18, Z
    4fb4:	31 81       	ldd	r19, Z+1	; 0x01
    4fb6:	48 81       	ld	r20, Y
    4fb8:	59 81       	ldd	r21, Y+1	; 0x01
    4fba:	c9 58       	subi	r28, 0x89	; 137
    4fbc:	d0 40       	sbci	r29, 0x00	; 0
    4fbe:	24 1b       	sub	r18, r20
    4fc0:	35 0b       	sbc	r19, r21
    4fc2:	31 83       	std	Z+1, r19	; 0x01
    4fc4:	20 83       	st	Z, r18
    s->file.data += s->len;
    4fc6:	fe 01       	movw	r30, r28
    4fc8:	eb 57       	subi	r30, 0x7B	; 123
    4fca:	ff 4f       	sbci	r31, 0xFF	; 255
    4fcc:	80 81       	ld	r24, Z
    4fce:	91 81       	ldd	r25, Z+1	; 0x01
    4fd0:	84 0f       	add	r24, r20
    4fd2:	95 1f       	adc	r25, r21
    4fd4:	91 83       	std	Z+1, r25	; 0x01
    4fd6:	80 83       	st	Z, r24
  } while(s->file.len > 0);
    4fd8:	12 16       	cp	r1, r18
    4fda:	13 06       	cpc	r1, r19
    4fdc:	c4 f2       	brlt	.-80     	; 0x4f8e <send_file+0x16>
	PSOCK_END(&s->sout);
    4fde:	1f 8a       	std	Y+23, r1	; 0x17
    4fe0:	1e 8a       	std	Y+22, r1	; 0x16
    4fe2:	82 e0       	ldi	r24, 0x02	; 2
}
    4fe4:	df 91       	pop	r29
    4fe6:	cf 91       	pop	r28
    4fe8:	08 95       	ret

00004fea <handle_connection>:
  PSOCK_END(&s->sin);
}
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
    4fea:	ef 92       	push	r14
    4fec:	ff 92       	push	r15
    4fee:	0f 93       	push	r16
    4ff0:	1f 93       	push	r17
    4ff2:	cf 93       	push	r28
    4ff4:	df 93       	push	r29
    4ff6:	ec 01       	movw	r28, r24
static
PT_THREAD(handle_input(struct httpd_state *s))
{
	unsigned int i;
	
	PSOCK_BEGIN(&s->sin);
    4ff8:	89 81       	ldd	r24, Y+1	; 0x01
    4ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    4ffc:	21 e0       	ldi	r18, 0x01	; 1
    4ffe:	8e 31       	cpi	r24, 0x1E	; 30
    5000:	92 07       	cpc	r25, r18
    5002:	a1 f0       	breq	.+40     	; 0x502c <handle_connection+0x42>
    5004:	a1 e0       	ldi	r26, 0x01	; 1
    5006:	8f 31       	cpi	r24, 0x1F	; 31
    5008:	9a 07       	cpc	r25, r26
    500a:	18 f4       	brcc	.+6      	; 0x5012 <handle_connection+0x28>
    500c:	89 2b       	or	r24, r25
    500e:	51 f0       	breq	.+20     	; 0x5024 <handle_connection+0x3a>
    5010:	be c0       	rjmp	.+380    	; 0x518e <handle_connection+0x1a4>
    5012:	b1 e0       	ldi	r27, 0x01	; 1
    5014:	84 32       	cpi	r24, 0x24	; 36
    5016:	9b 07       	cpc	r25, r27
    5018:	f9 f0       	breq	.+62     	; 0x5058 <handle_connection+0x6e>
    501a:	87 53       	subi	r24, 0x37	; 55
    501c:	91 40       	sbci	r25, 0x01	; 1
    501e:	09 f0       	breq	.+2      	; 0x5022 <handle_connection+0x38>
    5020:	b6 c0       	rjmp	.+364    	; 0x518e <handle_connection+0x1a4>
    5022:	53 c0       	rjmp	.+166    	; 0x50ca <handle_connection+0xe0>
	
  PSOCK_READTO(&s->sin, ISO_space);
    5024:	8e e1       	ldi	r24, 0x1E	; 30
    5026:	91 e0       	ldi	r25, 0x01	; 1
    5028:	9a 83       	std	Y+2, r25	; 0x02
    502a:	89 83       	std	Y+1, r24	; 0x01
    502c:	ce 01       	movw	r24, r28
    502e:	01 96       	adiw	r24, 0x01	; 1
    5030:	60 e2       	ldi	r22, 0x20	; 32
    5032:	0e 94 8b 23 	call	0x4716	; 0x4716 <psock_readto>
    5036:	88 23       	and	r24, r24
    5038:	09 f4       	brne	.+2      	; 0x503c <handle_connection+0x52>
    503a:	ab c0       	rjmp	.+342    	; 0x5192 <handle_connection+0x1a8>

  if(strncmp_P(s->inputbuf, http_get, 4) != 0) 
    503c:	ce 01       	movw	r24, r28
    503e:	8f 96       	adiw	r24, 0x2f	; 47
    5040:	62 e1       	ldi	r22, 0x12	; 18
    5042:	73 e0       	ldi	r23, 0x03	; 3
    5044:	44 e0       	ldi	r20, 0x04	; 4
    5046:	50 e0       	ldi	r21, 0x00	; 0
    5048:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    504c:	89 2b       	or	r24, r25
    504e:	91 f4       	brne	.+36     	; 0x5074 <handle_connection+0x8a>
	{
    PSOCK_CLOSE_EXIT(&s->sin);
  }
  PSOCK_READTO(&s->sin, ISO_space);
    5050:	84 e2       	ldi	r24, 0x24	; 36
    5052:	91 e0       	ldi	r25, 0x01	; 1
    5054:	9a 83       	std	Y+2, r25	; 0x02
    5056:	89 83       	std	Y+1, r24	; 0x01
    5058:	7e 01       	movw	r14, r28
    505a:	08 94       	sec
    505c:	e1 1c       	adc	r14, r1
    505e:	f1 1c       	adc	r15, r1
    5060:	c7 01       	movw	r24, r14
    5062:	60 e2       	ldi	r22, 0x20	; 32
    5064:	0e 94 8b 23 	call	0x4716	; 0x4716 <psock_readto>
    5068:	88 23       	and	r24, r24
    506a:	09 f4       	brne	.+2      	; 0x506e <handle_connection+0x84>
    506c:	92 c0       	rjmp	.+292    	; 0x5192 <handle_connection+0x1a8>
	
  if(s->inputbuf[0] != ISO_slash) 
    506e:	8f a5       	ldd	r24, Y+47	; 0x2f
    5070:	8f 32       	cpi	r24, 0x2F	; 47
    5072:	21 f0       	breq	.+8      	; 0x507c <handle_connection+0x92>
	{
    PSOCK_CLOSE_EXIT(&s->sin);
    5074:	80 e1       	ldi	r24, 0x10	; 16
    5076:	80 93 6d 04 	sts	0x046D, r24
    507a:	89 c0       	rjmp	.+274    	; 0x518e <handle_connection+0x1a4>
  }
	
  if(s->inputbuf[1] == ISO_space) 
    507c:	88 a9       	ldd	r24, Y+48	; 0x30
    507e:	8e 01       	movw	r16, r28
    5080:	00 59       	subi	r16, 0x90	; 144
    5082:	1f 4f       	sbci	r17, 0xFF	; 255
    5084:	80 32       	cpi	r24, 0x20	; 32
    5086:	41 f4       	brne	.+16     	; 0x5098 <handle_connection+0xae>
	{
    strncpy_P(s->filename, http_index_html, sizeof(s->filename));
    5088:	c8 01       	movw	r24, r16
    508a:	67 e5       	ldi	r22, 0x57	; 87
    508c:	73 e0       	ldi	r23, 0x03	; 3
    508e:	44 e1       	ldi	r20, 0x14	; 20
    5090:	50 e0       	ldi	r21, 0x00	; 0
    5092:	0e 94 29 2f 	call	0x5e52	; 0x5e52 <strncpy_P>
    5096:	0f c0       	rjmp	.+30     	; 0x50b6 <handle_connection+0xcc>
  } 
	else 
	{
    s->inputbuf[PSOCK_DATALEN(&s->sin) - 1] = 0;
    5098:	c7 01       	movw	r24, r14
    509a:	0e 94 6d 23 	call	0x46da	; 0x46da <psock_datalen>
    509e:	fe 01       	movw	r30, r28
    50a0:	e8 0f       	add	r30, r24
    50a2:	f9 1f       	adc	r31, r25
    50a4:	16 a6       	std	Z+46, r1	; 0x2e
    strncpy(s->filename, &s->inputbuf[0], sizeof(s->filename));
    50a6:	be 01       	movw	r22, r28
    50a8:	61 5d       	subi	r22, 0xD1	; 209
    50aa:	7f 4f       	sbci	r23, 0xFF	; 255
    50ac:	c8 01       	movw	r24, r16
    50ae:	44 e1       	ldi	r20, 0x14	; 20
    50b0:	50 e0       	ldi	r21, 0x00	; 0
    50b2:	0e 94 61 2f 	call	0x5ec2	; 0x5ec2 <strncpy>
  }
	s->state = STATE_OUTPUT;
    50b6:	cc 57       	subi	r28, 0x7C	; 124
    50b8:	df 4f       	sbci	r29, 0xFF	; 255
    50ba:	81 e0       	ldi	r24, 0x01	; 1
    50bc:	88 83       	st	Y, r24
    50be:	c4 58       	subi	r28, 0x84	; 132
    50c0:	d0 40       	sbci	r29, 0x00	; 0
	while(1) 
	{
    PSOCK_READTO(&s->sin, ISO_nl);
    50c2:	87 e3       	ldi	r24, 0x37	; 55
    50c4:	91 e0       	ldi	r25, 0x01	; 1
    50c6:	9a 83       	std	Y+2, r25	; 0x02
    50c8:	89 83       	std	Y+1, r24	; 0x01
    50ca:	7e 01       	movw	r14, r28
    50cc:	08 94       	sec
    50ce:	e1 1c       	adc	r14, r1
    50d0:	f1 1c       	adc	r15, r1
    50d2:	c7 01       	movw	r24, r14
    50d4:	6a e0       	ldi	r22, 0x0A	; 10
    50d6:	0e 94 8b 23 	call	0x4716	; 0x4716 <psock_readto>
    50da:	88 23       	and	r24, r24
    50dc:	09 f4       	brne	.+2      	; 0x50e0 <handle_connection+0xf6>
    50de:	59 c0       	rjmp	.+178    	; 0x5192 <handle_connection+0x1a8>
	  if(strncmp_P(s->inputbuf, http_referer, 8) == 0) 
    50e0:	8e 01       	movw	r16, r28
    50e2:	01 5d       	subi	r16, 0xD1	; 209
    50e4:	1f 4f       	sbci	r17, 0xFF	; 255
    50e6:	c8 01       	movw	r24, r16
    50e8:	6d e6       	ldi	r22, 0x6D	; 109
    50ea:	73 e0       	ldi	r23, 0x03	; 3
    50ec:	48 e0       	ldi	r20, 0x08	; 8
    50ee:	50 e0       	ldi	r21, 0x00	; 0
    50f0:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    50f4:	89 2b       	or	r24, r25
    50f6:	29 f7       	brne	.-54     	; 0x50c2 <handle_connection+0xd8>
		{
      s->inputbuf[PSOCK_DATALEN(&s->sin) - 2] = 0;
    50f8:	c7 01       	movw	r24, r14
    50fa:	0e 94 6d 23 	call	0x46da	; 0x46da <psock_datalen>
    50fe:	fe 01       	movw	r30, r28
    5100:	e8 0f       	add	r30, r24
    5102:	f9 1f       	adc	r31, r25
    5104:	15 a6       	std	Z+45, r1	; 0x2d
			//uart_puts(">>http_referer<<\r\n");
			uart_puts(s->inputbuf);
    5106:	c8 01       	movw	r24, r16
    5108:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
			uart_puts("\r\n");
    510c:	85 e1       	ldi	r24, 0x15	; 21
    510e:	92 e0       	ldi	r25, 0x02	; 2
    5110:	0e 94 50 10 	call	0x20a0	; 0x20a0 <uart_puts>
    5114:	f8 01       	movw	r30, r16
    5116:	00 e0       	ldi	r16, 0x00	; 0
    5118:	10 e0       	ldi	r17, 0x00	; 0
    511a:	02 c0       	rjmp	.+4      	; 0x5120 <handle_connection+0x136>
      /*      httpd_log(&s->inputbuf[9]);*/
			// check URL for '?'
			for (i=0;((s->inputbuf[i]!=0) && (s->inputbuf[i]!='?'));i++);
    511c:	0f 5f       	subi	r16, 0xFF	; 255
    511e:	1f 4f       	sbci	r17, 0xFF	; 255
    5120:	80 81       	ld	r24, Z
    5122:	88 23       	and	r24, r24
    5124:	71 f2       	breq	.-100    	; 0x50c2 <handle_connection+0xd8>
    5126:	31 96       	adiw	r30, 0x01	; 1
    5128:	8f 33       	cpi	r24, 0x3F	; 63
    512a:	c1 f7       	brne	.-16     	; 0x511c <handle_connection+0x132>
    512c:	b9 c1       	rjmp	.+882    	; 0x54a0 <handle_connection+0x4b6>
			{
			uart_puts_P(PSTR("found ?\r\n"));
				// compare path / file
				if(strncmp(s->inputbuf+i-strlen("io.shtml"), "io.shtml", strlen("io.shtml")) == 0)
				{
					uart_puts_P(PSTR("found io.shtml\r\n"));
    512e:	87 ed       	ldi	r24, 0xD7	; 215
    5130:	92 e0       	ldi	r25, 0x02	; 2
    5132:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
					// compare query
					if(strncmp(s->inputbuf+i+1, "LED1=1", strlen("LED1=1")) == 0)
    5136:	78 01       	movw	r14, r16
    5138:	08 94       	sec
    513a:	e1 1c       	adc	r14, r1
    513c:	f1 1c       	adc	r15, r1
    513e:	00 5d       	subi	r16, 0xD0	; 208
    5140:	1f 4f       	sbci	r17, 0xFF	; 255
    5142:	ce 01       	movw	r24, r28
    5144:	80 0f       	add	r24, r16
    5146:	91 1f       	adc	r25, r17
    5148:	68 e1       	ldi	r22, 0x18	; 24
    514a:	72 e0       	ldi	r23, 0x02	; 2
    514c:	46 e0       	ldi	r20, 0x06	; 6
    514e:	50 e0       	ldi	r21, 0x00	; 0
    5150:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <strncmp>
    5154:	00 97       	sbiw	r24, 0x00	; 0
    5156:	29 f4       	brne	.+10     	; 0x5162 <handle_connection+0x178>
					{
						// LED1=1
						PORTC &= ~(1<<PC0); // clear PC0 = LED ON
    5158:	40 98       	cbi	0x08, 0	; 8
						
						uart_puts_P(PSTR("LED=1\r\n"));
    515a:	8f ec       	ldi	r24, 0xCF	; 207
    515c:	92 e0       	ldi	r25, 0x02	; 2
    515e:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>

					}
					if(strncmp(s->inputbuf+i+1, "LED1=0",strlen("LED1=0")) == 0)
    5162:	8f e2       	ldi	r24, 0x2F	; 47
    5164:	90 e0       	ldi	r25, 0x00	; 0
    5166:	e8 0e       	add	r14, r24
    5168:	f9 1e       	adc	r15, r25
    516a:	ce 01       	movw	r24, r28
    516c:	8e 0d       	add	r24, r14
    516e:	9f 1d       	adc	r25, r15
    5170:	6f e1       	ldi	r22, 0x1F	; 31
    5172:	72 e0       	ldi	r23, 0x02	; 2
    5174:	46 e0       	ldi	r20, 0x06	; 6
    5176:	50 e0       	ldi	r21, 0x00	; 0
    5178:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <strncmp>
    517c:	00 97       	sbiw	r24, 0x00	; 0
    517e:	09 f0       	breq	.+2      	; 0x5182 <handle_connection+0x198>
    5180:	a0 cf       	rjmp	.-192    	; 0x50c2 <handle_connection+0xd8>
					{
						// LED1=0
						PORTC |= (1<<PC0); // set PC0 = LED OFF
    5182:	40 9a       	sbi	0x08, 0	; 8
						uart_puts_P(PSTR("LED=0\r\n"));
    5184:	87 ec       	ldi	r24, 0xC7	; 199
    5186:	92 e0       	ldi	r25, 0x02	; 2
    5188:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    518c:	9a cf       	rjmp	.-204    	; 0x50c2 <handle_connection+0xd8>
				}
			}
    }
  }
  
  PSOCK_END(&s->sin);
    518e:	1a 82       	std	Y+2, r1	; 0x02
    5190:	19 82       	std	Y+1, r1	; 0x01
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
  handle_input(s);
  if(s->state == STATE_OUTPUT) {
    5192:	cc 57       	subi	r28, 0x7C	; 124
    5194:	df 4f       	sbci	r29, 0xFF	; 255
    5196:	88 81       	ld	r24, Y
    5198:	c4 58       	subi	r28, 0x84	; 132
    519a:	d0 40       	sbci	r29, 0x00	; 0
    519c:	81 30       	cpi	r24, 0x01	; 1
    519e:	09 f0       	breq	.+2      	; 0x51a2 <handle_connection+0x1b8>
    51a0:	91 c1       	rjmp	.+802    	; 0x54c4 <handle_connection+0x4da>
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_output(struct httpd_state *s))
{
	char *ptr;
  PT_BEGIN(&s->outputpt);
    51a2:	8b a5       	ldd	r24, Y+43	; 0x2b
    51a4:	9c a5       	ldd	r25, Y+44	; 0x2c
    51a6:	a1 e0       	ldi	r26, 0x01	; 1
    51a8:	81 30       	cpi	r24, 0x01	; 1
    51aa:	9a 07       	cpc	r25, r26
    51ac:	09 f4       	brne	.+2      	; 0x51b0 <handle_connection+0x1c6>
    51ae:	6d c1       	rjmp	.+730    	; 0x548a <handle_connection+0x4a0>
    51b0:	b1 e0       	ldi	r27, 0x01	; 1
    51b2:	82 30       	cpi	r24, 0x02	; 2
    51b4:	9b 07       	cpc	r25, r27
    51b6:	38 f4       	brcc	.+14     	; 0x51c6 <handle_connection+0x1dc>
    51b8:	00 97       	sbiw	r24, 0x00	; 0
    51ba:	a1 f0       	breq	.+40     	; 0x51e4 <handle_connection+0x1fa>
    51bc:	80 50       	subi	r24, 0x00	; 0
    51be:	91 40       	sbci	r25, 0x01	; 1
    51c0:	09 f0       	breq	.+2      	; 0x51c4 <handle_connection+0x1da>
    51c2:	6b c1       	rjmp	.+726    	; 0x549a <handle_connection+0x4b0>
    51c4:	2b c0       	rjmp	.+86     	; 0x521c <handle_connection+0x232>
    51c6:	f1 e0       	ldi	r31, 0x01	; 1
    51c8:	8c 30       	cpi	r24, 0x0C	; 12
    51ca:	9f 07       	cpc	r25, r31
    51cc:	09 f4       	brne	.+2      	; 0x51d0 <handle_connection+0x1e6>
    51ce:	56 c0       	rjmp	.+172    	; 0x527c <handle_connection+0x292>
    51d0:	21 e0       	ldi	r18, 0x01	; 1
    51d2:	80 31       	cpi	r24, 0x10	; 16
    51d4:	92 07       	cpc	r25, r18
    51d6:	09 f4       	brne	.+2      	; 0x51da <handle_connection+0x1f0>
    51d8:	58 c1       	rjmp	.+688    	; 0x548a <handle_connection+0x4a0>
    51da:	85 50       	subi	r24, 0x05	; 5
    51dc:	91 40       	sbci	r25, 0x01	; 1
    51de:	09 f0       	breq	.+2      	; 0x51e2 <handle_connection+0x1f8>
    51e0:	5c c1       	rjmp	.+696    	; 0x549a <handle_connection+0x4b0>
    51e2:	2b c0       	rjmp	.+86     	; 0x523a <handle_connection+0x250>
	//uart_puts_P(PSTR("\n\r\x1B[1mHandle Output\x1B[0m"));
  if(!httpd_fs_open(s->filename, &s->file))
    51e4:	90 e7       	ldi	r25, 0x70	; 112
    51e6:	e9 2e       	mov	r14, r25
    51e8:	f1 2c       	mov	r15, r1
    51ea:	ec 0e       	add	r14, r28
    51ec:	fd 1e       	adc	r15, r29
    51ee:	8e 01       	movw	r16, r28
    51f0:	0b 57       	subi	r16, 0x7B	; 123
    51f2:	1f 4f       	sbci	r17, 0xFF	; 255
    51f4:	c7 01       	movw	r24, r14
    51f6:	b8 01       	movw	r22, r16
    51f8:	0e 94 04 2b 	call	0x5608	; 0x5608 <httpd_fs_open>
    51fc:	89 2b       	or	r24, r25
    51fe:	c9 f4       	brne	.+50     	; 0x5232 <handle_connection+0x248>
	{
    httpd_fs_open_P(http_404_html, &s->file);
    5200:	83 e6       	ldi	r24, 0x63	; 99
    5202:	93 e0       	ldi	r25, 0x03	; 3
    5204:	b8 01       	movw	r22, r16
    5206:	0e 94 44 2b 	call	0x5688	; 0x5688 <httpd_fs_open_P>
    strcpy_P(s->filename, http_404_html);
    520a:	c7 01       	movw	r24, r14
    520c:	63 e6       	ldi	r22, 0x63	; 99
    520e:	73 e0       	ldi	r23, 0x03	; 3
    5210:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <strcpy_P>
    PT_WAIT_THREAD(&s->outputpt,send_headers(s,http_header_404));
    5214:	80 e0       	ldi	r24, 0x00	; 0
    5216:	91 e0       	ldi	r25, 0x01	; 1
    5218:	9c a7       	std	Y+44, r25	; 0x2c
    521a:	8b a7       	std	Y+43, r24	; 0x2b
    521c:	ce 01       	movw	r24, r28
    521e:	6a ec       	ldi	r22, 0xCA	; 202
    5220:	73 e0       	ldi	r23, 0x03	; 3
    5222:	0e 94 bf 26 	call	0x4d7e	; 0x4d7e <send_headers>
    5226:	88 23       	and	r24, r24
    5228:	09 f4       	brne	.+2      	; 0x522c <handle_connection+0x242>
    522a:	4c c1       	rjmp	.+664    	; 0x54c4 <handle_connection+0x4da>
    PT_WAIT_THREAD(&s->outputpt,send_file(s));
    522c:	81 e0       	ldi	r24, 0x01	; 1
    522e:	91 e0       	ldi	r25, 0x01	; 1
    5230:	2a c1       	rjmp	.+596    	; 0x5486 <handle_connection+0x49c>
  } 
	else 
	{
    PT_WAIT_THREAD(&s->outputpt,send_headers(s,http_header_200));
    5232:	85 e0       	ldi	r24, 0x05	; 5
    5234:	91 e0       	ldi	r25, 0x01	; 1
    5236:	9c a7       	std	Y+44, r25	; 0x2c
    5238:	8b a7       	std	Y+43, r24	; 0x2b
    523a:	ce 01       	movw	r24, r28
    523c:	66 e7       	ldi	r22, 0x76	; 118
    523e:	73 e0       	ldi	r23, 0x03	; 3
    5240:	0e 94 bf 26 	call	0x4d7e	; 0x4d7e <send_headers>
    5244:	88 23       	and	r24, r24
    5246:	09 f4       	brne	.+2      	; 0x524a <handle_connection+0x260>
    5248:	3d c1       	rjmp	.+634    	; 0x54c4 <handle_connection+0x4da>
		
		// s->filename = RAM
    ptr = strchr(s->filename, ISO_period);
    524a:	ce 01       	movw	r24, r28
    524c:	80 59       	subi	r24, 0x90	; 144
    524e:	9f 4f       	sbci	r25, 0xFF	; 255
    5250:	6e e2       	ldi	r22, 0x2E	; 46
    5252:	70 e0       	ldi	r23, 0x00	; 0
    5254:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <strchr>
    if(ptr != NULL && strncmp_P(ptr, http_shtml, 6) == 0) 
    5258:	00 97       	sbiw	r24, 0x00	; 0
    525a:	09 f4       	brne	.+2      	; 0x525e <handle_connection+0x274>
    525c:	12 c1       	rjmp	.+548    	; 0x5482 <handle_connection+0x498>
    525e:	6b e1       	ldi	r22, 0x1B	; 27
    5260:	75 e0       	ldi	r23, 0x05	; 5
    5262:	46 e0       	ldi	r20, 0x06	; 6
    5264:	50 e0       	ldi	r21, 0x00	; 0
    5266:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    526a:	89 2b       	or	r24, r25
    526c:	09 f0       	breq	.+2      	; 0x5270 <handle_connection+0x286>
    526e:	09 c1       	rjmp	.+530    	; 0x5482 <handle_connection+0x498>
		{
      PT_INIT(&s->scriptpt);
    5270:	1e a6       	std	Y+46, r1	; 0x2e
    5272:	1d a6       	std	Y+45, r1	; 0x2d
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    5274:	8c e0       	ldi	r24, 0x0C	; 12
    5276:	91 e0       	ldi	r25, 0x01	; 1
    5278:	9c a7       	std	Y+44, r25	; 0x2c
    527a:	8b a7       	std	Y+43, r24	; 0x2b
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
	PT_BEGIN(&s->scriptpt);
    527c:	8d a5       	ldd	r24, Y+45	; 0x2d
    527e:	9e a5       	ldd	r25, Y+46	; 0x2e
    5280:	8f 3a       	cpi	r24, 0xAF	; 175
    5282:	91 05       	cpc	r25, r1
    5284:	09 f4       	brne	.+2      	; 0x5288 <handle_connection+0x29e>
    5286:	3d c0       	rjmp	.+122    	; 0x5302 <handle_connection+0x318>
    5288:	80 3b       	cpi	r24, 0xB0	; 176
    528a:	91 05       	cpc	r25, r1
    528c:	18 f4       	brcc	.+6      	; 0x5294 <handle_connection+0x2aa>
    528e:	89 2b       	or	r24, r25
    5290:	51 f0       	breq	.+20     	; 0x52a6 <handle_connection+0x2bc>
    5292:	f4 c0       	rjmp	.+488    	; 0x547c <handle_connection+0x492>
    5294:	82 3b       	cpi	r24, 0xB2	; 178
    5296:	91 05       	cpc	r25, r1
    5298:	09 f4       	brne	.+2      	; 0x529c <handle_connection+0x2b2>
    529a:	3b c0       	rjmp	.+118    	; 0x5312 <handle_connection+0x328>
    529c:	81 3d       	cpi	r24, 0xD1	; 209
    529e:	91 05       	cpc	r25, r1
    52a0:	09 f0       	breq	.+2      	; 0x52a4 <handle_connection+0x2ba>
    52a2:	ec c0       	rjmp	.+472    	; 0x547c <handle_connection+0x492>
    52a4:	ab c0       	rjmp	.+342    	; 0x53fc <handle_connection+0x412>
	uart_puts_P(PSTR("\r\nSCRIPT"));
    52a6:	82 ef       	ldi	r24, 0xF2	; 242
    52a8:	92 e0       	ldi	r25, 0x02	; 2
    52aa:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
    52ae:	dc c0       	rjmp	.+440    	; 0x5468 <handle_connection+0x47e>
	while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if((pgm_read_byte(s->file.data) == ISO_percent) &&
    52b0:	de 01       	movw	r26, r28
    52b2:	ab 57       	subi	r26, 0x7B	; 123
    52b4:	bf 4f       	sbci	r27, 0xFF	; 255
    52b6:	ed 91       	ld	r30, X+
    52b8:	fc 91       	ld	r31, X
    52ba:	11 97       	sbiw	r26, 0x01	; 1
    52bc:	84 91       	lpm	r24, Z+
    52be:	85 32       	cpi	r24, 0x25	; 37
    52c0:	09 f0       	breq	.+2      	; 0x52c4 <handle_connection+0x2da>
    52c2:	5d c0       	rjmp	.+186    	; 0x537e <handle_connection+0x394>
       (pgm_read_byte(s->file.data + 1) == ISO_bang)) {
    52c4:	31 96       	adiw	r30, 0x01	; 1
    52c6:	84 91       	lpm	r24, Z+
    52c8:	31 97       	sbiw	r30, 0x01	; 1
	PT_BEGIN(&s->scriptpt);
	uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if((pgm_read_byte(s->file.data) == ISO_percent) &&
    52ca:	81 32       	cpi	r24, 0x21	; 33
    52cc:	09 f0       	breq	.+2      	; 0x52d0 <handle_connection+0x2e6>
    52ce:	57 c0       	rjmp	.+174    	; 0x537e <handle_connection+0x394>
       (pgm_read_byte(s->file.data + 1) == ISO_bang)) {
      s->scriptptr = s->file.data + 3;
    52d0:	c5 57       	subi	r28, 0x75	; 117
    52d2:	df 4f       	sbci	r29, 0xFF	; 255
    52d4:	33 96       	adiw	r30, 0x03	; 3
    52d6:	e9 93       	st	Y+, r30
    52d8:	f9 93       	st	Y+, r31
      s->scriptlen = s->file.len - 3;
    52da:	23 50       	subi	r18, 0x03	; 3
    52dc:	30 40       	sbci	r19, 0x00	; 0
    52de:	39 83       	std	Y+1, r19	; 0x01
    52e0:	28 83       	st	Y, r18
    52e2:	cd 58       	subi	r28, 0x8D	; 141
    52e4:	d0 40       	sbci	r29, 0x00	; 0
			if(pgm_read_byte(s->scriptptr - 1) == ISO_colon) {
    52e6:	31 97       	sbiw	r30, 0x01	; 1
    52e8:	84 91       	lpm	r24, Z+
    52ea:	32 97       	sbiw	r30, 0x02	; 2
    52ec:	8a 33       	cpi	r24, 0x3A	; 58
    52ee:	69 f4       	brne	.+26     	; 0x530a <handle_connection+0x320>

				httpd_fs_open_P(s->scriptptr + 1, &s->file);
    52f0:	cf 01       	movw	r24, r30
    52f2:	04 96       	adiw	r24, 0x04	; 4
    52f4:	bd 01       	movw	r22, r26
    52f6:	0e 94 44 2b 	call	0x5688	; 0x5688 <httpd_fs_open_P>
			PT_WAIT_THREAD(&s->scriptpt, send_file(s));
    52fa:	8f ea       	ldi	r24, 0xAF	; 175
    52fc:	90 e0       	ldi	r25, 0x00	; 0
    52fe:	9e a7       	std	Y+46, r25	; 0x2e
    5300:	8d a7       	std	Y+45, r24	; 0x2d
    5302:	ce 01       	movw	r24, r28
    5304:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <send_file>
    5308:	12 c0       	rjmp	.+36     	; 0x532e <handle_connection+0x344>
			
      } else {
				PT_WAIT_THREAD(&s->scriptpt, httpd_cgi(s->scriptptr)(s, s->scriptptr));
    530a:	82 eb       	ldi	r24, 0xB2	; 178
    530c:	90 e0       	ldi	r25, 0x00	; 0
    530e:	9e a7       	std	Y+46, r25	; 0x2e
    5310:	8d a7       	std	Y+45, r24	; 0x2d
    5312:	8e 01       	movw	r16, r28
    5314:	05 57       	subi	r16, 0x75	; 117
    5316:	1f 4f       	sbci	r17, 0xFF	; 255
    5318:	f8 01       	movw	r30, r16
    531a:	80 81       	ld	r24, Z
    531c:	91 81       	ldd	r25, Z+1	; 0x01
    531e:	0e 94 cf 2b 	call	0x579e	; 0x579e <httpd_cgi>
    5322:	fc 01       	movw	r30, r24
    5324:	d8 01       	movw	r26, r16
    5326:	6d 91       	ld	r22, X+
    5328:	7c 91       	ld	r23, X
    532a:	ce 01       	movw	r24, r28
    532c:	09 95       	icall
    532e:	88 23       	and	r24, r24
    5330:	09 f4       	brne	.+2      	; 0x5334 <handle_connection+0x34a>
    5332:	c8 c0       	rjmp	.+400    	; 0x54c4 <handle_connection+0x4da>
/*---------------------------------------------------------------------------*/
static void
next_scriptstate(struct httpd_state *s)
{
  char *p;
  p = (char *) strchr_P(s->scriptptr, ISO_nl) + 1;
    5334:	8b e8       	ldi	r24, 0x8B	; 139
    5336:	e8 2e       	mov	r14, r24
    5338:	f1 2c       	mov	r15, r1
    533a:	ec 0e       	add	r14, r28
    533c:	fd 1e       	adc	r15, r29
    533e:	f7 01       	movw	r30, r14
    5340:	00 81       	ld	r16, Z
    5342:	11 81       	ldd	r17, Z+1	; 0x01
    5344:	c8 01       	movw	r24, r16
    5346:	6a e0       	ldi	r22, 0x0A	; 10
    5348:	70 e0       	ldi	r23, 0x00	; 0
    534a:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <strchr_P>
    534e:	01 96       	adiw	r24, 0x01	; 1
  s->scriptlen -= (unsigned short)(p - s->scriptptr);
    5350:	fe 01       	movw	r30, r28
    5352:	e3 57       	subi	r30, 0x73	; 115
    5354:	ff 4f       	sbci	r31, 0xFF	; 255
    5356:	08 1b       	sub	r16, r24
    5358:	19 0b       	sbc	r17, r25
    535a:	20 81       	ld	r18, Z
    535c:	31 81       	ldd	r19, Z+1	; 0x01
    535e:	02 0f       	add	r16, r18
    5360:	13 1f       	adc	r17, r19
    5362:	11 83       	std	Z+1, r17	; 0x01
    5364:	00 83       	st	Z, r16
  s->scriptptr = p;
    5366:	d7 01       	movw	r26, r14
    5368:	8d 93       	st	X+, r24
    536a:	9c 93       	st	X, r25
      }
      next_scriptstate(s);
      
      /* The script is over, so we reset the pointers and continue
			sending the rest of the file. */
      s->file.data = s->scriptptr;
    536c:	cb 57       	subi	r28, 0x7B	; 123
    536e:	df 4f       	sbci	r29, 0xFF	; 255
    5370:	89 93       	st	Y+, r24
    5372:	99 93       	st	Y+, r25
      s->file.len = s->scriptlen;
    5374:	19 83       	std	Y+1, r17	; 0x01
    5376:	08 83       	st	Y, r16
    5378:	c7 58       	subi	r28, 0x87	; 135
    537a:	d0 40       	sbci	r29, 0x00	; 0
    537c:	75 c0       	rjmp	.+234    	; 0x5468 <handle_connection+0x47e>
    } else {
      /* See if we find the start of script marker in the block of HTML
	 to be sent. */
			//uart_puts_P(PSTR("\n\r\x1B[1mscript marker\x1B[0m"));
      if(s->file.len > uip_mss()) {
    537e:	e0 91 70 04 	lds	r30, 0x0470
    5382:	f0 91 71 04 	lds	r31, 0x0471
    5386:	82 89       	ldd	r24, Z+18	; 0x12
    5388:	93 89       	ldd	r25, Z+19	; 0x13
    538a:	fe 01       	movw	r30, r28
    538c:	e7 57       	subi	r30, 0x77	; 119
    538e:	ff 4f       	sbci	r31, 0xFF	; 255
    5390:	82 17       	cp	r24, r18
    5392:	93 07       	cpc	r25, r19
    5394:	18 f4       	brcc	.+6      	; 0x539c <handle_connection+0x3b2>
				s->len = uip_mss();
    5396:	91 83       	std	Z+1, r25	; 0x01
    5398:	80 83       	st	Z, r24
    539a:	02 c0       	rjmp	.+4      	; 0x53a0 <handle_connection+0x3b6>
      } else {
				s->len = s->file.len;
    539c:	31 83       	std	Z+1, r19	; 0x01
    539e:	20 83       	st	Z, r18
      }

			if(pgm_read_byte(s->file.data) == ISO_percent) {
    53a0:	cb 57       	subi	r28, 0x7B	; 123
    53a2:	df 4f       	sbci	r29, 0xFF	; 255
    53a4:	08 81       	ld	r16, Y
    53a6:	19 81       	ldd	r17, Y+1	; 0x01
    53a8:	c5 58       	subi	r28, 0x85	; 133
    53aa:	d0 40       	sbci	r29, 0x00	; 0
    53ac:	f8 01       	movw	r30, r16
    53ae:	84 91       	lpm	r24, Z+
    53b0:	85 32       	cpi	r24, 0x25	; 37
    53b2:	19 f4       	brne	.+6      	; 0x53ba <handle_connection+0x3d0>
				ptr = (char *) strchr_P(s->file.data + 1, ISO_percent);
    53b4:	c8 01       	movw	r24, r16
    53b6:	01 96       	adiw	r24, 0x01	; 1
    53b8:	01 c0       	rjmp	.+2      	; 0x53bc <handle_connection+0x3d2>
      } else {
				ptr = (char *) strchr_P(s->file.data, ISO_percent); 
    53ba:	c8 01       	movw	r24, r16
    53bc:	65 e2       	ldi	r22, 0x25	; 37
    53be:	70 e0       	ldi	r23, 0x00	; 0
    53c0:	0e 94 f7 2e 	call	0x5dee	; 0x5dee <strchr_P>
      }
      if(ptr != NULL && ptr != s->file.data) {
    53c4:	00 97       	sbiw	r24, 0x00	; 0
    53c6:	b1 f0       	breq	.+44     	; 0x53f4 <handle_connection+0x40a>
    53c8:	80 17       	cp	r24, r16
    53ca:	91 07       	cpc	r25, r17
    53cc:	99 f0       	breq	.+38     	; 0x53f4 <handle_connection+0x40a>
				s->len = (int)(ptr - s->file.data);
    53ce:	80 1b       	sub	r24, r16
    53d0:	91 0b       	sbc	r25, r17
    53d2:	de 01       	movw	r26, r28
    53d4:	a7 57       	subi	r26, 0x77	; 119
    53d6:	bf 4f       	sbci	r27, 0xFF	; 255
    53d8:	11 96       	adiw	r26, 0x01	; 1
    53da:	9c 93       	st	X, r25
    53dc:	8e 93       	st	-X, r24
				if(s->len >= uip_mss()) {
    53de:	e0 91 70 04 	lds	r30, 0x0470
    53e2:	f0 91 71 04 	lds	r31, 0x0471
    53e6:	22 89       	ldd	r18, Z+18	; 0x12
    53e8:	33 89       	ldd	r19, Z+19	; 0x13
    53ea:	82 17       	cp	r24, r18
    53ec:	93 07       	cpc	r25, r19
    53ee:	10 f0       	brcs	.+4      	; 0x53f4 <handle_connection+0x40a>
					s->len = uip_mss();
    53f0:	2d 93       	st	X+, r18
    53f2:	3c 93       	st	X, r19
				}
      }
			//uart_puts_P(PSTR("\n\r\x1B[1msend ???\x1B[0m"));
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
    53f4:	81 ed       	ldi	r24, 0xD1	; 209
    53f6:	90 e0       	ldi	r25, 0x00	; 0
    53f8:	9e a7       	std	Y+46, r25	; 0x2e
    53fa:	8d a7       	std	Y+45, r24	; 0x2d
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_part_of_file(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sout);
    53fc:	8e 89       	ldd	r24, Y+22	; 0x16
    53fe:	9f 89       	ldd	r25, Y+23	; 0x17
    5400:	00 97       	sbiw	r24, 0x00	; 0
    5402:	21 f0       	breq	.+8      	; 0x540c <handle_connection+0x422>
    5404:	87 38       	cpi	r24, 0x87	; 135
    5406:	91 05       	cpc	r25, r1
    5408:	a9 f4       	brne	.+42     	; 0x5434 <handle_connection+0x44a>
    540a:	04 c0       	rjmp	.+8      	; 0x5414 <handle_connection+0x42a>
		if (((char*)uip_appdata)[t]!='\n')
			//	uart_putc( ((unsigned char *)uip_appdata)[t]);
			uart_putc(pgm_read_byte((char *)(s->file.data+t)));
	uart_puts_P(PSTR("<<<\r\n"));*/
  
  PSOCK_SEND_P(&s->sout, s->file.data, s->len);
    540c:	87 e8       	ldi	r24, 0x87	; 135
    540e:	90 e0       	ldi	r25, 0x00	; 0
    5410:	9f 8b       	std	Y+23, r25	; 0x17
    5412:	8e 8b       	std	Y+22, r24	; 0x16
    5414:	cb 57       	subi	r28, 0x7B	; 123
    5416:	df 4f       	sbci	r29, 0xFF	; 255
    5418:	68 81       	ld	r22, Y
    541a:	79 81       	ldd	r23, Y+1	; 0x01
    541c:	24 96       	adiw	r28, 0x04	; 4
    541e:	48 81       	ld	r20, Y
    5420:	59 81       	ldd	r21, Y+1	; 0x01
    5422:	c9 58       	subi	r28, 0x89	; 137
    5424:	d0 40       	sbci	r29, 0x00	; 0
    5426:	ce 01       	movw	r24, r28
    5428:	46 96       	adiw	r24, 0x16	; 22
    542a:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <psock_send_P>
    542e:	88 23       	and	r24, r24
    5430:	09 f4       	brne	.+2      	; 0x5434 <handle_connection+0x44a>
    5432:	48 c0       	rjmp	.+144    	; 0x54c4 <handle_connection+0x4da>
  
  PSOCK_END(&s->sout);
    5434:	1f 8a       	std	Y+23, r1	; 0x17
    5436:	1e 8a       	std	Y+22, r1	; 0x16
					s->len = uip_mss();
				}
      }
			//uart_puts_P(PSTR("\n\r\x1B[1msend ???\x1B[0m"));
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
      s->file.data += s->len;
    5438:	fe 01       	movw	r30, r28
    543a:	eb 57       	subi	r30, 0x7B	; 123
    543c:	ff 4f       	sbci	r31, 0xFF	; 255
    543e:	c7 57       	subi	r28, 0x77	; 119
    5440:	df 4f       	sbci	r29, 0xFF	; 255
    5442:	80 81       	ld	r24, Z
    5444:	91 81       	ldd	r25, Z+1	; 0x01
    5446:	28 81       	ld	r18, Y
    5448:	39 81       	ldd	r19, Y+1	; 0x01
    544a:	c9 58       	subi	r28, 0x89	; 137
    544c:	d0 40       	sbci	r29, 0x00	; 0
    544e:	82 0f       	add	r24, r18
    5450:	93 1f       	adc	r25, r19
    5452:	91 83       	std	Z+1, r25	; 0x01
    5454:	80 83       	st	Z, r24
      s->file.len -= s->len;
    5456:	fe 01       	movw	r30, r28
    5458:	e9 57       	subi	r30, 0x79	; 121
    545a:	ff 4f       	sbci	r31, 0xFF	; 255
    545c:	80 81       	ld	r24, Z
    545e:	91 81       	ldd	r25, Z+1	; 0x01
    5460:	82 1b       	sub	r24, r18
    5462:	93 0b       	sbc	r25, r19
    5464:	91 83       	std	Z+1, r25	; 0x01
    5466:	80 83       	st	Z, r24
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
	PT_BEGIN(&s->scriptpt);
	uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {
    5468:	c9 57       	subi	r28, 0x79	; 121
    546a:	df 4f       	sbci	r29, 0xFF	; 255
    546c:	28 81       	ld	r18, Y
    546e:	39 81       	ldd	r19, Y+1	; 0x01
    5470:	c7 58       	subi	r28, 0x87	; 135
    5472:	d0 40       	sbci	r29, 0x00	; 0
    5474:	12 16       	cp	r1, r18
    5476:	13 06       	cpc	r1, r19
    5478:	0c f4       	brge	.+2      	; 0x547c <handle_connection+0x492>
    547a:	1a cf       	rjmp	.-460    	; 0x52b0 <handle_connection+0x2c6>
      s->file.data += s->len;
      s->file.len -= s->len;
    }
  }
  
  PT_END(&s->scriptpt);
    547c:	1e a6       	std	Y+46, r1	; 0x2e
    547e:	1d a6       	std	Y+45, r1	; 0x2d
    5480:	09 c0       	rjmp	.+18     	; 0x5494 <handle_connection+0x4aa>
      PT_INIT(&s->scriptpt);
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    } 
		else 
		{
      PT_WAIT_THREAD(&s->outputpt,send_file(s));
    5482:	80 e1       	ldi	r24, 0x10	; 16
    5484:	91 e0       	ldi	r25, 0x01	; 1
    5486:	9c a7       	std	Y+44, r25	; 0x2c
    5488:	8b a7       	std	Y+43, r24	; 0x2b
    548a:	ce 01       	movw	r24, r28
    548c:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <send_file>
    5490:	88 23       	and	r24, r24
    5492:	c1 f0       	breq	.+48     	; 0x54c4 <handle_connection+0x4da>
    }
  }
  PSOCK_CLOSE(&s->sout);
    5494:	80 e1       	ldi	r24, 0x10	; 16
    5496:	80 93 6d 04 	sts	0x046D, r24
  PT_END(&s->outputpt);
    549a:	1c a6       	std	Y+44, r1	; 0x2c
    549c:	1b a6       	std	Y+43, r1	; 0x2b
    549e:	12 c0       	rjmp	.+36     	; 0x54c4 <handle_connection+0x4da>
      /*      httpd_log(&s->inputbuf[9]);*/
			// check URL for '?'
			for (i=0;((s->inputbuf[i]!=0) && (s->inputbuf[i]!='?'));i++);
			if (s->inputbuf[i]=='?')
			{
			uart_puts_P(PSTR("found ?\r\n"));
    54a0:	88 ee       	ldi	r24, 0xE8	; 232
    54a2:	92 e0       	ldi	r25, 0x02	; 2
    54a4:	0e 94 5d 10 	call	0x20ba	; 0x20ba <uart_puts_P>
				// compare path / file
				if(strncmp(s->inputbuf+i-strlen("io.shtml"), "io.shtml", strlen("io.shtml")) == 0)
    54a8:	c8 01       	movw	r24, r16
    54aa:	87 96       	adiw	r24, 0x27	; 39
    54ac:	8c 0f       	add	r24, r28
    54ae:	9d 1f       	adc	r25, r29
    54b0:	66 e2       	ldi	r22, 0x26	; 38
    54b2:	72 e0       	ldi	r23, 0x02	; 2
    54b4:	48 e0       	ldi	r20, 0x08	; 8
    54b6:	50 e0       	ldi	r21, 0x00	; 0
    54b8:	0e 94 53 2f 	call	0x5ea6	; 0x5ea6 <strncmp>
    54bc:	00 97       	sbiw	r24, 0x00	; 0
    54be:	09 f0       	breq	.+2      	; 0x54c2 <handle_connection+0x4d8>
    54c0:	00 ce       	rjmp	.-1024   	; 0x50c2 <handle_connection+0xd8>
    54c2:	35 ce       	rjmp	.-918    	; 0x512e <handle_connection+0x144>
{
  handle_input(s);
  if(s->state == STATE_OUTPUT) {
    handle_output(s);
  }
}
    54c4:	df 91       	pop	r29
    54c6:	cf 91       	pop	r28
    54c8:	1f 91       	pop	r17
    54ca:	0f 91       	pop	r16
    54cc:	ff 90       	pop	r15
    54ce:	ef 90       	pop	r14
    54d0:	08 95       	ret

000054d2 <httpd_appcall>:
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
    54d2:	ef 92       	push	r14
    54d4:	ff 92       	push	r15
    54d6:	0f 93       	push	r16
    54d8:	1f 93       	push	r17
    54da:	cf 93       	push	r28
    54dc:	df 93       	push	r29
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);
    54de:	c0 91 70 04 	lds	r28, 0x0470
    54e2:	d0 91 71 04 	lds	r29, 0x0471

	//uart_puts_P(PSTR("\n\r\x1B[1mAppcall\x1B[0m"));
	
  if(uip_closed() || uip_aborted() || uip_timedout()) {
    54e6:	90 91 6d 04 	lds	r25, 0x046D
    54ea:	94 fd       	sbrc	r25, 4
    54ec:	3c c0       	rjmp	.+120    	; 0x5566 <httpd_appcall+0x94>
    54ee:	95 fd       	sbrc	r25, 5
    54f0:	3a c0       	rjmp	.+116    	; 0x5566 <httpd_appcall+0x94>
    54f2:	97 fd       	sbrc	r25, 7
    54f4:	38 c0       	rjmp	.+112    	; 0x5566 <httpd_appcall+0x94>
}
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);
    54f6:	2c e1       	ldi	r18, 0x1C	; 28
    54f8:	e2 2e       	mov	r14, r18
    54fa:	f1 2c       	mov	r15, r1
    54fc:	ec 0e       	add	r14, r28
    54fe:	fd 1e       	adc	r15, r29

	//uart_puts_P(PSTR("\n\r\x1B[1mAppcall\x1B[0m"));
	
  if(uip_closed() || uip_aborted() || uip_timedout()) {
  } else if(uip_connected()) {
    5500:	96 ff       	sbrs	r25, 6
    5502:	1b c0       	rjmp	.+54     	; 0x553a <httpd_appcall+0x68>
    PSOCK_INIT(&s->sin, s->inputbuf, sizeof(s->inputbuf) - 1);
    5504:	8e 01       	movw	r16, r28
    5506:	05 5b       	subi	r16, 0xB5	; 181
    5508:	1f 4f       	sbci	r17, 0xFF	; 255
    550a:	ce 01       	movw	r24, r28
    550c:	4d 96       	adiw	r24, 0x1d	; 29
    550e:	b8 01       	movw	r22, r16
    5510:	40 e4       	ldi	r20, 0x40	; 64
    5512:	50 e0       	ldi	r21, 0x00	; 0
    5514:	0e 94 12 24 	call	0x4824	; 0x4824 <psock_init>
    PSOCK_INIT(&s->sout, s->inputbuf, sizeof(s->inputbuf) - 1);
    5518:	ce 01       	movw	r24, r28
    551a:	c2 96       	adiw	r24, 0x32	; 50
    551c:	b8 01       	movw	r22, r16
    551e:	40 e4       	ldi	r20, 0x40	; 64
    5520:	50 e0       	ldi	r21, 0x00	; 0
    5522:	0e 94 12 24 	call	0x4824	; 0x4824 <psock_init>
    PT_INIT(&s->outputpt);
    5526:	c9 5b       	subi	r28, 0xB9	; 185
    5528:	df 4f       	sbci	r29, 0xFF	; 255
    552a:	19 82       	std	Y+1, r1	; 0x01
    552c:	18 82       	st	Y, r1
    s->state = STATE_WAITING;
    552e:	c7 5a       	subi	r28, 0xA7	; 167
    5530:	df 4f       	sbci	r29, 0xFF	; 255
    5532:	18 82       	st	Y, r1
    5534:	c0 5a       	subi	r28, 0xA0	; 160
    5536:	d0 40       	sbci	r29, 0x00	; 0
    5538:	0e c0       	rjmp	.+28     	; 0x5556 <httpd_appcall+0x84>
    /*    timer_set(&s->ti3mer, CLOCK_SECOND * 100);*/
    s->timer = 0;
    handle_connection(s);
		} else if(s != NULL) {
    553a:	e1 14       	cp	r14, r1
    553c:	f1 04       	cpc	r15, r1
    553e:	81 f0       	breq	.+32     	; 0x5560 <httpd_appcall+0x8e>
			if(uip_poll()) {
    5540:	93 ff       	sbrs	r25, 3
    5542:	09 c0       	rjmp	.+18     	; 0x5556 <httpd_appcall+0x84>
				++s->timer;
    5544:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5546:	8f 5f       	subi	r24, 0xFF	; 255
    5548:	8c 8f       	std	Y+28, r24	; 0x1c
				if(s->timer >= 20) {
    554a:	84 31       	cpi	r24, 0x14	; 20
    554c:	28 f0       	brcs	.+10     	; 0x5558 <httpd_appcall+0x86>
					uip_abort();
    554e:	80 e2       	ldi	r24, 0x20	; 32
    5550:	80 93 6d 04 	sts	0x046D, r24
    5554:	01 c0       	rjmp	.+2      	; 0x5558 <httpd_appcall+0x86>
				}
			} else {
      s->timer = 0;
    5556:	1c 8e       	std	Y+28, r1	; 0x1c
    }
    handle_connection(s);
    5558:	c7 01       	movw	r24, r14
    555a:	0e 94 f5 27 	call	0x4fea	; 0x4fea <handle_connection>
    555e:	03 c0       	rjmp	.+6      	; 0x5566 <httpd_appcall+0x94>
  } else {
    uip_abort();
    5560:	80 e2       	ldi	r24, 0x20	; 32
    5562:	80 93 6d 04 	sts	0x046D, r24
  }
}
    5566:	df 91       	pop	r29
    5568:	cf 91       	pop	r28
    556a:	1f 91       	pop	r17
    556c:	0f 91       	pop	r16
    556e:	ff 90       	pop	r15
    5570:	ef 90       	pop	r14
    5572:	08 95       	ret

00005574 <generate_part_of_file>:


/*---------------------------------------------------------------------------*/
static unsigned short
generate_part_of_file(void *state)
{
    5574:	0f 93       	push	r16
    5576:	1f 93       	push	r17
  struct httpd_state *s = (struct httpd_state *)state;
    5578:	dc 01       	movw	r26, r24

  if(s->file.len > uip_mss()) {
    557a:	a9 57       	subi	r26, 0x79	; 121
    557c:	bf 4f       	sbci	r27, 0xFF	; 255
    557e:	2d 91       	ld	r18, X+
    5580:	3c 91       	ld	r19, X
    5582:	11 97       	sbiw	r26, 0x01	; 1
    5584:	a7 58       	subi	r26, 0x87	; 135
    5586:	b0 40       	sbci	r27, 0x00	; 0
    5588:	e0 91 70 04 	lds	r30, 0x0470
    558c:	f0 91 71 04 	lds	r31, 0x0471
    5590:	82 89       	ldd	r24, Z+18	; 0x12
    5592:	93 89       	ldd	r25, Z+19	; 0x13
    5594:	fd 01       	movw	r30, r26
    5596:	e7 57       	subi	r30, 0x77	; 119
    5598:	ff 4f       	sbci	r31, 0xFF	; 255
    559a:	82 17       	cp	r24, r18
    559c:	93 07       	cpc	r25, r19
    559e:	18 f4       	brcc	.+6      	; 0x55a6 <generate_part_of_file+0x32>
    s->len = uip_mss();
    55a0:	91 83       	std	Z+1, r25	; 0x01
    55a2:	80 83       	st	Z, r24
    55a4:	02 c0       	rjmp	.+4      	; 0x55aa <generate_part_of_file+0x36>
  } else {
    s->len = s->file.len;
    55a6:	31 83       	std	Z+1, r19	; 0x01
    55a8:	20 83       	st	Z, r18
  }
  memcpy_P(uip_appdata, s->file.data, s->len);
    55aa:	ab 57       	subi	r26, 0x7B	; 123
    55ac:	bf 4f       	sbci	r27, 0xFF	; 255
    55ae:	6d 91       	ld	r22, X+
    55b0:	7c 91       	ld	r23, X
    55b2:	11 97       	sbiw	r26, 0x01	; 1
    55b4:	8d 01       	movw	r16, r26
    55b6:	0c 5f       	subi	r16, 0xFC	; 252
    55b8:	1f 4f       	sbci	r17, 0xFF	; 255
    55ba:	f8 01       	movw	r30, r16
    55bc:	40 81       	ld	r20, Z
    55be:	51 81       	ldd	r21, Z+1	; 0x01
    55c0:	80 91 6e 04 	lds	r24, 0x046E
    55c4:	90 91 6f 04 	lds	r25, 0x046F
    55c8:	0e 94 ee 2e 	call	0x5ddc	; 0x5ddc <memcpy_P>
			//uart_putc( ((unsigned char *)uip_appdata)[t]);
			uart_putc(((char*)uip_appdata)[t]);
	uart_puts_P(PSTR("<<<\r\n"));*/
  
  return s->len;
}
    55cc:	f8 01       	movw	r30, r16
    55ce:	80 81       	ld	r24, Z
    55d0:	91 81       	ldd	r25, Z+1	; 0x01
    55d2:	1f 91       	pop	r17
    55d4:	0f 91       	pop	r16
    55d6:	08 95       	ret

000055d8 <httpd_fs_strcmp>:
#endif /* HTTPD_FS_STATISTICS */

/*-----------------------------------------------------------------------------------*/
static u8_t
httpd_fs_strcmp(const char *str1, const char *str2)
{
    55d8:	30 e0       	ldi	r19, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    55da:	a3 2f       	mov	r26, r19
    55dc:	b0 e0       	ldi	r27, 0x00	; 0
    55de:	fb 01       	movw	r30, r22
    55e0:	ea 0f       	add	r30, r26
    55e2:	fb 1f       	adc	r31, r27
    55e4:	44 91       	lpm	r20, Z+
    55e6:	44 23       	and	r20, r20
    55e8:	69 f0       	breq	.+26     	; 0x5604 <httpd_fs_strcmp+0x2c>
    55ea:	a8 0f       	add	r26, r24
    55ec:	b9 1f       	adc	r27, r25
    55ee:	2c 91       	ld	r18, X
    55f0:	2d 30       	cpi	r18, 0x0D	; 13
    55f2:	41 f0       	breq	.+16     	; 0x5604 <httpd_fs_strcmp+0x2c>
    55f4:	2a 30       	cpi	r18, 0x0A	; 10
    55f6:	31 f0       	breq	.+12     	; 0x5604 <httpd_fs_strcmp+0x2c>
     str1[i] == '\r' ||
     str1[i] == '\n') {
    return 0;
  }

  if(str1[i] != pgm_read_byte(&str2[i])) {
    55f8:	24 17       	cp	r18, r20
    55fa:	11 f0       	breq	.+4      	; 0x5600 <httpd_fs_strcmp+0x28>
    55fc:	81 e0       	ldi	r24, 0x01	; 1
    55fe:	08 95       	ret
    return 1;
  }


  ++i;
    5600:	3f 5f       	subi	r19, 0xFF	; 255
    5602:	eb cf       	rjmp	.-42     	; 0x55da <httpd_fs_strcmp+0x2>
  goto loop;
    5604:	80 e0       	ldi	r24, 0x00	; 0
}
    5606:	08 95       	ret

00005608 <httpd_fs_open>:
  goto loop;
}
/*-----------------------------------------------------------------------------------*/
int
httpd_fs_open(const char *name, struct httpd_fs_file *file)
{
    5608:	cf 92       	push	r12
    560a:	df 92       	push	r13
    560c:	ef 92       	push	r14
    560e:	ff 92       	push	r15
    5610:	0f 93       	push	r16
    5612:	1f 93       	push	r17
    5614:	cf 93       	push	r28
    5616:	df 93       	push	r29
    5618:	6c 01       	movw	r12, r24
    561a:	7b 01       	movw	r14, r22
#if HTTPD_FS_STATISTICS
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    561c:	c3 e9       	ldi	r28, 0x93	; 147
    561e:	d2 e0       	ldi	r29, 0x02	; 2
    5620:	00 e0       	ldi	r16, 0x00	; 0
    5622:	10 e0       	ldi	r17, 0x00	; 0
    5624:	23 c0       	rjmp	.+70     	; 0x566c <httpd_fs_open+0x64>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
    5626:	6a 81       	ldd	r22, Y+2	; 0x02
    5628:	7b 81       	ldd	r23, Y+3	; 0x03
    562a:	c6 01       	movw	r24, r12
    562c:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <httpd_fs_strcmp>
    5630:	88 23       	and	r24, r24
    5632:	b1 f4       	brne	.+44     	; 0x5660 <httpd_fs_open+0x58>
      file->data = f->data;  // f = progmem !
    5634:	8c 81       	ldd	r24, Y+4	; 0x04
    5636:	9d 81       	ldd	r25, Y+5	; 0x05
    5638:	f7 01       	movw	r30, r14
    563a:	91 83       	std	Z+1, r25	; 0x01
    563c:	80 83       	st	Z, r24
      file->len = f->len;    // f = progmem !
    563e:	8e 81       	ldd	r24, Y+6	; 0x06
    5640:	9f 81       	ldd	r25, Y+7	; 0x07
    5642:	93 83       	std	Z+3, r25	; 0x03
    5644:	82 83       	std	Z+2, r24	; 0x02
#if HTTPD_FS_STATISTICS
      ++count[i];
    5646:	f8 01       	movw	r30, r16
    5648:	ee 0f       	add	r30, r30
    564a:	ff 1f       	adc	r31, r31
    564c:	e3 5b       	subi	r30, 0xB3	; 179
    564e:	fb 4f       	sbci	r31, 0xFB	; 251
    5650:	80 81       	ld	r24, Z
    5652:	91 81       	ldd	r25, Z+1	; 0x01
    5654:	01 96       	adiw	r24, 0x01	; 1
    5656:	91 83       	std	Z+1, r25	; 0x01
    5658:	80 83       	st	Z, r24
    565a:	21 e0       	ldi	r18, 0x01	; 1
    565c:	30 e0       	ldi	r19, 0x00	; 0
    565e:	0a c0       	rjmp	.+20     	; 0x5674 <httpd_fs_open+0x6c>
#endif /* HTTPD_FS_STATISTICS */
      return 1;
    }
#if HTTPD_FS_STATISTICS
    ++i;
    5660:	0f 5f       	subi	r16, 0xFF	; 255
    5662:	1f 4f       	sbci	r17, 0xFF	; 255
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    5664:	88 81       	ld	r24, Y
    5666:	99 81       	ldd	r25, Y+1	; 0x01
    5668:	9c 01       	movw	r18, r24
    566a:	e9 01       	movw	r28, r18
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    566c:	20 97       	sbiw	r28, 0x00	; 0
    566e:	d9 f6       	brne	.-74     	; 0x5626 <httpd_fs_open+0x1e>
    5670:	20 e0       	ldi	r18, 0x00	; 0
    5672:	30 e0       	ldi	r19, 0x00	; 0
    ++i;
#endif /* HTTPD_FS_STATISTICS */

  }
  return 0;
}
    5674:	c9 01       	movw	r24, r18
    5676:	df 91       	pop	r29
    5678:	cf 91       	pop	r28
    567a:	1f 91       	pop	r17
    567c:	0f 91       	pop	r16
    567e:	ff 90       	pop	r15
    5680:	ef 90       	pop	r14
    5682:	df 90       	pop	r13
    5684:	cf 90       	pop	r12
    5686:	08 95       	ret

00005688 <httpd_fs_open_P>:
/*-----------------------------------------------------------------------------------*/
int
httpd_fs_open_P(const char *name, struct httpd_fs_file *file)
{
    5688:	0f 93       	push	r16
    568a:	1f 93       	push	r17
    568c:	cf 93       	push	r28
    568e:	df 93       	push	r29
    5690:	8c 01       	movw	r16, r24
    5692:	eb 01       	movw	r28, r22
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    5694:	a3 e9       	ldi	r26, 0x93	; 147
    5696:	b2 e0       	ldi	r27, 0x02	; 2
    5698:	40 e0       	ldi	r20, 0x00	; 0
    569a:	50 e0       	ldi	r21, 0x00	; 0
    569c:	32 c0       	rjmp	.+100    	; 0x5702 <httpd_fs_open_P+0x7a>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp_P(name, f->name) == 0) {
    569e:	12 96       	adiw	r26, 0x02	; 2
    56a0:	6d 91       	ld	r22, X+
    56a2:	7c 91       	ld	r23, X
    56a4:	13 97       	sbiw	r26, 0x03	; 3
    56a6:	20 e0       	ldi	r18, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    56a8:	82 2f       	mov	r24, r18
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	fb 01       	movw	r30, r22
    56ae:	e8 0f       	add	r30, r24
    56b0:	f9 1f       	adc	r31, r25
    56b2:	34 91       	lpm	r19, Z+
    56b4:	33 23       	and	r19, r19
    56b6:	61 f0       	breq	.+24     	; 0x56d0 <httpd_fs_open_P+0x48>
     pgm_read_byte(&str1[i]) == '\r' ||
    56b8:	80 0f       	add	r24, r16
    56ba:	91 1f       	adc	r25, r17
    56bc:	fc 01       	movw	r30, r24
    56be:	84 91       	lpm	r24, Z+
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    56c0:	8d 30       	cpi	r24, 0x0D	; 13
    56c2:	31 f0       	breq	.+12     	; 0x56d0 <httpd_fs_open_P+0x48>
    56c4:	8a 30       	cpi	r24, 0x0A	; 10
    56c6:	21 f0       	breq	.+8      	; 0x56d0 <httpd_fs_open_P+0x48>
     pgm_read_byte(&str1[i]) == '\r' ||
     pgm_read_byte(&str1[i]) == '\n') {
    return 0;
  }

  if(pgm_read_byte(&str1[i]) != pgm_read_byte(&str2[i])) {
    56c8:	83 17       	cp	r24, r19
    56ca:	29 f5       	brne	.+74     	; 0x5716 <httpd_fs_open_P+0x8e>
    return 1;
  }


  ++i;
    56cc:	2f 5f       	subi	r18, 0xFF	; 255
    56ce:	ec cf       	rjmp	.-40     	; 0x56a8 <httpd_fs_open_P+0x20>
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp_P(name, f->name) == 0) {
      file->data = f->data;  // f->data = zeiger auf progmem 
    56d0:	14 96       	adiw	r26, 0x04	; 4
    56d2:	8d 91       	ld	r24, X+
    56d4:	9c 91       	ld	r25, X
    56d6:	15 97       	sbiw	r26, 0x05	; 5
    56d8:	99 83       	std	Y+1, r25	; 0x01
    56da:	88 83       	st	Y, r24
      file->len = f->len;    // f->len = zeiger auf progmem 
    56dc:	16 96       	adiw	r26, 0x06	; 6
    56de:	8d 91       	ld	r24, X+
    56e0:	9c 91       	ld	r25, X
    56e2:	17 97       	sbiw	r26, 0x07	; 7
    56e4:	9b 83       	std	Y+3, r25	; 0x03
    56e6:	8a 83       	std	Y+2, r24	; 0x02
#if HTTPD_FS_STATISTICS
      ++count[i];
    56e8:	fa 01       	movw	r30, r20
    56ea:	ee 0f       	add	r30, r30
    56ec:	ff 1f       	adc	r31, r31
    56ee:	e3 5b       	subi	r30, 0xB3	; 179
    56f0:	fb 4f       	sbci	r31, 0xFB	; 251
    56f2:	80 81       	ld	r24, Z
    56f4:	91 81       	ldd	r25, Z+1	; 0x01
    56f6:	01 96       	adiw	r24, 0x01	; 1
    56f8:	91 83       	std	Z+1, r25	; 0x01
    56fa:	80 83       	st	Z, r24
    56fc:	21 e0       	ldi	r18, 0x01	; 1
    56fe:	30 e0       	ldi	r19, 0x00	; 0
    5700:	04 c0       	rjmp	.+8      	; 0x570a <httpd_fs_open_P+0x82>
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    5702:	10 97       	sbiw	r26, 0x00	; 0
    5704:	61 f6       	brne	.-104    	; 0x569e <httpd_fs_open_P+0x16>
    5706:	20 e0       	ldi	r18, 0x00	; 0
    5708:	30 e0       	ldi	r19, 0x00	; 0
    ++i;
#endif /* HTTPD_FS_STATISTICS */

  }
  return 0;
}
    570a:	c9 01       	movw	r24, r18
    570c:	df 91       	pop	r29
    570e:	cf 91       	pop	r28
    5710:	1f 91       	pop	r17
    5712:	0f 91       	pop	r16
    5714:	08 95       	ret
      ++count[i];
#endif /* HTTPD_FS_STATISTICS */
      return 1;
    }
#if HTTPD_FS_STATISTICS
    ++i;
    5716:	4f 5f       	subi	r20, 0xFF	; 255
    5718:	5f 4f       	sbci	r21, 0xFF	; 255
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    571a:	8c 91       	ld	r24, X
    571c:	11 96       	adiw	r26, 0x01	; 1
    571e:	9c 91       	ld	r25, X
    5720:	9c 01       	movw	r18, r24
    5722:	d9 01       	movw	r26, r18
    5724:	ee cf       	rjmp	.-36     	; 0x5702 <httpd_fs_open_P+0x7a>

00005726 <httpd_fs_init>:
}
/*-----------------------------------------------------------------------------------*/

void
httpd_fs_init(void)
{
    5726:	ed e4       	ldi	r30, 0x4D	; 77
    5728:	f4 e0       	ldi	r31, 0x04	; 4
#if HTTPD_FS_STATISTICS
  u16_t i;
  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {
    count[i] = 0;
    572a:	11 92       	st	Z+, r1
    572c:	11 92       	st	Z+, r1
void
httpd_fs_init(void)
{
#if HTTPD_FS_STATISTICS
  u16_t i;
  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {
    572e:	84 e0       	ldi	r24, 0x04	; 4
    5730:	e3 36       	cpi	r30, 0x63	; 99
    5732:	f8 07       	cpc	r31, r24
    5734:	d1 f7       	brne	.-12     	; 0x572a <httpd_fs_init+0x4>
    count[i] = 0;
  }
#endif /* HTTPD_FS_STATISTICS */
}
    5736:	08 95       	ret

00005738 <httpd_fs_count>:
/*-----------------------------------------------------------------------------------*/
#if HTTPD_FS_STATISTICS
u16_t httpd_fs_count
(char *name)
{
    5738:	ef 92       	push	r14
    573a:	ff 92       	push	r15
    573c:	0f 93       	push	r16
    573e:	1f 93       	push	r17
    5740:	cf 93       	push	r28
    5742:	df 93       	push	r29
    5744:	7c 01       	movw	r14, r24
  struct httpd_fsdata_file_noconst *f; 
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    5746:	03 e9       	ldi	r16, 0x93	; 147
    5748:	12 e0       	ldi	r17, 0x02	; 2
    574a:	c0 e0       	ldi	r28, 0x00	; 0
    574c:	d0 e0       	ldi	r29, 0x00	; 0
    574e:	15 c0       	rjmp	.+42     	; 0x577a <httpd_fs_count+0x42>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
    5750:	f8 01       	movw	r30, r16
    5752:	62 81       	ldd	r22, Z+2	; 0x02
    5754:	73 81       	ldd	r23, Z+3	; 0x03
    5756:	c7 01       	movw	r24, r14
    5758:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <httpd_fs_strcmp>
    575c:	88 23       	and	r24, r24
    575e:	39 f4       	brne	.+14     	; 0x576e <httpd_fs_count+0x36>
      return count[i];
    5760:	cc 0f       	add	r28, r28
    5762:	dd 1f       	adc	r29, r29
    5764:	c3 5b       	subi	r28, 0xB3	; 179
    5766:	db 4f       	sbci	r29, 0xFB	; 251
    5768:	28 81       	ld	r18, Y
    576a:	39 81       	ldd	r19, Y+1	; 0x01
    576c:	0b c0       	rjmp	.+22     	; 0x5784 <httpd_fs_count+0x4c>
    }
    ++i;
    576e:	21 96       	adiw	r28, 0x01	; 1
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    5770:	f8 01       	movw	r30, r16
    5772:	80 81       	ld	r24, Z
    5774:	91 81       	ldd	r25, Z+1	; 0x01
    5776:	9c 01       	movw	r18, r24
    5778:	89 01       	movw	r16, r18
  struct httpd_fsdata_file_noconst *f; 
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    577a:	01 15       	cp	r16, r1
    577c:	11 05       	cpc	r17, r1
    577e:	41 f7       	brne	.-48     	; 0x5750 <httpd_fs_count+0x18>
    5780:	20 e0       	ldi	r18, 0x00	; 0
    5782:	30 e0       	ldi	r19, 0x00	; 0
      return count[i];
    }
    ++i;
  }
  return 0;
}
    5784:	c9 01       	movw	r24, r18
    5786:	df 91       	pop	r29
    5788:	cf 91       	pop	r28
    578a:	1f 91       	pop	r17
    578c:	0f 91       	pop	r16
    578e:	ff 90       	pop	r15
    5790:	ef 90       	pop	r14
    5792:	08 95       	ret

00005794 <nullfunction>:
/*---------------------------------------------------------------------------*/
static
PT_THREAD(nullfunction(struct httpd_state *s, char *ptr))
{
  PSOCK_BEGIN(&s->sout);
  PSOCK_END(&s->sout);
    5794:	fc 01       	movw	r30, r24
    5796:	17 8a       	std	Z+23, r1	; 0x17
    5798:	16 8a       	std	Z+22, r1	; 0x16
}
    579a:	82 e0       	ldi	r24, 0x02	; 2
    579c:	08 95       	ret

0000579e <httpd_cgi>:
/*---------------------------------------------------------------------------*/
httpd_cgifunction
httpd_cgi(char *name)
{
    579e:	ef 92       	push	r14
    57a0:	ff 92       	push	r15
    57a2:	0f 93       	push	r16
    57a4:	1f 93       	push	r17
    57a6:	cf 93       	push	r28
    57a8:	df 93       	push	r29
    57aa:	7c 01       	movw	r14, r24
    57ac:	03 e0       	ldi	r16, 0x03	; 3
    57ae:	13 e0       	ldi	r17, 0x03	; 3
    57b0:	15 c0       	rjmp	.+42     	; 0x57dc <httpd_cgi+0x3e>
  const struct httpd_cgi_call **f;


  /* Find the matching name in the table, return the function. */
  for(f = calls; *f != NULL; ++f) {
    if(strncmp_P((*f)->name, name, strlen((*f)->name)) == 0) {
    57b2:	88 81       	ld	r24, Y
    57b4:	99 81       	ldd	r25, Y+1	; 0x01
    57b6:	fc 01       	movw	r30, r24
    57b8:	df 01       	movw	r26, r30
    57ba:	0d 90       	ld	r0, X+
    57bc:	00 20       	and	r0, r0
    57be:	e9 f7       	brne	.-6      	; 0x57ba <httpd_cgi+0x1c>
    57c0:	11 97       	sbiw	r26, 0x01	; 1
    57c2:	ae 1b       	sub	r26, r30
    57c4:	bf 0b       	sbc	r27, r31
    57c6:	b7 01       	movw	r22, r14
    57c8:	ad 01       	movw	r20, r26
    57ca:	0e 94 1b 2f 	call	0x5e36	; 0x5e36 <strncmp_P>
    57ce:	89 2b       	or	r24, r25
    57d0:	19 f4       	brne	.+6      	; 0x57d8 <httpd_cgi+0x3a>
      return (*f)->function;
    57d2:	2a 81       	ldd	r18, Y+2	; 0x02
    57d4:	3b 81       	ldd	r19, Y+3	; 0x03
    57d6:	09 c0       	rjmp	.+18     	; 0x57ea <httpd_cgi+0x4c>
{
  const struct httpd_cgi_call **f;


  /* Find the matching name in the table, return the function. */
  for(f = calls; *f != NULL; ++f) {
    57d8:	0e 5f       	subi	r16, 0xFE	; 254
    57da:	1f 4f       	sbci	r17, 0xFF	; 255
    57dc:	f8 01       	movw	r30, r16
    57de:	c0 81       	ld	r28, Z
    57e0:	d1 81       	ldd	r29, Z+1	; 0x01
    57e2:	20 97       	sbiw	r28, 0x00	; 0
    57e4:	31 f7       	brne	.-52     	; 0x57b2 <httpd_cgi+0x14>
    57e6:	2a ec       	ldi	r18, 0xCA	; 202
    57e8:	3b e2       	ldi	r19, 0x2B	; 43
    if(strncmp_P((*f)->name, name, strlen((*f)->name)) == 0) {
      return (*f)->function;
    }
  }
  return nullfunction;
}
    57ea:	c9 01       	movw	r24, r18
    57ec:	df 91       	pop	r29
    57ee:	cf 91       	pop	r28
    57f0:	1f 91       	pop	r17
    57f2:	0f 91       	pop	r16
    57f4:	ff 90       	pop	r15
    57f6:	ef 90       	pop	r14
    57f8:	08 95       	ret

000057fa <net_stats>:
		  "%5u\n", ((uip_stats_t *)&uip_stat)[s->count]);
}

static
PT_THREAD(net_stats(struct httpd_state *s, char *ptr))
{
    57fa:	cf 93       	push	r28
    57fc:	df 93       	push	r29
    57fe:	ec 01       	movw	r28, r24
  PSOCK_BEGIN(&s->sout);
    5800:	8e 89       	ldd	r24, Y+22	; 0x16
    5802:	9f 89       	ldd	r25, Y+23	; 0x17
    5804:	00 97       	sbiw	r24, 0x00	; 0
    5806:	21 f0       	breq	.+8      	; 0x5810 <net_stats+0x16>
    5808:	84 3c       	cpi	r24, 0xC4	; 196
    580a:	91 05       	cpc	r25, r1
    580c:	29 f5       	brne	.+74     	; 0x5858 <net_stats+0x5e>
    580e:	0b c0       	rjmp	.+22     	; 0x5826 <net_stats+0x2c>

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
    5810:	c1 57       	subi	r28, 0x71	; 113
    5812:	df 4f       	sbci	r29, 0xFF	; 255
    5814:	19 82       	std	Y+1, r1	; 0x01
    5816:	18 82       	st	Y, r1
    5818:	cf 58       	subi	r28, 0x8F	; 143
    581a:	d0 40       	sbci	r29, 0x00	; 0
    581c:	15 c0       	rjmp	.+42     	; 0x5848 <net_stats+0x4e>
      ++s->count) {
    PSOCK_GENERATOR_SEND(&s->sout, generate_net_stats, s);
    581e:	84 ec       	ldi	r24, 0xC4	; 196
    5820:	90 e0       	ldi	r25, 0x00	; 0
    5822:	9f 8b       	std	Y+23, r25	; 0x17
    5824:	8e 8b       	std	Y+22, r24	; 0x16
    5826:	ce 01       	movw	r24, r28
    5828:	46 96       	adiw	r24, 0x16	; 22
    582a:	69 e7       	ldi	r22, 0x79	; 121
    582c:	7c e2       	ldi	r23, 0x2C	; 44
    582e:	ae 01       	movw	r20, r28
    5830:	0e 94 e4 24 	call	0x49c8	; 0x49c8 <psock_generator_send>
    5834:	88 23       	and	r24, r24
    5836:	99 f0       	breq	.+38     	; 0x585e <net_stats+0x64>
  PSOCK_BEGIN(&s->sout);

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
      ++s->count) {
    5838:	fe 01       	movw	r30, r28
    583a:	e1 57       	subi	r30, 0x71	; 113
    583c:	ff 4f       	sbci	r31, 0xFF	; 255
    583e:	80 81       	ld	r24, Z
    5840:	91 81       	ldd	r25, Z+1	; 0x01
    5842:	01 96       	adiw	r24, 0x01	; 1
    5844:	91 83       	std	Z+1, r25	; 0x01
    5846:	80 83       	st	Z, r24
{
  PSOCK_BEGIN(&s->sout);

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
    5848:	c1 57       	subi	r28, 0x71	; 113
    584a:	df 4f       	sbci	r29, 0xFF	; 255
    584c:	88 81       	ld	r24, Y
    584e:	99 81       	ldd	r25, Y+1	; 0x01
    5850:	cf 58       	subi	r28, 0x8F	; 143
    5852:	d0 40       	sbci	r29, 0x00	; 0
    5854:	46 97       	sbiw	r24, 0x16	; 22
    5856:	18 f3       	brcs	.-58     	; 0x581e <net_stats+0x24>
    PSOCK_GENERATOR_SEND(&s->sout, generate_net_stats, s);
  }
  
#endif /* UIP_STATISTICS */
  
  PSOCK_END(&s->sout);
    5858:	1f 8a       	std	Y+23, r1	; 0x17
    585a:	1e 8a       	std	Y+22, r1	; 0x16
    585c:	82 e0       	ldi	r24, 0x02	; 2
}
    585e:	df 91       	pop	r29
    5860:	cf 91       	pop	r28
    5862:	08 95       	ret

00005864 <tcp_stats>:
		 (uip_stopped(conn))? '!':' ');
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(tcp_stats(struct httpd_state *s, char *ptr))
{
    5864:	cf 93       	push	r28
    5866:	df 93       	push	r29
    5868:	ec 01       	movw	r28, r24
  
  PSOCK_BEGIN(&s->sout);
    586a:	8e 89       	ldd	r24, Y+22	; 0x16
    586c:	9f 89       	ldd	r25, Y+23	; 0x17
    586e:	00 97       	sbiw	r24, 0x00	; 0
    5870:	21 f0       	breq	.+8      	; 0x587a <tcp_stats+0x16>
    5872:	8c 3a       	cpi	r24, 0xAC	; 172
    5874:	91 05       	cpc	r25, r1
    5876:	b9 f5       	brne	.+110    	; 0x58e6 <tcp_stats+0x82>
    5878:	1c c0       	rjmp	.+56     	; 0x58b2 <tcp_stats+0x4e>

  for(s->count = 0; s->count < UIP_CONNS; ++s->count) {
    587a:	c1 57       	subi	r28, 0x71	; 113
    587c:	df 4f       	sbci	r29, 0xFF	; 255
    587e:	19 82       	std	Y+1, r1	; 0x01
    5880:	18 82       	st	Y, r1
    5882:	cf 58       	subi	r28, 0x8F	; 143
    5884:	d0 40       	sbci	r29, 0x00	; 0
    5886:	26 c0       	rjmp	.+76     	; 0x58d4 <tcp_stats+0x70>
    if((uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED) {
    5888:	8d ea       	ldi	r24, 0xAD	; 173
    588a:	90 e0       	ldi	r25, 0x00	; 0
    588c:	28 9f       	mul	r18, r24
    588e:	f0 01       	movw	r30, r0
    5890:	29 9f       	mul	r18, r25
    5892:	f0 0d       	add	r31, r0
    5894:	38 9f       	mul	r19, r24
    5896:	f0 0d       	add	r31, r0
    5898:	11 24       	eor	r1, r1
    589a:	ee 58       	subi	r30, 0x8E	; 142
    589c:	fb 4f       	sbci	r31, 0xFB	; 251
    589e:	81 8d       	ldd	r24, Z+25	; 0x19
    58a0:	90 e0       	ldi	r25, 0x00	; 0
    58a2:	8f 70       	andi	r24, 0x0F	; 15
    58a4:	90 70       	andi	r25, 0x00	; 0
    58a6:	89 2b       	or	r24, r25
    58a8:	69 f0       	breq	.+26     	; 0x58c4 <tcp_stats+0x60>
      PSOCK_GENERATOR_SEND(&s->sout, generate_tcp_stats, s);
    58aa:	8c ea       	ldi	r24, 0xAC	; 172
    58ac:	90 e0       	ldi	r25, 0x00	; 0
    58ae:	9f 8b       	std	Y+23, r25	; 0x17
    58b0:	8e 8b       	std	Y+22, r24	; 0x16
    58b2:	ce 01       	movw	r24, r28
    58b4:	46 96       	adiw	r24, 0x16	; 22
    58b6:	65 eb       	ldi	r22, 0xB5	; 181
    58b8:	7c e2       	ldi	r23, 0x2C	; 44
    58ba:	ae 01       	movw	r20, r28
    58bc:	0e 94 e4 24 	call	0x49c8	; 0x49c8 <psock_generator_send>
    58c0:	88 23       	and	r24, r24
    58c2:	a1 f0       	breq	.+40     	; 0x58ec <tcp_stats+0x88>
PT_THREAD(tcp_stats(struct httpd_state *s, char *ptr))
{
  
  PSOCK_BEGIN(&s->sout);

  for(s->count = 0; s->count < UIP_CONNS; ++s->count) {
    58c4:	fe 01       	movw	r30, r28
    58c6:	e1 57       	subi	r30, 0x71	; 113
    58c8:	ff 4f       	sbci	r31, 0xFF	; 255
    58ca:	80 81       	ld	r24, Z
    58cc:	91 81       	ldd	r25, Z+1	; 0x01
    58ce:	01 96       	adiw	r24, 0x01	; 1
    58d0:	91 83       	std	Z+1, r25	; 0x01
    58d2:	80 83       	st	Z, r24
    58d4:	c1 57       	subi	r28, 0x71	; 113
    58d6:	df 4f       	sbci	r29, 0xFF	; 255
    58d8:	28 81       	ld	r18, Y
    58da:	39 81       	ldd	r19, Y+1	; 0x01
    58dc:	cf 58       	subi	r28, 0x8F	; 143
    58de:	d0 40       	sbci	r29, 0x00	; 0
    58e0:	22 30       	cpi	r18, 0x02	; 2
    58e2:	31 05       	cpc	r19, r1
    58e4:	88 f2       	brcs	.-94     	; 0x5888 <tcp_stats+0x24>
    if((uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED) {
      PSOCK_GENERATOR_SEND(&s->sout, generate_tcp_stats, s);
    }
  }

  PSOCK_END(&s->sout);
    58e6:	1f 8a       	std	Y+23, r1	; 0x17
    58e8:	1e 8a       	std	Y+22, r1	; 0x16
    58ea:	82 e0       	ldi	r24, 0x02	; 2
}
    58ec:	df 91       	pop	r29
    58ee:	cf 91       	pop	r28
    58f0:	08 95       	ret

000058f2 <generate_net_stats>:
/*---------------------------------------------------------------------------*/
static unsigned short
generate_net_stats(void *arg)
{
  struct httpd_state *s = (struct httpd_state *)arg;
  return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE,
    58f2:	2d b7       	in	r18, 0x3d	; 61
    58f4:	3e b7       	in	r19, 0x3e	; 62
    58f6:	28 50       	subi	r18, 0x08	; 8
    58f8:	30 40       	sbci	r19, 0x00	; 0
    58fa:	0f b6       	in	r0, 0x3f	; 63
    58fc:	f8 94       	cli
    58fe:	3e bf       	out	0x3e, r19	; 62
    5900:	0f be       	out	0x3f, r0	; 63
    5902:	2d bf       	out	0x3d, r18	; 61
    5904:	ad b7       	in	r26, 0x3d	; 61
    5906:	be b7       	in	r27, 0x3e	; 62
    5908:	11 96       	adiw	r26, 0x01	; 1
    590a:	20 91 6e 04 	lds	r18, 0x046E
    590e:	30 91 6f 04 	lds	r19, 0x046F
    5912:	ed b7       	in	r30, 0x3d	; 61
    5914:	fe b7       	in	r31, 0x3e	; 62
    5916:	32 83       	std	Z+2, r19	; 0x02
    5918:	21 83       	std	Z+1, r18	; 0x01
    591a:	26 ea       	ldi	r18, 0xA6	; 166
    591c:	35 e0       	ldi	r19, 0x05	; 5
    591e:	13 96       	adiw	r26, 0x03	; 3
    5920:	3c 93       	st	X, r19
    5922:	2e 93       	st	-X, r18
    5924:	12 97       	sbiw	r26, 0x02	; 2
    5926:	2d e9       	ldi	r18, 0x9D	; 157
    5928:	32 e0       	ldi	r19, 0x02	; 2
    592a:	15 96       	adiw	r26, 0x05	; 5
    592c:	3c 93       	st	X, r19
    592e:	2e 93       	st	-X, r18
    5930:	14 97       	sbiw	r26, 0x04	; 4
    5932:	fc 01       	movw	r30, r24
    5934:	e1 57       	subi	r30, 0x71	; 113
    5936:	ff 4f       	sbci	r31, 0xFF	; 255
    5938:	01 90       	ld	r0, Z+
    593a:	f0 81       	ld	r31, Z
    593c:	e0 2d       	mov	r30, r0
    593e:	ee 0f       	add	r30, r30
    5940:	ff 1f       	adc	r31, r31
    5942:	ec 52       	subi	r30, 0x2C	; 44
    5944:	fa 4f       	sbci	r31, 0xFA	; 250
    5946:	80 81       	ld	r24, Z
    5948:	91 81       	ldd	r25, Z+1	; 0x01
    594a:	17 96       	adiw	r26, 0x07	; 7
    594c:	9c 93       	st	X, r25
    594e:	8e 93       	st	-X, r24
    5950:	16 97       	sbiw	r26, 0x06	; 6
    5952:	0e 94 ae 2f 	call	0x5f5c	; 0x5f5c <snprintf>
    5956:	2d b7       	in	r18, 0x3d	; 61
    5958:	3e b7       	in	r19, 0x3e	; 62
    595a:	28 5f       	subi	r18, 0xF8	; 248
    595c:	3f 4f       	sbci	r19, 0xFF	; 255
    595e:	0f b6       	in	r0, 0x3f	; 63
    5960:	f8 94       	cli
    5962:	3e bf       	out	0x3e, r19	; 62
    5964:	0f be       	out	0x3f, r0	; 63
    5966:	2d bf       	out	0x3d, r18	; 61
		  "%5u\n", ((uip_stats_t *)&uip_stat)[s->count]);
}
    5968:	08 95       	ret

0000596a <generate_tcp_stats>:
  last_ack};
  

static unsigned short
generate_tcp_stats(void *arg)
{
    596a:	4f 92       	push	r4
    596c:	5f 92       	push	r5
    596e:	6f 92       	push	r6
    5970:	7f 92       	push	r7
    5972:	8f 92       	push	r8
    5974:	9f 92       	push	r9
    5976:	af 92       	push	r10
    5978:	bf 92       	push	r11
    597a:	cf 92       	push	r12
    597c:	df 92       	push	r13
    597e:	ef 92       	push	r14
    5980:	ff 92       	push	r15
    5982:	0f 93       	push	r16
    5984:	1f 93       	push	r17
    5986:	cf 93       	push	r28
    5988:	df 93       	push	r29
  struct uip_conn *conn;
  struct httpd_state *s = (struct httpd_state *)arg;
  conn = &uip_conns[s->count]; 
    598a:	fc 01       	movw	r30, r24
    598c:	e1 57       	subi	r30, 0x71	; 113
    598e:	ff 4f       	sbci	r31, 0xFF	; 255
    5990:	20 81       	ld	r18, Z
    5992:	31 81       	ldd	r19, Z+1	; 0x01
    5994:	8d ea       	ldi	r24, 0xAD	; 173
    5996:	90 e0       	ldi	r25, 0x00	; 0
    5998:	28 9f       	mul	r18, r24
    599a:	80 01       	movw	r16, r0
    599c:	29 9f       	mul	r18, r25
    599e:	10 0d       	add	r17, r0
    59a0:	38 9f       	mul	r19, r24
    59a2:	10 0d       	add	r17, r0
    59a4:	11 24       	eor	r1, r1
    59a6:	0e 58       	subi	r16, 0x8E	; 142
    59a8:	1b 4f       	sbci	r17, 0xFB	; 251
  return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE,
    59aa:	c0 90 6e 04 	lds	r12, 0x046E
    59ae:	d0 90 6f 04 	lds	r13, 0x046F
    59b2:	d8 01       	movw	r26, r16
    59b4:	14 96       	adiw	r26, 0x04	; 4
    59b6:	8d 91       	ld	r24, X+
    59b8:	9c 91       	ld	r25, X
    59ba:	15 97       	sbiw	r26, 0x05	; 5
    59bc:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    59c0:	5c 01       	movw	r10, r24
    59c2:	f8 01       	movw	r30, r16
    59c4:	80 81       	ld	r24, Z
    59c6:	91 81       	ldd	r25, Z+1	; 0x01
    59c8:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    59cc:	69 2e       	mov	r6, r25
    59ce:	d8 01       	movw	r26, r16
    59d0:	8d 91       	ld	r24, X+
    59d2:	9c 91       	ld	r25, X
    59d4:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    59d8:	7c 01       	movw	r14, r24
    59da:	f8 01       	movw	r30, r16
    59dc:	82 81       	ldd	r24, Z+2	; 0x02
    59de:	93 81       	ldd	r25, Z+3	; 0x03
    59e0:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    59e4:	79 2e       	mov	r7, r25
    59e6:	d8 01       	movw	r26, r16
    59e8:	12 96       	adiw	r26, 0x02	; 2
    59ea:	8d 91       	ld	r24, X+
    59ec:	9c 91       	ld	r25, X
    59ee:	13 97       	sbiw	r26, 0x03	; 3
    59f0:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    59f4:	ec 01       	movw	r28, r24
    59f6:	f8 01       	movw	r30, r16
    59f8:	86 81       	ldd	r24, Z+6	; 0x06
    59fa:	97 81       	ldd	r25, Z+7	; 0x07
    59fc:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <htons>
    5a00:	2c 01       	movw	r4, r24
    5a02:	d8 01       	movw	r26, r16
    5a04:	59 96       	adiw	r26, 0x19	; 25
    5a06:	8c 91       	ld	r24, X
    5a08:	59 97       	sbiw	r26, 0x19	; 25
    5a0a:	28 2f       	mov	r18, r24
    5a0c:	30 e0       	ldi	r19, 0x00	; 0
    5a0e:	f9 01       	movw	r30, r18
    5a10:	ef 70       	andi	r30, 0x0F	; 15
    5a12:	f0 70       	andi	r31, 0x00	; 0
    5a14:	ee 0f       	add	r30, r30
    5a16:	ff 1f       	adc	r31, r31
    5a18:	e5 5f       	subi	r30, 0xF5	; 245
    5a1a:	fc 4f       	sbci	r31, 0xFC	; 252
    5a1c:	60 81       	ld	r22, Z
    5a1e:	71 81       	ldd	r23, Z+1	; 0x01
    5a20:	5b 96       	adiw	r26, 0x1b	; 27
    5a22:	9c 90       	ld	r9, X
    5a24:	5b 97       	sbiw	r26, 0x1b	; 27
    5a26:	5a 96       	adiw	r26, 0x1a	; 26
    5a28:	8c 90       	ld	r8, X
    5a2a:	5a 97       	sbiw	r26, 0x1a	; 26
    5a2c:	50 96       	adiw	r26, 0x10	; 16
    5a2e:	8d 91       	ld	r24, X+
    5a30:	9c 91       	ld	r25, X
    5a32:	51 97       	sbiw	r26, 0x11	; 17
    5a34:	89 2b       	or	r24, r25
    5a36:	19 f4       	brne	.+6      	; 0x5a3e <generate_tcp_stats+0xd4>
    5a38:	40 e2       	ldi	r20, 0x20	; 32
    5a3a:	50 e0       	ldi	r21, 0x00	; 0
    5a3c:	02 c0       	rjmp	.+4      	; 0x5a42 <generate_tcp_stats+0xd8>
    5a3e:	4a e2       	ldi	r20, 0x2A	; 42
    5a40:	50 e0       	ldi	r21, 0x00	; 0
    5a42:	24 fd       	sbrc	r18, 4
    5a44:	03 c0       	rjmp	.+6      	; 0x5a4c <generate_tcp_stats+0xe2>
    5a46:	20 e2       	ldi	r18, 0x20	; 32
    5a48:	30 e0       	ldi	r19, 0x00	; 0
    5a4a:	02 c0       	rjmp	.+4      	; 0x5a50 <generate_tcp_stats+0xe6>
    5a4c:	21 e2       	ldi	r18, 0x21	; 33
    5a4e:	30 e0       	ldi	r19, 0x00	; 0
    5a50:	ed b7       	in	r30, 0x3d	; 61
    5a52:	fe b7       	in	r31, 0x3e	; 62
    5a54:	7c 97       	sbiw	r30, 0x1c	; 28
    5a56:	0f b6       	in	r0, 0x3f	; 63
    5a58:	f8 94       	cli
    5a5a:	fe bf       	out	0x3e, r31	; 62
    5a5c:	0f be       	out	0x3f, r0	; 63
    5a5e:	ed bf       	out	0x3d, r30	; 61
    5a60:	31 96       	adiw	r30, 0x01	; 1
    5a62:	ad b7       	in	r26, 0x3d	; 61
    5a64:	be b7       	in	r27, 0x3e	; 62
    5a66:	12 96       	adiw	r26, 0x02	; 2
    5a68:	dc 92       	st	X, r13
    5a6a:	ce 92       	st	-X, r12
    5a6c:	11 97       	sbiw	r26, 0x01	; 1
    5a6e:	86 ea       	ldi	r24, 0xA6	; 166
    5a70:	95 e0       	ldi	r25, 0x05	; 5
    5a72:	93 83       	std	Z+3, r25	; 0x03
    5a74:	82 83       	std	Z+2, r24	; 0x02
    5a76:	82 ea       	ldi	r24, 0xA2	; 162
    5a78:	92 e0       	ldi	r25, 0x02	; 2
    5a7a:	95 83       	std	Z+5, r25	; 0x05
    5a7c:	84 83       	std	Z+4, r24	; 0x04
    5a7e:	b7 82       	std	Z+7, r11	; 0x07
    5a80:	a6 82       	std	Z+6, r10	; 0x06
    5a82:	60 86       	std	Z+8, r6	; 0x08
    5a84:	11 86       	std	Z+9, r1	; 0x09
    5a86:	bf ef       	ldi	r27, 0xFF	; 255
    5a88:	eb 22       	and	r14, r27
    5a8a:	ff 24       	eor	r15, r15
    5a8c:	f3 86       	std	Z+11, r15	; 0x0b
    5a8e:	e2 86       	std	Z+10, r14	; 0x0a
    5a90:	74 86       	std	Z+12, r7	; 0x0c
    5a92:	15 86       	std	Z+13, r1	; 0x0d
    5a94:	d0 70       	andi	r29, 0x00	; 0
    5a96:	d7 87       	std	Z+15, r29	; 0x0f
    5a98:	c6 87       	std	Z+14, r28	; 0x0e
    5a9a:	51 8a       	std	Z+17, r5	; 0x11
    5a9c:	40 8a       	std	Z+16, r4	; 0x10
    5a9e:	73 8b       	std	Z+19, r23	; 0x13
    5aa0:	62 8b       	std	Z+18, r22	; 0x12
    5aa2:	94 8a       	std	Z+20, r9	; 0x14
    5aa4:	15 8a       	std	Z+21, r1	; 0x15
    5aa6:	86 8a       	std	Z+22, r8	; 0x16
    5aa8:	17 8a       	std	Z+23, r1	; 0x17
    5aaa:	51 8f       	std	Z+25, r21	; 0x19
    5aac:	40 8f       	std	Z+24, r20	; 0x18
    5aae:	33 8f       	std	Z+27, r19	; 0x1b
    5ab0:	22 8f       	std	Z+26, r18	; 0x1a
    5ab2:	0e 94 ae 2f 	call	0x5f5c	; 0x5f5c <snprintf>
    5ab6:	ed b7       	in	r30, 0x3d	; 61
    5ab8:	fe b7       	in	r31, 0x3e	; 62
    5aba:	7c 96       	adiw	r30, 0x1c	; 28
    5abc:	0f b6       	in	r0, 0x3f	; 63
    5abe:	f8 94       	cli
    5ac0:	fe bf       	out	0x3e, r31	; 62
    5ac2:	0f be       	out	0x3f, r0	; 63
    5ac4:	ed bf       	out	0x3d, r30	; 61
		 states[conn->tcpstateflags & UIP_TS_MASK],
		 conn->nrtx,
		 conn->timer,
		 (uip_outstanding(conn))? '*':' ',
		 (uip_stopped(conn))? '!':' ');
}
    5ac6:	df 91       	pop	r29
    5ac8:	cf 91       	pop	r28
    5aca:	1f 91       	pop	r17
    5acc:	0f 91       	pop	r16
    5ace:	ff 90       	pop	r15
    5ad0:	ef 90       	pop	r14
    5ad2:	df 90       	pop	r13
    5ad4:	cf 90       	pop	r12
    5ad6:	bf 90       	pop	r11
    5ad8:	af 90       	pop	r10
    5ada:	9f 90       	pop	r9
    5adc:	8f 90       	pop	r8
    5ade:	7f 90       	pop	r7
    5ae0:	6f 90       	pop	r6
    5ae2:	5f 90       	pop	r5
    5ae4:	4f 90       	pop	r4
    5ae6:	08 95       	ret

00005ae8 <file_stats>:
	return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE, "%5u", httpd_fs_count(f));
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(file_stats(struct httpd_state *s, char *ptr))
{
    5ae8:	cf 93       	push	r28
    5aea:	df 93       	push	r29
    5aec:	ec 01       	movw	r28, r24
  PSOCK_BEGIN(&s->sout);
    5aee:	8e 89       	ldd	r24, Y+22	; 0x16
    5af0:	9f 89       	ldd	r25, Y+23	; 0x17
    5af2:	00 97       	sbiw	r24, 0x00	; 0
    5af4:	21 f0       	breq	.+8      	; 0x5afe <file_stats+0x16>
    5af6:	83 36       	cpi	r24, 0x63	; 99
    5af8:	91 05       	cpc	r25, r1
    5afa:	a9 f4       	brne	.+42     	; 0x5b26 <file_stats+0x3e>
    5afc:	04 c0       	rjmp	.+8      	; 0x5b06 <file_stats+0x1e>

  PSOCK_GENERATOR_SEND(&s->sout, generate_file_stats, strchr(ptr, ' ') + 1);
    5afe:	83 e6       	ldi	r24, 0x63	; 99
    5b00:	90 e0       	ldi	r25, 0x00	; 0
    5b02:	9f 8b       	std	Y+23, r25	; 0x17
    5b04:	8e 8b       	std	Y+22, r24	; 0x16
    5b06:	cb 01       	movw	r24, r22
    5b08:	60 e2       	ldi	r22, 0x20	; 32
    5b0a:	70 e0       	ldi	r23, 0x00	; 0
    5b0c:	0e 94 48 2f 	call	0x5e90	; 0x5e90 <strchr>
    5b10:	ac 01       	movw	r20, r24
    5b12:	4f 5f       	subi	r20, 0xFF	; 255
    5b14:	5f 4f       	sbci	r21, 0xFF	; 255
    5b16:	ce 01       	movw	r24, r28
    5b18:	46 96       	adiw	r24, 0x16	; 22
    5b1a:	69 e9       	ldi	r22, 0x99	; 153
    5b1c:	7d e2       	ldi	r23, 0x2D	; 45
    5b1e:	0e 94 e4 24 	call	0x49c8	; 0x49c8 <psock_generator_send>
    5b22:	88 23       	and	r24, r24
    5b24:	19 f0       	breq	.+6      	; 0x5b2c <file_stats+0x44>
  
  PSOCK_END(&s->sout);
    5b26:	1f 8a       	std	Y+23, r1	; 0x17
    5b28:	1e 8a       	std	Y+22, r1	; 0x16
    5b2a:	82 e0       	ldi	r24, 0x02	; 2
}
    5b2c:	df 91       	pop	r29
    5b2e:	cf 91       	pop	r28
    5b30:	08 95       	ret

00005b32 <generate_file_stats>:
  return nullfunction;
}
/*---------------------------------------------------------------------------*/
static unsigned short
generate_file_stats(void *arg)
{
    5b32:	0f 93       	push	r16
    5b34:	1f 93       	push	r17
	char *f = (char *)arg;
	return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE, "%5u", httpd_fs_count(f));
    5b36:	00 91 6e 04 	lds	r16, 0x046E
    5b3a:	10 91 6f 04 	lds	r17, 0x046F
    5b3e:	0e 94 9c 2b 	call	0x5738	; 0x5738 <httpd_fs_count>
    5b42:	2d b7       	in	r18, 0x3d	; 61
    5b44:	3e b7       	in	r19, 0x3e	; 62
    5b46:	28 50       	subi	r18, 0x08	; 8
    5b48:	30 40       	sbci	r19, 0x00	; 0
    5b4a:	0f b6       	in	r0, 0x3f	; 63
    5b4c:	f8 94       	cli
    5b4e:	3e bf       	out	0x3e, r19	; 62
    5b50:	0f be       	out	0x3f, r0	; 63
    5b52:	2d bf       	out	0x3d, r18	; 61
    5b54:	ed b7       	in	r30, 0x3d	; 61
    5b56:	fe b7       	in	r31, 0x3e	; 62
    5b58:	31 96       	adiw	r30, 0x01	; 1
    5b5a:	ad b7       	in	r26, 0x3d	; 61
    5b5c:	be b7       	in	r27, 0x3e	; 62
    5b5e:	12 96       	adiw	r26, 0x02	; 2
    5b60:	1c 93       	st	X, r17
    5b62:	0e 93       	st	-X, r16
    5b64:	11 97       	sbiw	r26, 0x01	; 1
    5b66:	26 ea       	ldi	r18, 0xA6	; 166
    5b68:	35 e0       	ldi	r19, 0x05	; 5
    5b6a:	33 83       	std	Z+3, r19	; 0x03
    5b6c:	22 83       	std	Z+2, r18	; 0x02
    5b6e:	2f ef       	ldi	r18, 0xFF	; 255
    5b70:	32 e0       	ldi	r19, 0x02	; 2
    5b72:	35 83       	std	Z+5, r19	; 0x05
    5b74:	24 83       	std	Z+4, r18	; 0x04
    5b76:	97 83       	std	Z+7, r25	; 0x07
    5b78:	86 83       	std	Z+6, r24	; 0x06
    5b7a:	0e 94 ae 2f 	call	0x5f5c	; 0x5f5c <snprintf>
    5b7e:	2d b7       	in	r18, 0x3d	; 61
    5b80:	3e b7       	in	r19, 0x3e	; 62
    5b82:	28 5f       	subi	r18, 0xF8	; 248
    5b84:	3f 4f       	sbci	r19, 0xFF	; 255
    5b86:	0f b6       	in	r0, 0x3f	; 63
    5b88:	f8 94       	cli
    5b8a:	3e bf       	out	0x3e, r19	; 62
    5b8c:	0f be       	out	0x3f, r0	; 63
    5b8e:	2d bf       	out	0x3d, r18	; 61
}
    5b90:	1f 91       	pop	r17
    5b92:	0f 91       	pop	r16
    5b94:	08 95       	ret

00005b96 <malloc>:
    5b96:	cf 93       	push	r28
    5b98:	df 93       	push	r29
    5b9a:	bc 01       	movw	r22, r24
    5b9c:	82 30       	cpi	r24, 0x02	; 2
    5b9e:	91 05       	cpc	r25, r1
    5ba0:	10 f4       	brcc	.+4      	; 0x5ba6 <malloc+0x10>
    5ba2:	62 e0       	ldi	r22, 0x02	; 2
    5ba4:	70 e0       	ldi	r23, 0x00	; 0
    5ba6:	a0 91 ea 0b 	lds	r26, 0x0BEA
    5baa:	b0 91 eb 0b 	lds	r27, 0x0BEB
    5bae:	ed 01       	movw	r28, r26
    5bb0:	e0 e0       	ldi	r30, 0x00	; 0
    5bb2:	f0 e0       	ldi	r31, 0x00	; 0
    5bb4:	40 e0       	ldi	r20, 0x00	; 0
    5bb6:	50 e0       	ldi	r21, 0x00	; 0
    5bb8:	21 c0       	rjmp	.+66     	; 0x5bfc <malloc+0x66>
    5bba:	88 81       	ld	r24, Y
    5bbc:	99 81       	ldd	r25, Y+1	; 0x01
    5bbe:	86 17       	cp	r24, r22
    5bc0:	97 07       	cpc	r25, r23
    5bc2:	69 f4       	brne	.+26     	; 0x5bde <malloc+0x48>
    5bc4:	8a 81       	ldd	r24, Y+2	; 0x02
    5bc6:	9b 81       	ldd	r25, Y+3	; 0x03
    5bc8:	30 97       	sbiw	r30, 0x00	; 0
    5bca:	19 f0       	breq	.+6      	; 0x5bd2 <malloc+0x3c>
    5bcc:	93 83       	std	Z+3, r25	; 0x03
    5bce:	82 83       	std	Z+2, r24	; 0x02
    5bd0:	04 c0       	rjmp	.+8      	; 0x5bda <malloc+0x44>
    5bd2:	90 93 eb 0b 	sts	0x0BEB, r25
    5bd6:	80 93 ea 0b 	sts	0x0BEA, r24
    5bda:	fe 01       	movw	r30, r28
    5bdc:	34 c0       	rjmp	.+104    	; 0x5c46 <malloc+0xb0>
    5bde:	68 17       	cp	r22, r24
    5be0:	79 07       	cpc	r23, r25
    5be2:	38 f4       	brcc	.+14     	; 0x5bf2 <malloc+0x5c>
    5be4:	41 15       	cp	r20, r1
    5be6:	51 05       	cpc	r21, r1
    5be8:	19 f0       	breq	.+6      	; 0x5bf0 <malloc+0x5a>
    5bea:	84 17       	cp	r24, r20
    5bec:	95 07       	cpc	r25, r21
    5bee:	08 f4       	brcc	.+2      	; 0x5bf2 <malloc+0x5c>
    5bf0:	ac 01       	movw	r20, r24
    5bf2:	fe 01       	movw	r30, r28
    5bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf8:	9c 01       	movw	r18, r24
    5bfa:	e9 01       	movw	r28, r18
    5bfc:	20 97       	sbiw	r28, 0x00	; 0
    5bfe:	e9 f6       	brne	.-70     	; 0x5bba <malloc+0x24>
    5c00:	41 15       	cp	r20, r1
    5c02:	51 05       	cpc	r21, r1
    5c04:	a9 f1       	breq	.+106    	; 0x5c70 <malloc+0xda>
    5c06:	ca 01       	movw	r24, r20
    5c08:	86 1b       	sub	r24, r22
    5c0a:	97 0b       	sbc	r25, r23
    5c0c:	04 97       	sbiw	r24, 0x04	; 4
    5c0e:	08 f4       	brcc	.+2      	; 0x5c12 <malloc+0x7c>
    5c10:	ba 01       	movw	r22, r20
    5c12:	e0 e0       	ldi	r30, 0x00	; 0
    5c14:	f0 e0       	ldi	r31, 0x00	; 0
    5c16:	2a c0       	rjmp	.+84     	; 0x5c6c <malloc+0xd6>
    5c18:	8d 91       	ld	r24, X+
    5c1a:	9c 91       	ld	r25, X
    5c1c:	11 97       	sbiw	r26, 0x01	; 1
    5c1e:	84 17       	cp	r24, r20
    5c20:	95 07       	cpc	r25, r21
    5c22:	f9 f4       	brne	.+62     	; 0x5c62 <malloc+0xcc>
    5c24:	64 17       	cp	r22, r20
    5c26:	75 07       	cpc	r23, r21
    5c28:	81 f4       	brne	.+32     	; 0x5c4a <malloc+0xb4>
    5c2a:	12 96       	adiw	r26, 0x02	; 2
    5c2c:	8d 91       	ld	r24, X+
    5c2e:	9c 91       	ld	r25, X
    5c30:	13 97       	sbiw	r26, 0x03	; 3
    5c32:	30 97       	sbiw	r30, 0x00	; 0
    5c34:	19 f0       	breq	.+6      	; 0x5c3c <malloc+0xa6>
    5c36:	93 83       	std	Z+3, r25	; 0x03
    5c38:	82 83       	std	Z+2, r24	; 0x02
    5c3a:	04 c0       	rjmp	.+8      	; 0x5c44 <malloc+0xae>
    5c3c:	90 93 eb 0b 	sts	0x0BEB, r25
    5c40:	80 93 ea 0b 	sts	0x0BEA, r24
    5c44:	fd 01       	movw	r30, r26
    5c46:	32 96       	adiw	r30, 0x02	; 2
    5c48:	4f c0       	rjmp	.+158    	; 0x5ce8 <malloc+0x152>
    5c4a:	ca 01       	movw	r24, r20
    5c4c:	86 1b       	sub	r24, r22
    5c4e:	97 0b       	sbc	r25, r23
    5c50:	fd 01       	movw	r30, r26
    5c52:	e8 0f       	add	r30, r24
    5c54:	f9 1f       	adc	r31, r25
    5c56:	61 93       	st	Z+, r22
    5c58:	71 93       	st	Z+, r23
    5c5a:	02 97       	sbiw	r24, 0x02	; 2
    5c5c:	8d 93       	st	X+, r24
    5c5e:	9c 93       	st	X, r25
    5c60:	43 c0       	rjmp	.+134    	; 0x5ce8 <malloc+0x152>
    5c62:	fd 01       	movw	r30, r26
    5c64:	82 81       	ldd	r24, Z+2	; 0x02
    5c66:	93 81       	ldd	r25, Z+3	; 0x03
    5c68:	9c 01       	movw	r18, r24
    5c6a:	d9 01       	movw	r26, r18
    5c6c:	10 97       	sbiw	r26, 0x00	; 0
    5c6e:	a1 f6       	brne	.-88     	; 0x5c18 <malloc+0x82>
    5c70:	80 91 e8 0b 	lds	r24, 0x0BE8
    5c74:	90 91 e9 0b 	lds	r25, 0x0BE9
    5c78:	89 2b       	or	r24, r25
    5c7a:	41 f4       	brne	.+16     	; 0x5c8c <malloc+0xf6>
    5c7c:	80 91 a6 03 	lds	r24, 0x03A6
    5c80:	90 91 a7 03 	lds	r25, 0x03A7
    5c84:	90 93 e9 0b 	sts	0x0BE9, r25
    5c88:	80 93 e8 0b 	sts	0x0BE8, r24
    5c8c:	40 91 a8 03 	lds	r20, 0x03A8
    5c90:	50 91 a9 03 	lds	r21, 0x03A9
    5c94:	41 15       	cp	r20, r1
    5c96:	51 05       	cpc	r21, r1
    5c98:	41 f4       	brne	.+16     	; 0x5caa <malloc+0x114>
    5c9a:	4d b7       	in	r20, 0x3d	; 61
    5c9c:	5e b7       	in	r21, 0x3e	; 62
    5c9e:	80 91 a4 03 	lds	r24, 0x03A4
    5ca2:	90 91 a5 03 	lds	r25, 0x03A5
    5ca6:	48 1b       	sub	r20, r24
    5ca8:	59 0b       	sbc	r21, r25
    5caa:	20 91 e8 0b 	lds	r18, 0x0BE8
    5cae:	30 91 e9 0b 	lds	r19, 0x0BE9
    5cb2:	24 17       	cp	r18, r20
    5cb4:	35 07       	cpc	r19, r21
    5cb6:	b0 f4       	brcc	.+44     	; 0x5ce4 <malloc+0x14e>
    5cb8:	ca 01       	movw	r24, r20
    5cba:	82 1b       	sub	r24, r18
    5cbc:	93 0b       	sbc	r25, r19
    5cbe:	86 17       	cp	r24, r22
    5cc0:	97 07       	cpc	r25, r23
    5cc2:	80 f0       	brcs	.+32     	; 0x5ce4 <malloc+0x14e>
    5cc4:	ab 01       	movw	r20, r22
    5cc6:	4e 5f       	subi	r20, 0xFE	; 254
    5cc8:	5f 4f       	sbci	r21, 0xFF	; 255
    5cca:	84 17       	cp	r24, r20
    5ccc:	95 07       	cpc	r25, r21
    5cce:	50 f0       	brcs	.+20     	; 0x5ce4 <malloc+0x14e>
    5cd0:	42 0f       	add	r20, r18
    5cd2:	53 1f       	adc	r21, r19
    5cd4:	50 93 e9 0b 	sts	0x0BE9, r21
    5cd8:	40 93 e8 0b 	sts	0x0BE8, r20
    5cdc:	f9 01       	movw	r30, r18
    5cde:	61 93       	st	Z+, r22
    5ce0:	71 93       	st	Z+, r23
    5ce2:	02 c0       	rjmp	.+4      	; 0x5ce8 <malloc+0x152>
    5ce4:	e0 e0       	ldi	r30, 0x00	; 0
    5ce6:	f0 e0       	ldi	r31, 0x00	; 0
    5ce8:	cf 01       	movw	r24, r30
    5cea:	df 91       	pop	r29
    5cec:	cf 91       	pop	r28
    5cee:	08 95       	ret

00005cf0 <free>:
    5cf0:	cf 93       	push	r28
    5cf2:	df 93       	push	r29
    5cf4:	00 97       	sbiw	r24, 0x00	; 0
    5cf6:	09 f4       	brne	.+2      	; 0x5cfa <free+0xa>
    5cf8:	50 c0       	rjmp	.+160    	; 0x5d9a <free+0xaa>
    5cfa:	ec 01       	movw	r28, r24
    5cfc:	22 97       	sbiw	r28, 0x02	; 2
    5cfe:	1b 82       	std	Y+3, r1	; 0x03
    5d00:	1a 82       	std	Y+2, r1	; 0x02
    5d02:	a0 91 ea 0b 	lds	r26, 0x0BEA
    5d06:	b0 91 eb 0b 	lds	r27, 0x0BEB
    5d0a:	10 97       	sbiw	r26, 0x00	; 0
    5d0c:	09 f1       	breq	.+66     	; 0x5d50 <free+0x60>
    5d0e:	40 e0       	ldi	r20, 0x00	; 0
    5d10:	50 e0       	ldi	r21, 0x00	; 0
    5d12:	ac 17       	cp	r26, r28
    5d14:	bd 07       	cpc	r27, r29
    5d16:	08 f1       	brcs	.+66     	; 0x5d5a <free+0x6a>
    5d18:	bb 83       	std	Y+3, r27	; 0x03
    5d1a:	aa 83       	std	Y+2, r26	; 0x02
    5d1c:	fe 01       	movw	r30, r28
    5d1e:	21 91       	ld	r18, Z+
    5d20:	31 91       	ld	r19, Z+
    5d22:	e2 0f       	add	r30, r18
    5d24:	f3 1f       	adc	r31, r19
    5d26:	ae 17       	cp	r26, r30
    5d28:	bf 07       	cpc	r27, r31
    5d2a:	79 f4       	brne	.+30     	; 0x5d4a <free+0x5a>
    5d2c:	8d 91       	ld	r24, X+
    5d2e:	9c 91       	ld	r25, X
    5d30:	11 97       	sbiw	r26, 0x01	; 1
    5d32:	28 0f       	add	r18, r24
    5d34:	39 1f       	adc	r19, r25
    5d36:	2e 5f       	subi	r18, 0xFE	; 254
    5d38:	3f 4f       	sbci	r19, 0xFF	; 255
    5d3a:	39 83       	std	Y+1, r19	; 0x01
    5d3c:	28 83       	st	Y, r18
    5d3e:	12 96       	adiw	r26, 0x02	; 2
    5d40:	8d 91       	ld	r24, X+
    5d42:	9c 91       	ld	r25, X
    5d44:	13 97       	sbiw	r26, 0x03	; 3
    5d46:	9b 83       	std	Y+3, r25	; 0x03
    5d48:	8a 83       	std	Y+2, r24	; 0x02
    5d4a:	41 15       	cp	r20, r1
    5d4c:	51 05       	cpc	r21, r1
    5d4e:	71 f4       	brne	.+28     	; 0x5d6c <free+0x7c>
    5d50:	d0 93 eb 0b 	sts	0x0BEB, r29
    5d54:	c0 93 ea 0b 	sts	0x0BEA, r28
    5d58:	20 c0       	rjmp	.+64     	; 0x5d9a <free+0xaa>
    5d5a:	12 96       	adiw	r26, 0x02	; 2
    5d5c:	8d 91       	ld	r24, X+
    5d5e:	9c 91       	ld	r25, X
    5d60:	13 97       	sbiw	r26, 0x03	; 3
    5d62:	ad 01       	movw	r20, r26
    5d64:	00 97       	sbiw	r24, 0x00	; 0
    5d66:	11 f0       	breq	.+4      	; 0x5d6c <free+0x7c>
    5d68:	dc 01       	movw	r26, r24
    5d6a:	d3 cf       	rjmp	.-90     	; 0x5d12 <free+0x22>
    5d6c:	fa 01       	movw	r30, r20
    5d6e:	d3 83       	std	Z+3, r29	; 0x03
    5d70:	c2 83       	std	Z+2, r28	; 0x02
    5d72:	21 91       	ld	r18, Z+
    5d74:	31 91       	ld	r19, Z+
    5d76:	e2 0f       	add	r30, r18
    5d78:	f3 1f       	adc	r31, r19
    5d7a:	ce 17       	cp	r28, r30
    5d7c:	df 07       	cpc	r29, r31
    5d7e:	69 f4       	brne	.+26     	; 0x5d9a <free+0xaa>
    5d80:	88 81       	ld	r24, Y
    5d82:	99 81       	ldd	r25, Y+1	; 0x01
    5d84:	28 0f       	add	r18, r24
    5d86:	39 1f       	adc	r19, r25
    5d88:	2e 5f       	subi	r18, 0xFE	; 254
    5d8a:	3f 4f       	sbci	r19, 0xFF	; 255
    5d8c:	fa 01       	movw	r30, r20
    5d8e:	31 83       	std	Z+1, r19	; 0x01
    5d90:	20 83       	st	Z, r18
    5d92:	8a 81       	ldd	r24, Y+2	; 0x02
    5d94:	9b 81       	ldd	r25, Y+3	; 0x03
    5d96:	93 83       	std	Z+3, r25	; 0x03
    5d98:	82 83       	std	Z+2, r24	; 0x02
    5d9a:	df 91       	pop	r29
    5d9c:	cf 91       	pop	r28
    5d9e:	08 95       	ret

00005da0 <atoi>:
    5da0:	fc 01       	movw	r30, r24
    5da2:	88 27       	eor	r24, r24
    5da4:	99 27       	eor	r25, r25
    5da6:	e8 94       	clt
    5da8:	21 91       	ld	r18, Z+
    5daa:	20 32       	cpi	r18, 0x20	; 32
    5dac:	e9 f3       	breq	.-6      	; 0x5da8 <atoi+0x8>
    5dae:	29 30       	cpi	r18, 0x09	; 9
    5db0:	10 f0       	brcs	.+4      	; 0x5db6 <atoi+0x16>
    5db2:	2e 30       	cpi	r18, 0x0E	; 14
    5db4:	c8 f3       	brcs	.-14     	; 0x5da8 <atoi+0x8>
    5db6:	2b 32       	cpi	r18, 0x2B	; 43
    5db8:	41 f0       	breq	.+16     	; 0x5dca <atoi+0x2a>
    5dba:	2d 32       	cpi	r18, 0x2D	; 45
    5dbc:	39 f4       	brne	.+14     	; 0x5dcc <atoi+0x2c>
    5dbe:	68 94       	set
    5dc0:	04 c0       	rjmp	.+8      	; 0x5dca <atoi+0x2a>
    5dc2:	0e 94 a6 2f 	call	0x5f4c	; 0x5f4c <__mulhi_const_10>
    5dc6:	82 0f       	add	r24, r18
    5dc8:	91 1d       	adc	r25, r1
    5dca:	21 91       	ld	r18, Z+
    5dcc:	20 53       	subi	r18, 0x30	; 48
    5dce:	2a 30       	cpi	r18, 0x0A	; 10
    5dd0:	c0 f3       	brcs	.-16     	; 0x5dc2 <atoi+0x22>
    5dd2:	1e f4       	brtc	.+6      	; 0x5dda <atoi+0x3a>
    5dd4:	90 95       	com	r25
    5dd6:	81 95       	neg	r24
    5dd8:	9f 4f       	sbci	r25, 0xFF	; 255
    5dda:	08 95       	ret

00005ddc <memcpy_P>:
    5ddc:	fb 01       	movw	r30, r22
    5dde:	dc 01       	movw	r26, r24
    5de0:	02 c0       	rjmp	.+4      	; 0x5de6 <memcpy_P+0xa>
    5de2:	05 90       	lpm	r0, Z+
    5de4:	0d 92       	st	X+, r0
    5de6:	41 50       	subi	r20, 0x01	; 1
    5de8:	50 40       	sbci	r21, 0x00	; 0
    5dea:	d8 f7       	brcc	.-10     	; 0x5de2 <memcpy_P+0x6>
    5dec:	08 95       	ret

00005dee <strchr_P>:
    5dee:	fc 01       	movw	r30, r24
    5df0:	05 90       	lpm	r0, Z+
    5df2:	06 16       	cp	r0, r22
    5df4:	21 f0       	breq	.+8      	; 0x5dfe <strchr_P+0x10>
    5df6:	00 20       	and	r0, r0
    5df8:	d9 f7       	brne	.-10     	; 0x5df0 <strchr_P+0x2>
    5dfa:	c0 01       	movw	r24, r0
    5dfc:	08 95       	ret
    5dfe:	31 97       	sbiw	r30, 0x01	; 1
    5e00:	cf 01       	movw	r24, r30
    5e02:	08 95       	ret

00005e04 <strcmp_P>:
    5e04:	fb 01       	movw	r30, r22
    5e06:	dc 01       	movw	r26, r24
    5e08:	8d 91       	ld	r24, X+
    5e0a:	05 90       	lpm	r0, Z+
    5e0c:	80 19       	sub	r24, r0
    5e0e:	01 10       	cpse	r0, r1
    5e10:	d9 f3       	breq	.-10     	; 0x5e08 <strcmp_P+0x4>
    5e12:	99 0b       	sbc	r25, r25
    5e14:	08 95       	ret

00005e16 <strcpy_P>:
    5e16:	fb 01       	movw	r30, r22
    5e18:	dc 01       	movw	r26, r24
    5e1a:	05 90       	lpm	r0, Z+
    5e1c:	0d 92       	st	X+, r0
    5e1e:	00 20       	and	r0, r0
    5e20:	e1 f7       	brne	.-8      	; 0x5e1a <strcpy_P+0x4>
    5e22:	08 95       	ret

00005e24 <strlen_P>:
    5e24:	fc 01       	movw	r30, r24
    5e26:	05 90       	lpm	r0, Z+
    5e28:	00 20       	and	r0, r0
    5e2a:	e9 f7       	brne	.-6      	; 0x5e26 <strlen_P+0x2>
    5e2c:	80 95       	com	r24
    5e2e:	90 95       	com	r25
    5e30:	8e 0f       	add	r24, r30
    5e32:	9f 1f       	adc	r25, r31
    5e34:	08 95       	ret

00005e36 <strncmp_P>:
    5e36:	fb 01       	movw	r30, r22
    5e38:	dc 01       	movw	r26, r24
    5e3a:	41 50       	subi	r20, 0x01	; 1
    5e3c:	50 40       	sbci	r21, 0x00	; 0
    5e3e:	30 f0       	brcs	.+12     	; 0x5e4c <strncmp_P+0x16>
    5e40:	8d 91       	ld	r24, X+
    5e42:	05 90       	lpm	r0, Z+
    5e44:	80 19       	sub	r24, r0
    5e46:	19 f4       	brne	.+6      	; 0x5e4e <strncmp_P+0x18>
    5e48:	00 20       	and	r0, r0
    5e4a:	b9 f7       	brne	.-18     	; 0x5e3a <strncmp_P+0x4>
    5e4c:	88 1b       	sub	r24, r24
    5e4e:	99 0b       	sbc	r25, r25
    5e50:	08 95       	ret

00005e52 <strncpy_P>:
    5e52:	fb 01       	movw	r30, r22
    5e54:	dc 01       	movw	r26, r24
    5e56:	41 50       	subi	r20, 0x01	; 1
    5e58:	50 40       	sbci	r21, 0x00	; 0
    5e5a:	48 f0       	brcs	.+18     	; 0x5e6e <strncpy_P+0x1c>
    5e5c:	05 90       	lpm	r0, Z+
    5e5e:	0d 92       	st	X+, r0
    5e60:	00 20       	and	r0, r0
    5e62:	c9 f7       	brne	.-14     	; 0x5e56 <strncpy_P+0x4>
    5e64:	01 c0       	rjmp	.+2      	; 0x5e68 <strncpy_P+0x16>
    5e66:	1d 92       	st	X+, r1
    5e68:	41 50       	subi	r20, 0x01	; 1
    5e6a:	50 40       	sbci	r21, 0x00	; 0
    5e6c:	e0 f7       	brcc	.-8      	; 0x5e66 <strncpy_P+0x14>
    5e6e:	08 95       	ret

00005e70 <memcpy>:
    5e70:	fb 01       	movw	r30, r22
    5e72:	dc 01       	movw	r26, r24
    5e74:	02 c0       	rjmp	.+4      	; 0x5e7a <memcpy+0xa>
    5e76:	01 90       	ld	r0, Z+
    5e78:	0d 92       	st	X+, r0
    5e7a:	41 50       	subi	r20, 0x01	; 1
    5e7c:	50 40       	sbci	r21, 0x00	; 0
    5e7e:	d8 f7       	brcc	.-10     	; 0x5e76 <memcpy+0x6>
    5e80:	08 95       	ret

00005e82 <memset>:
    5e82:	dc 01       	movw	r26, r24
    5e84:	01 c0       	rjmp	.+2      	; 0x5e88 <memset+0x6>
    5e86:	6d 93       	st	X+, r22
    5e88:	41 50       	subi	r20, 0x01	; 1
    5e8a:	50 40       	sbci	r21, 0x00	; 0
    5e8c:	e0 f7       	brcc	.-8      	; 0x5e86 <memset+0x4>
    5e8e:	08 95       	ret

00005e90 <strchr>:
    5e90:	fc 01       	movw	r30, r24
    5e92:	81 91       	ld	r24, Z+
    5e94:	86 17       	cp	r24, r22
    5e96:	21 f0       	breq	.+8      	; 0x5ea0 <strchr+0x10>
    5e98:	88 23       	and	r24, r24
    5e9a:	d9 f7       	brne	.-10     	; 0x5e92 <strchr+0x2>
    5e9c:	99 27       	eor	r25, r25
    5e9e:	08 95       	ret
    5ea0:	31 97       	sbiw	r30, 0x01	; 1
    5ea2:	cf 01       	movw	r24, r30
    5ea4:	08 95       	ret

00005ea6 <strncmp>:
    5ea6:	fb 01       	movw	r30, r22
    5ea8:	dc 01       	movw	r26, r24
    5eaa:	41 50       	subi	r20, 0x01	; 1
    5eac:	50 40       	sbci	r21, 0x00	; 0
    5eae:	30 f0       	brcs	.+12     	; 0x5ebc <strncmp+0x16>
    5eb0:	8d 91       	ld	r24, X+
    5eb2:	01 90       	ld	r0, Z+
    5eb4:	80 19       	sub	r24, r0
    5eb6:	19 f4       	brne	.+6      	; 0x5ebe <strncmp+0x18>
    5eb8:	00 20       	and	r0, r0
    5eba:	b9 f7       	brne	.-18     	; 0x5eaa <strncmp+0x4>
    5ebc:	88 1b       	sub	r24, r24
    5ebe:	99 0b       	sbc	r25, r25
    5ec0:	08 95       	ret

00005ec2 <strncpy>:
    5ec2:	fb 01       	movw	r30, r22
    5ec4:	dc 01       	movw	r26, r24
    5ec6:	41 50       	subi	r20, 0x01	; 1
    5ec8:	50 40       	sbci	r21, 0x00	; 0
    5eca:	48 f0       	brcs	.+18     	; 0x5ede <strncpy+0x1c>
    5ecc:	01 90       	ld	r0, Z+
    5ece:	0d 92       	st	X+, r0
    5ed0:	00 20       	and	r0, r0
    5ed2:	c9 f7       	brne	.-14     	; 0x5ec6 <strncpy+0x4>
    5ed4:	01 c0       	rjmp	.+2      	; 0x5ed8 <strncpy+0x16>
    5ed6:	1d 92       	st	X+, r1
    5ed8:	41 50       	subi	r20, 0x01	; 1
    5eda:	50 40       	sbci	r21, 0x00	; 0
    5edc:	e0 f7       	brcc	.-8      	; 0x5ed6 <strncpy+0x14>
    5ede:	08 95       	ret

00005ee0 <strrchr>:
    5ee0:	fc 01       	movw	r30, r24
    5ee2:	81 e0       	ldi	r24, 0x01	; 1
    5ee4:	90 e0       	ldi	r25, 0x00	; 0
    5ee6:	01 90       	ld	r0, Z+
    5ee8:	06 16       	cp	r0, r22
    5eea:	09 f4       	brne	.+2      	; 0x5eee <strrchr+0xe>
    5eec:	cf 01       	movw	r24, r30
    5eee:	00 20       	and	r0, r0
    5ef0:	d1 f7       	brne	.-12     	; 0x5ee6 <strrchr+0x6>
    5ef2:	01 97       	sbiw	r24, 0x01	; 1
    5ef4:	08 95       	ret

00005ef6 <strupr>:
    5ef6:	dc 01       	movw	r26, r24
    5ef8:	6c 91       	ld	r22, X
    5efa:	61 56       	subi	r22, 0x61	; 97
    5efc:	6a 31       	cpi	r22, 0x1A	; 26
    5efe:	08 f0       	brcs	.+2      	; 0x5f02 <strupr+0xc>
    5f00:	60 5e       	subi	r22, 0xE0	; 224
    5f02:	6f 5b       	subi	r22, 0xBF	; 191
    5f04:	6d 93       	st	X+, r22
    5f06:	c1 f7       	brne	.-16     	; 0x5ef8 <strupr+0x2>
    5f08:	08 95       	ret

00005f0a <itoa>:
    5f0a:	fb 01       	movw	r30, r22
    5f0c:	9f 01       	movw	r18, r30
    5f0e:	e8 94       	clt
    5f10:	42 30       	cpi	r20, 0x02	; 2
    5f12:	c4 f0       	brlt	.+48     	; 0x5f44 <itoa+0x3a>
    5f14:	45 32       	cpi	r20, 0x25	; 37
    5f16:	b4 f4       	brge	.+44     	; 0x5f44 <itoa+0x3a>
    5f18:	4a 30       	cpi	r20, 0x0A	; 10
    5f1a:	29 f4       	brne	.+10     	; 0x5f26 <itoa+0x1c>
    5f1c:	97 fb       	bst	r25, 7
    5f1e:	1e f4       	brtc	.+6      	; 0x5f26 <itoa+0x1c>
    5f20:	90 95       	com	r25
    5f22:	81 95       	neg	r24
    5f24:	9f 4f       	sbci	r25, 0xFF	; 255
    5f26:	64 2f       	mov	r22, r20
    5f28:	77 27       	eor	r23, r23
    5f2a:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <__udivmodhi4>
    5f2e:	80 5d       	subi	r24, 0xD0	; 208
    5f30:	8a 33       	cpi	r24, 0x3A	; 58
    5f32:	0c f0       	brlt	.+2      	; 0x5f36 <itoa+0x2c>
    5f34:	89 5d       	subi	r24, 0xD9	; 217
    5f36:	81 93       	st	Z+, r24
    5f38:	cb 01       	movw	r24, r22
    5f3a:	00 97       	sbiw	r24, 0x00	; 0
    5f3c:	a1 f7       	brne	.-24     	; 0x5f26 <itoa+0x1c>
    5f3e:	16 f4       	brtc	.+4      	; 0x5f44 <itoa+0x3a>
    5f40:	5d e2       	ldi	r21, 0x2D	; 45
    5f42:	51 93       	st	Z+, r21
    5f44:	10 82       	st	Z, r1
    5f46:	c9 01       	movw	r24, r18
    5f48:	0c 94 d2 31 	jmp	0x63a4	; 0x63a4 <strrev>

00005f4c <__mulhi_const_10>:
    5f4c:	7a e0       	ldi	r23, 0x0A	; 10
    5f4e:	97 9f       	mul	r25, r23
    5f50:	90 2d       	mov	r25, r0
    5f52:	87 9f       	mul	r24, r23
    5f54:	80 2d       	mov	r24, r0
    5f56:	91 0d       	add	r25, r1
    5f58:	11 24       	eor	r1, r1
    5f5a:	08 95       	ret

00005f5c <snprintf>:
    5f5c:	ae e0       	ldi	r26, 0x0E	; 14
    5f5e:	b0 e0       	ldi	r27, 0x00	; 0
    5f60:	e4 eb       	ldi	r30, 0xB4	; 180
    5f62:	ff e2       	ldi	r31, 0x2F	; 47
    5f64:	0c 94 8e 32 	jmp	0x651c	; 0x651c <__prologue_saves__+0x1c>
    5f68:	0d 89       	ldd	r16, Y+21	; 0x15
    5f6a:	1e 89       	ldd	r17, Y+22	; 0x16
    5f6c:	8f 89       	ldd	r24, Y+23	; 0x17
    5f6e:	98 8d       	ldd	r25, Y+24	; 0x18
    5f70:	97 ff       	sbrs	r25, 7
    5f72:	02 c0       	rjmp	.+4      	; 0x5f78 <snprintf+0x1c>
    5f74:	80 e0       	ldi	r24, 0x00	; 0
    5f76:	90 e8       	ldi	r25, 0x80	; 128
    5f78:	01 97       	sbiw	r24, 0x01	; 1
    5f7a:	9e 83       	std	Y+6, r25	; 0x06
    5f7c:	8d 83       	std	Y+5, r24	; 0x05
    5f7e:	1a 83       	std	Y+2, r17	; 0x02
    5f80:	09 83       	std	Y+1, r16	; 0x01
    5f82:	86 e0       	ldi	r24, 0x06	; 6
    5f84:	8c 83       	std	Y+4, r24	; 0x04
    5f86:	9e 01       	movw	r18, r28
    5f88:	25 5e       	subi	r18, 0xE5	; 229
    5f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f8c:	ce 01       	movw	r24, r28
    5f8e:	01 96       	adiw	r24, 0x01	; 1
    5f90:	69 8d       	ldd	r22, Y+25	; 0x19
    5f92:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5f94:	a9 01       	movw	r20, r18
    5f96:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vfprintf>
    5f9a:	4d 81       	ldd	r20, Y+5	; 0x05
    5f9c:	5e 81       	ldd	r21, Y+6	; 0x06
    5f9e:	57 fd       	sbrc	r21, 7
    5fa0:	0a c0       	rjmp	.+20     	; 0x5fb6 <snprintf+0x5a>
    5fa2:	2f 81       	ldd	r18, Y+7	; 0x07
    5fa4:	38 85       	ldd	r19, Y+8	; 0x08
    5fa6:	42 17       	cp	r20, r18
    5fa8:	53 07       	cpc	r21, r19
    5faa:	0c f4       	brge	.+2      	; 0x5fae <snprintf+0x52>
    5fac:	9a 01       	movw	r18, r20
    5fae:	02 0f       	add	r16, r18
    5fb0:	13 1f       	adc	r17, r19
    5fb2:	f8 01       	movw	r30, r16
    5fb4:	10 82       	st	Z, r1
    5fb6:	2e 96       	adiw	r28, 0x0e	; 14
    5fb8:	e4 e0       	ldi	r30, 0x04	; 4
    5fba:	0c 94 aa 32 	jmp	0x6554	; 0x6554 <__epilogue_restores__+0x1c>

00005fbe <vfprintf>:
    5fbe:	ab e0       	ldi	r26, 0x0B	; 11
    5fc0:	b0 e0       	ldi	r27, 0x00	; 0
    5fc2:	e5 ee       	ldi	r30, 0xE5	; 229
    5fc4:	ff e2       	ldi	r31, 0x2F	; 47
    5fc6:	0c 94 80 32 	jmp	0x6500	; 0x6500 <__prologue_saves__>
    5fca:	3c 01       	movw	r6, r24
    5fcc:	2b 01       	movw	r4, r22
    5fce:	5a 01       	movw	r10, r20
    5fd0:	fc 01       	movw	r30, r24
    5fd2:	17 82       	std	Z+7, r1	; 0x07
    5fd4:	16 82       	std	Z+6, r1	; 0x06
    5fd6:	83 81       	ldd	r24, Z+3	; 0x03
    5fd8:	81 fd       	sbrc	r24, 1
    5fda:	03 c0       	rjmp	.+6      	; 0x5fe2 <vfprintf+0x24>
    5fdc:	6f ef       	ldi	r22, 0xFF	; 255
    5fde:	7f ef       	ldi	r23, 0xFF	; 255
    5fe0:	c6 c1       	rjmp	.+908    	; 0x636e <vfprintf+0x3b0>
    5fe2:	9a e0       	ldi	r25, 0x0A	; 10
    5fe4:	89 2e       	mov	r8, r25
    5fe6:	1e 01       	movw	r2, r28
    5fe8:	08 94       	sec
    5fea:	21 1c       	adc	r2, r1
    5fec:	31 1c       	adc	r3, r1
    5fee:	f3 01       	movw	r30, r6
    5ff0:	23 81       	ldd	r18, Z+3	; 0x03
    5ff2:	f2 01       	movw	r30, r4
    5ff4:	23 fd       	sbrc	r18, 3
    5ff6:	85 91       	lpm	r24, Z+
    5ff8:	23 ff       	sbrs	r18, 3
    5ffa:	81 91       	ld	r24, Z+
    5ffc:	2f 01       	movw	r4, r30
    5ffe:	88 23       	and	r24, r24
    6000:	09 f4       	brne	.+2      	; 0x6004 <vfprintf+0x46>
    6002:	b2 c1       	rjmp	.+868    	; 0x6368 <vfprintf+0x3aa>
    6004:	85 32       	cpi	r24, 0x25	; 37
    6006:	39 f4       	brne	.+14     	; 0x6016 <vfprintf+0x58>
    6008:	23 fd       	sbrc	r18, 3
    600a:	85 91       	lpm	r24, Z+
    600c:	23 ff       	sbrs	r18, 3
    600e:	81 91       	ld	r24, Z+
    6010:	2f 01       	movw	r4, r30
    6012:	85 32       	cpi	r24, 0x25	; 37
    6014:	29 f4       	brne	.+10     	; 0x6020 <vfprintf+0x62>
    6016:	90 e0       	ldi	r25, 0x00	; 0
    6018:	b3 01       	movw	r22, r6
    601a:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    601e:	e7 cf       	rjmp	.-50     	; 0x5fee <vfprintf+0x30>
    6020:	98 2f       	mov	r25, r24
    6022:	ff 24       	eor	r15, r15
    6024:	ee 24       	eor	r14, r14
    6026:	99 24       	eor	r9, r9
    6028:	ff e1       	ldi	r31, 0x1F	; 31
    602a:	ff 15       	cp	r31, r15
    602c:	d0 f0       	brcs	.+52     	; 0x6062 <vfprintf+0xa4>
    602e:	9b 32       	cpi	r25, 0x2B	; 43
    6030:	69 f0       	breq	.+26     	; 0x604c <vfprintf+0x8e>
    6032:	9c 32       	cpi	r25, 0x2C	; 44
    6034:	28 f4       	brcc	.+10     	; 0x6040 <vfprintf+0x82>
    6036:	90 32       	cpi	r25, 0x20	; 32
    6038:	59 f0       	breq	.+22     	; 0x6050 <vfprintf+0x92>
    603a:	93 32       	cpi	r25, 0x23	; 35
    603c:	91 f4       	brne	.+36     	; 0x6062 <vfprintf+0xa4>
    603e:	0e c0       	rjmp	.+28     	; 0x605c <vfprintf+0x9e>
    6040:	9d 32       	cpi	r25, 0x2D	; 45
    6042:	49 f0       	breq	.+18     	; 0x6056 <vfprintf+0x98>
    6044:	90 33       	cpi	r25, 0x30	; 48
    6046:	69 f4       	brne	.+26     	; 0x6062 <vfprintf+0xa4>
    6048:	41 e0       	ldi	r20, 0x01	; 1
    604a:	24 c0       	rjmp	.+72     	; 0x6094 <vfprintf+0xd6>
    604c:	52 e0       	ldi	r21, 0x02	; 2
    604e:	f5 2a       	or	r15, r21
    6050:	84 e0       	ldi	r24, 0x04	; 4
    6052:	f8 2a       	or	r15, r24
    6054:	28 c0       	rjmp	.+80     	; 0x60a6 <vfprintf+0xe8>
    6056:	98 e0       	ldi	r25, 0x08	; 8
    6058:	f9 2a       	or	r15, r25
    605a:	25 c0       	rjmp	.+74     	; 0x60a6 <vfprintf+0xe8>
    605c:	e0 e1       	ldi	r30, 0x10	; 16
    605e:	fe 2a       	or	r15, r30
    6060:	22 c0       	rjmp	.+68     	; 0x60a6 <vfprintf+0xe8>
    6062:	f7 fc       	sbrc	r15, 7
    6064:	29 c0       	rjmp	.+82     	; 0x60b8 <vfprintf+0xfa>
    6066:	89 2f       	mov	r24, r25
    6068:	80 53       	subi	r24, 0x30	; 48
    606a:	8a 30       	cpi	r24, 0x0A	; 10
    606c:	70 f4       	brcc	.+28     	; 0x608a <vfprintf+0xcc>
    606e:	f6 fe       	sbrs	r15, 6
    6070:	05 c0       	rjmp	.+10     	; 0x607c <vfprintf+0xbe>
    6072:	98 9c       	mul	r9, r8
    6074:	90 2c       	mov	r9, r0
    6076:	11 24       	eor	r1, r1
    6078:	98 0e       	add	r9, r24
    607a:	15 c0       	rjmp	.+42     	; 0x60a6 <vfprintf+0xe8>
    607c:	e8 9c       	mul	r14, r8
    607e:	e0 2c       	mov	r14, r0
    6080:	11 24       	eor	r1, r1
    6082:	e8 0e       	add	r14, r24
    6084:	f0 e2       	ldi	r31, 0x20	; 32
    6086:	ff 2a       	or	r15, r31
    6088:	0e c0       	rjmp	.+28     	; 0x60a6 <vfprintf+0xe8>
    608a:	9e 32       	cpi	r25, 0x2E	; 46
    608c:	29 f4       	brne	.+10     	; 0x6098 <vfprintf+0xda>
    608e:	f6 fc       	sbrc	r15, 6
    6090:	6b c1       	rjmp	.+726    	; 0x6368 <vfprintf+0x3aa>
    6092:	40 e4       	ldi	r20, 0x40	; 64
    6094:	f4 2a       	or	r15, r20
    6096:	07 c0       	rjmp	.+14     	; 0x60a6 <vfprintf+0xe8>
    6098:	9c 36       	cpi	r25, 0x6C	; 108
    609a:	19 f4       	brne	.+6      	; 0x60a2 <vfprintf+0xe4>
    609c:	50 e8       	ldi	r21, 0x80	; 128
    609e:	f5 2a       	or	r15, r21
    60a0:	02 c0       	rjmp	.+4      	; 0x60a6 <vfprintf+0xe8>
    60a2:	98 36       	cpi	r25, 0x68	; 104
    60a4:	49 f4       	brne	.+18     	; 0x60b8 <vfprintf+0xfa>
    60a6:	f2 01       	movw	r30, r4
    60a8:	23 fd       	sbrc	r18, 3
    60aa:	95 91       	lpm	r25, Z+
    60ac:	23 ff       	sbrs	r18, 3
    60ae:	91 91       	ld	r25, Z+
    60b0:	2f 01       	movw	r4, r30
    60b2:	99 23       	and	r25, r25
    60b4:	09 f0       	breq	.+2      	; 0x60b8 <vfprintf+0xfa>
    60b6:	b8 cf       	rjmp	.-144    	; 0x6028 <vfprintf+0x6a>
    60b8:	89 2f       	mov	r24, r25
    60ba:	85 54       	subi	r24, 0x45	; 69
    60bc:	83 30       	cpi	r24, 0x03	; 3
    60be:	18 f0       	brcs	.+6      	; 0x60c6 <vfprintf+0x108>
    60c0:	80 52       	subi	r24, 0x20	; 32
    60c2:	83 30       	cpi	r24, 0x03	; 3
    60c4:	38 f4       	brcc	.+14     	; 0x60d4 <vfprintf+0x116>
    60c6:	44 e0       	ldi	r20, 0x04	; 4
    60c8:	50 e0       	ldi	r21, 0x00	; 0
    60ca:	a4 0e       	add	r10, r20
    60cc:	b5 1e       	adc	r11, r21
    60ce:	5f e3       	ldi	r21, 0x3F	; 63
    60d0:	59 83       	std	Y+1, r21	; 0x01
    60d2:	0f c0       	rjmp	.+30     	; 0x60f2 <vfprintf+0x134>
    60d4:	93 36       	cpi	r25, 0x63	; 99
    60d6:	31 f0       	breq	.+12     	; 0x60e4 <vfprintf+0x126>
    60d8:	93 37       	cpi	r25, 0x73	; 115
    60da:	79 f0       	breq	.+30     	; 0x60fa <vfprintf+0x13c>
    60dc:	93 35       	cpi	r25, 0x53	; 83
    60de:	09 f0       	breq	.+2      	; 0x60e2 <vfprintf+0x124>
    60e0:	56 c0       	rjmp	.+172    	; 0x618e <vfprintf+0x1d0>
    60e2:	20 c0       	rjmp	.+64     	; 0x6124 <vfprintf+0x166>
    60e4:	f5 01       	movw	r30, r10
    60e6:	80 81       	ld	r24, Z
    60e8:	89 83       	std	Y+1, r24	; 0x01
    60ea:	42 e0       	ldi	r20, 0x02	; 2
    60ec:	50 e0       	ldi	r21, 0x00	; 0
    60ee:	a4 0e       	add	r10, r20
    60f0:	b5 1e       	adc	r11, r21
    60f2:	61 01       	movw	r12, r2
    60f4:	01 e0       	ldi	r16, 0x01	; 1
    60f6:	10 e0       	ldi	r17, 0x00	; 0
    60f8:	12 c0       	rjmp	.+36     	; 0x611e <vfprintf+0x160>
    60fa:	f5 01       	movw	r30, r10
    60fc:	c0 80       	ld	r12, Z
    60fe:	d1 80       	ldd	r13, Z+1	; 0x01
    6100:	f6 fc       	sbrc	r15, 6
    6102:	03 c0       	rjmp	.+6      	; 0x610a <vfprintf+0x14c>
    6104:	6f ef       	ldi	r22, 0xFF	; 255
    6106:	7f ef       	ldi	r23, 0xFF	; 255
    6108:	02 c0       	rjmp	.+4      	; 0x610e <vfprintf+0x150>
    610a:	69 2d       	mov	r22, r9
    610c:	70 e0       	ldi	r23, 0x00	; 0
    610e:	42 e0       	ldi	r20, 0x02	; 2
    6110:	50 e0       	ldi	r21, 0x00	; 0
    6112:	a4 0e       	add	r10, r20
    6114:	b5 1e       	adc	r11, r21
    6116:	c6 01       	movw	r24, r12
    6118:	0e 94 c7 31 	call	0x638e	; 0x638e <strnlen>
    611c:	8c 01       	movw	r16, r24
    611e:	5f e7       	ldi	r21, 0x7F	; 127
    6120:	f5 22       	and	r15, r21
    6122:	14 c0       	rjmp	.+40     	; 0x614c <vfprintf+0x18e>
    6124:	f5 01       	movw	r30, r10
    6126:	c0 80       	ld	r12, Z
    6128:	d1 80       	ldd	r13, Z+1	; 0x01
    612a:	f6 fc       	sbrc	r15, 6
    612c:	03 c0       	rjmp	.+6      	; 0x6134 <vfprintf+0x176>
    612e:	6f ef       	ldi	r22, 0xFF	; 255
    6130:	7f ef       	ldi	r23, 0xFF	; 255
    6132:	02 c0       	rjmp	.+4      	; 0x6138 <vfprintf+0x17a>
    6134:	69 2d       	mov	r22, r9
    6136:	70 e0       	ldi	r23, 0x00	; 0
    6138:	42 e0       	ldi	r20, 0x02	; 2
    613a:	50 e0       	ldi	r21, 0x00	; 0
    613c:	a4 0e       	add	r10, r20
    613e:	b5 1e       	adc	r11, r21
    6140:	c6 01       	movw	r24, r12
    6142:	0e 94 bc 31 	call	0x6378	; 0x6378 <strnlen_P>
    6146:	8c 01       	movw	r16, r24
    6148:	50 e8       	ldi	r21, 0x80	; 128
    614a:	f5 2a       	or	r15, r21
    614c:	f3 fe       	sbrs	r15, 3
    614e:	07 c0       	rjmp	.+14     	; 0x615e <vfprintf+0x1a0>
    6150:	1a c0       	rjmp	.+52     	; 0x6186 <vfprintf+0x1c8>
    6152:	80 e2       	ldi	r24, 0x20	; 32
    6154:	90 e0       	ldi	r25, 0x00	; 0
    6156:	b3 01       	movw	r22, r6
    6158:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    615c:	ea 94       	dec	r14
    615e:	8e 2d       	mov	r24, r14
    6160:	90 e0       	ldi	r25, 0x00	; 0
    6162:	08 17       	cp	r16, r24
    6164:	19 07       	cpc	r17, r25
    6166:	a8 f3       	brcs	.-22     	; 0x6152 <vfprintf+0x194>
    6168:	0e c0       	rjmp	.+28     	; 0x6186 <vfprintf+0x1c8>
    616a:	f6 01       	movw	r30, r12
    616c:	f7 fc       	sbrc	r15, 7
    616e:	85 91       	lpm	r24, Z+
    6170:	f7 fe       	sbrs	r15, 7
    6172:	81 91       	ld	r24, Z+
    6174:	6f 01       	movw	r12, r30
    6176:	90 e0       	ldi	r25, 0x00	; 0
    6178:	b3 01       	movw	r22, r6
    617a:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    617e:	e1 10       	cpse	r14, r1
    6180:	ea 94       	dec	r14
    6182:	01 50       	subi	r16, 0x01	; 1
    6184:	10 40       	sbci	r17, 0x00	; 0
    6186:	01 15       	cp	r16, r1
    6188:	11 05       	cpc	r17, r1
    618a:	79 f7       	brne	.-34     	; 0x616a <vfprintf+0x1ac>
    618c:	ea c0       	rjmp	.+468    	; 0x6362 <vfprintf+0x3a4>
    618e:	94 36       	cpi	r25, 0x64	; 100
    6190:	11 f0       	breq	.+4      	; 0x6196 <vfprintf+0x1d8>
    6192:	99 36       	cpi	r25, 0x69	; 105
    6194:	69 f5       	brne	.+90     	; 0x61f0 <vfprintf+0x232>
    6196:	f7 fe       	sbrs	r15, 7
    6198:	08 c0       	rjmp	.+16     	; 0x61aa <vfprintf+0x1ec>
    619a:	f5 01       	movw	r30, r10
    619c:	20 81       	ld	r18, Z
    619e:	31 81       	ldd	r19, Z+1	; 0x01
    61a0:	42 81       	ldd	r20, Z+2	; 0x02
    61a2:	53 81       	ldd	r21, Z+3	; 0x03
    61a4:	84 e0       	ldi	r24, 0x04	; 4
    61a6:	90 e0       	ldi	r25, 0x00	; 0
    61a8:	0a c0       	rjmp	.+20     	; 0x61be <vfprintf+0x200>
    61aa:	f5 01       	movw	r30, r10
    61ac:	80 81       	ld	r24, Z
    61ae:	91 81       	ldd	r25, Z+1	; 0x01
    61b0:	9c 01       	movw	r18, r24
    61b2:	44 27       	eor	r20, r20
    61b4:	37 fd       	sbrc	r19, 7
    61b6:	40 95       	com	r20
    61b8:	54 2f       	mov	r21, r20
    61ba:	82 e0       	ldi	r24, 0x02	; 2
    61bc:	90 e0       	ldi	r25, 0x00	; 0
    61be:	a8 0e       	add	r10, r24
    61c0:	b9 1e       	adc	r11, r25
    61c2:	9f e6       	ldi	r25, 0x6F	; 111
    61c4:	f9 22       	and	r15, r25
    61c6:	57 ff       	sbrs	r21, 7
    61c8:	09 c0       	rjmp	.+18     	; 0x61dc <vfprintf+0x21e>
    61ca:	50 95       	com	r21
    61cc:	40 95       	com	r20
    61ce:	30 95       	com	r19
    61d0:	21 95       	neg	r18
    61d2:	3f 4f       	sbci	r19, 0xFF	; 255
    61d4:	4f 4f       	sbci	r20, 0xFF	; 255
    61d6:	5f 4f       	sbci	r21, 0xFF	; 255
    61d8:	e0 e8       	ldi	r30, 0x80	; 128
    61da:	fe 2a       	or	r15, r30
    61dc:	ca 01       	movw	r24, r20
    61de:	b9 01       	movw	r22, r18
    61e0:	a1 01       	movw	r20, r2
    61e2:	2a e0       	ldi	r18, 0x0A	; 10
    61e4:	30 e0       	ldi	r19, 0x00	; 0
    61e6:	0e 94 0e 32 	call	0x641c	; 0x641c <__ultoa_invert>
    61ea:	d8 2e       	mov	r13, r24
    61ec:	d2 18       	sub	r13, r2
    61ee:	40 c0       	rjmp	.+128    	; 0x6270 <vfprintf+0x2b2>
    61f0:	95 37       	cpi	r25, 0x75	; 117
    61f2:	29 f4       	brne	.+10     	; 0x61fe <vfprintf+0x240>
    61f4:	1f 2d       	mov	r17, r15
    61f6:	1f 7e       	andi	r17, 0xEF	; 239
    61f8:	2a e0       	ldi	r18, 0x0A	; 10
    61fa:	30 e0       	ldi	r19, 0x00	; 0
    61fc:	1d c0       	rjmp	.+58     	; 0x6238 <vfprintf+0x27a>
    61fe:	1f 2d       	mov	r17, r15
    6200:	19 7f       	andi	r17, 0xF9	; 249
    6202:	9f 36       	cpi	r25, 0x6F	; 111
    6204:	61 f0       	breq	.+24     	; 0x621e <vfprintf+0x260>
    6206:	90 37       	cpi	r25, 0x70	; 112
    6208:	20 f4       	brcc	.+8      	; 0x6212 <vfprintf+0x254>
    620a:	98 35       	cpi	r25, 0x58	; 88
    620c:	09 f0       	breq	.+2      	; 0x6210 <vfprintf+0x252>
    620e:	ac c0       	rjmp	.+344    	; 0x6368 <vfprintf+0x3aa>
    6210:	0f c0       	rjmp	.+30     	; 0x6230 <vfprintf+0x272>
    6212:	90 37       	cpi	r25, 0x70	; 112
    6214:	39 f0       	breq	.+14     	; 0x6224 <vfprintf+0x266>
    6216:	98 37       	cpi	r25, 0x78	; 120
    6218:	09 f0       	breq	.+2      	; 0x621c <vfprintf+0x25e>
    621a:	a6 c0       	rjmp	.+332    	; 0x6368 <vfprintf+0x3aa>
    621c:	04 c0       	rjmp	.+8      	; 0x6226 <vfprintf+0x268>
    621e:	28 e0       	ldi	r18, 0x08	; 8
    6220:	30 e0       	ldi	r19, 0x00	; 0
    6222:	0a c0       	rjmp	.+20     	; 0x6238 <vfprintf+0x27a>
    6224:	10 61       	ori	r17, 0x10	; 16
    6226:	14 fd       	sbrc	r17, 4
    6228:	14 60       	ori	r17, 0x04	; 4
    622a:	20 e1       	ldi	r18, 0x10	; 16
    622c:	30 e0       	ldi	r19, 0x00	; 0
    622e:	04 c0       	rjmp	.+8      	; 0x6238 <vfprintf+0x27a>
    6230:	14 fd       	sbrc	r17, 4
    6232:	16 60       	ori	r17, 0x06	; 6
    6234:	20 e1       	ldi	r18, 0x10	; 16
    6236:	32 e0       	ldi	r19, 0x02	; 2
    6238:	17 ff       	sbrs	r17, 7
    623a:	08 c0       	rjmp	.+16     	; 0x624c <vfprintf+0x28e>
    623c:	f5 01       	movw	r30, r10
    623e:	60 81       	ld	r22, Z
    6240:	71 81       	ldd	r23, Z+1	; 0x01
    6242:	82 81       	ldd	r24, Z+2	; 0x02
    6244:	93 81       	ldd	r25, Z+3	; 0x03
    6246:	44 e0       	ldi	r20, 0x04	; 4
    6248:	50 e0       	ldi	r21, 0x00	; 0
    624a:	08 c0       	rjmp	.+16     	; 0x625c <vfprintf+0x29e>
    624c:	f5 01       	movw	r30, r10
    624e:	80 81       	ld	r24, Z
    6250:	91 81       	ldd	r25, Z+1	; 0x01
    6252:	bc 01       	movw	r22, r24
    6254:	80 e0       	ldi	r24, 0x00	; 0
    6256:	90 e0       	ldi	r25, 0x00	; 0
    6258:	42 e0       	ldi	r20, 0x02	; 2
    625a:	50 e0       	ldi	r21, 0x00	; 0
    625c:	a4 0e       	add	r10, r20
    625e:	b5 1e       	adc	r11, r21
    6260:	a1 01       	movw	r20, r2
    6262:	0e 94 0e 32 	call	0x641c	; 0x641c <__ultoa_invert>
    6266:	d8 2e       	mov	r13, r24
    6268:	d2 18       	sub	r13, r2
    626a:	8f e7       	ldi	r24, 0x7F	; 127
    626c:	f8 2e       	mov	r15, r24
    626e:	f1 22       	and	r15, r17
    6270:	f6 fe       	sbrs	r15, 6
    6272:	0b c0       	rjmp	.+22     	; 0x628a <vfprintf+0x2cc>
    6274:	5e ef       	ldi	r21, 0xFE	; 254
    6276:	f5 22       	and	r15, r21
    6278:	d9 14       	cp	r13, r9
    627a:	38 f4       	brcc	.+14     	; 0x628a <vfprintf+0x2cc>
    627c:	f4 fe       	sbrs	r15, 4
    627e:	07 c0       	rjmp	.+14     	; 0x628e <vfprintf+0x2d0>
    6280:	f2 fc       	sbrc	r15, 2
    6282:	05 c0       	rjmp	.+10     	; 0x628e <vfprintf+0x2d0>
    6284:	8f ee       	ldi	r24, 0xEF	; 239
    6286:	f8 22       	and	r15, r24
    6288:	02 c0       	rjmp	.+4      	; 0x628e <vfprintf+0x2d0>
    628a:	1d 2d       	mov	r17, r13
    628c:	01 c0       	rjmp	.+2      	; 0x6290 <vfprintf+0x2d2>
    628e:	19 2d       	mov	r17, r9
    6290:	f4 fe       	sbrs	r15, 4
    6292:	0d c0       	rjmp	.+26     	; 0x62ae <vfprintf+0x2f0>
    6294:	fe 01       	movw	r30, r28
    6296:	ed 0d       	add	r30, r13
    6298:	f1 1d       	adc	r31, r1
    629a:	80 81       	ld	r24, Z
    629c:	80 33       	cpi	r24, 0x30	; 48
    629e:	19 f4       	brne	.+6      	; 0x62a6 <vfprintf+0x2e8>
    62a0:	99 ee       	ldi	r25, 0xE9	; 233
    62a2:	f9 22       	and	r15, r25
    62a4:	08 c0       	rjmp	.+16     	; 0x62b6 <vfprintf+0x2f8>
    62a6:	1f 5f       	subi	r17, 0xFF	; 255
    62a8:	f2 fe       	sbrs	r15, 2
    62aa:	05 c0       	rjmp	.+10     	; 0x62b6 <vfprintf+0x2f8>
    62ac:	03 c0       	rjmp	.+6      	; 0x62b4 <vfprintf+0x2f6>
    62ae:	8f 2d       	mov	r24, r15
    62b0:	86 78       	andi	r24, 0x86	; 134
    62b2:	09 f0       	breq	.+2      	; 0x62b6 <vfprintf+0x2f8>
    62b4:	1f 5f       	subi	r17, 0xFF	; 255
    62b6:	0f 2d       	mov	r16, r15
    62b8:	f3 fc       	sbrc	r15, 3
    62ba:	14 c0       	rjmp	.+40     	; 0x62e4 <vfprintf+0x326>
    62bc:	f0 fe       	sbrs	r15, 0
    62be:	0f c0       	rjmp	.+30     	; 0x62de <vfprintf+0x320>
    62c0:	1e 15       	cp	r17, r14
    62c2:	10 f0       	brcs	.+4      	; 0x62c8 <vfprintf+0x30a>
    62c4:	9d 2c       	mov	r9, r13
    62c6:	0b c0       	rjmp	.+22     	; 0x62de <vfprintf+0x320>
    62c8:	9d 2c       	mov	r9, r13
    62ca:	9e 0c       	add	r9, r14
    62cc:	91 1a       	sub	r9, r17
    62ce:	1e 2d       	mov	r17, r14
    62d0:	06 c0       	rjmp	.+12     	; 0x62de <vfprintf+0x320>
    62d2:	80 e2       	ldi	r24, 0x20	; 32
    62d4:	90 e0       	ldi	r25, 0x00	; 0
    62d6:	b3 01       	movw	r22, r6
    62d8:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    62dc:	1f 5f       	subi	r17, 0xFF	; 255
    62de:	1e 15       	cp	r17, r14
    62e0:	c0 f3       	brcs	.-16     	; 0x62d2 <vfprintf+0x314>
    62e2:	04 c0       	rjmp	.+8      	; 0x62ec <vfprintf+0x32e>
    62e4:	1e 15       	cp	r17, r14
    62e6:	10 f4       	brcc	.+4      	; 0x62ec <vfprintf+0x32e>
    62e8:	e1 1a       	sub	r14, r17
    62ea:	01 c0       	rjmp	.+2      	; 0x62ee <vfprintf+0x330>
    62ec:	ee 24       	eor	r14, r14
    62ee:	04 ff       	sbrs	r16, 4
    62f0:	0f c0       	rjmp	.+30     	; 0x6310 <vfprintf+0x352>
    62f2:	80 e3       	ldi	r24, 0x30	; 48
    62f4:	90 e0       	ldi	r25, 0x00	; 0
    62f6:	b3 01       	movw	r22, r6
    62f8:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    62fc:	02 ff       	sbrs	r16, 2
    62fe:	1d c0       	rjmp	.+58     	; 0x633a <vfprintf+0x37c>
    6300:	01 fd       	sbrc	r16, 1
    6302:	03 c0       	rjmp	.+6      	; 0x630a <vfprintf+0x34c>
    6304:	88 e7       	ldi	r24, 0x78	; 120
    6306:	90 e0       	ldi	r25, 0x00	; 0
    6308:	0e c0       	rjmp	.+28     	; 0x6326 <vfprintf+0x368>
    630a:	88 e5       	ldi	r24, 0x58	; 88
    630c:	90 e0       	ldi	r25, 0x00	; 0
    630e:	0b c0       	rjmp	.+22     	; 0x6326 <vfprintf+0x368>
    6310:	80 2f       	mov	r24, r16
    6312:	86 78       	andi	r24, 0x86	; 134
    6314:	91 f0       	breq	.+36     	; 0x633a <vfprintf+0x37c>
    6316:	01 ff       	sbrs	r16, 1
    6318:	02 c0       	rjmp	.+4      	; 0x631e <vfprintf+0x360>
    631a:	8b e2       	ldi	r24, 0x2B	; 43
    631c:	01 c0       	rjmp	.+2      	; 0x6320 <vfprintf+0x362>
    631e:	80 e2       	ldi	r24, 0x20	; 32
    6320:	f7 fc       	sbrc	r15, 7
    6322:	8d e2       	ldi	r24, 0x2D	; 45
    6324:	90 e0       	ldi	r25, 0x00	; 0
    6326:	b3 01       	movw	r22, r6
    6328:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    632c:	06 c0       	rjmp	.+12     	; 0x633a <vfprintf+0x37c>
    632e:	80 e3       	ldi	r24, 0x30	; 48
    6330:	90 e0       	ldi	r25, 0x00	; 0
    6332:	b3 01       	movw	r22, r6
    6334:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    6338:	9a 94       	dec	r9
    633a:	d9 14       	cp	r13, r9
    633c:	c0 f3       	brcs	.-16     	; 0x632e <vfprintf+0x370>
    633e:	da 94       	dec	r13
    6340:	f1 01       	movw	r30, r2
    6342:	ed 0d       	add	r30, r13
    6344:	f1 1d       	adc	r31, r1
    6346:	80 81       	ld	r24, Z
    6348:	90 e0       	ldi	r25, 0x00	; 0
    634a:	b3 01       	movw	r22, r6
    634c:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    6350:	dd 20       	and	r13, r13
    6352:	a9 f7       	brne	.-22     	; 0x633e <vfprintf+0x380>
    6354:	06 c0       	rjmp	.+12     	; 0x6362 <vfprintf+0x3a4>
    6356:	80 e2       	ldi	r24, 0x20	; 32
    6358:	90 e0       	ldi	r25, 0x00	; 0
    635a:	b3 01       	movw	r22, r6
    635c:	0e 94 e2 31 	call	0x63c4	; 0x63c4 <fputc>
    6360:	ea 94       	dec	r14
    6362:	ee 20       	and	r14, r14
    6364:	c1 f7       	brne	.-16     	; 0x6356 <vfprintf+0x398>
    6366:	43 ce       	rjmp	.-890    	; 0x5fee <vfprintf+0x30>
    6368:	f3 01       	movw	r30, r6
    636a:	66 81       	ldd	r22, Z+6	; 0x06
    636c:	77 81       	ldd	r23, Z+7	; 0x07
    636e:	cb 01       	movw	r24, r22
    6370:	2b 96       	adiw	r28, 0x0b	; 11
    6372:	e2 e1       	ldi	r30, 0x12	; 18
    6374:	0c 94 9c 32 	jmp	0x6538	; 0x6538 <__epilogue_restores__>

00006378 <strnlen_P>:
    6378:	fc 01       	movw	r30, r24
    637a:	05 90       	lpm	r0, Z+
    637c:	61 50       	subi	r22, 0x01	; 1
    637e:	70 40       	sbci	r23, 0x00	; 0
    6380:	01 10       	cpse	r0, r1
    6382:	d8 f7       	brcc	.-10     	; 0x637a <strnlen_P+0x2>
    6384:	80 95       	com	r24
    6386:	90 95       	com	r25
    6388:	8e 0f       	add	r24, r30
    638a:	9f 1f       	adc	r25, r31
    638c:	08 95       	ret

0000638e <strnlen>:
    638e:	fc 01       	movw	r30, r24
    6390:	61 50       	subi	r22, 0x01	; 1
    6392:	70 40       	sbci	r23, 0x00	; 0
    6394:	01 90       	ld	r0, Z+
    6396:	01 10       	cpse	r0, r1
    6398:	d8 f7       	brcc	.-10     	; 0x6390 <strnlen+0x2>
    639a:	80 95       	com	r24
    639c:	90 95       	com	r25
    639e:	8e 0f       	add	r24, r30
    63a0:	9f 1f       	adc	r25, r31
    63a2:	08 95       	ret

000063a4 <strrev>:
    63a4:	dc 01       	movw	r26, r24
    63a6:	fc 01       	movw	r30, r24
    63a8:	67 2f       	mov	r22, r23
    63aa:	71 91       	ld	r23, Z+
    63ac:	77 23       	and	r23, r23
    63ae:	e1 f7       	brne	.-8      	; 0x63a8 <strrev+0x4>
    63b0:	32 97       	sbiw	r30, 0x02	; 2
    63b2:	04 c0       	rjmp	.+8      	; 0x63bc <strrev+0x18>
    63b4:	7c 91       	ld	r23, X
    63b6:	6d 93       	st	X+, r22
    63b8:	70 83       	st	Z, r23
    63ba:	62 91       	ld	r22, -Z
    63bc:	ae 17       	cp	r26, r30
    63be:	bf 07       	cpc	r27, r31
    63c0:	c8 f3       	brcs	.-14     	; 0x63b4 <strrev+0x10>
    63c2:	08 95       	ret

000063c4 <fputc>:
    63c4:	0f 93       	push	r16
    63c6:	1f 93       	push	r17
    63c8:	cf 93       	push	r28
    63ca:	df 93       	push	r29
    63cc:	8c 01       	movw	r16, r24
    63ce:	eb 01       	movw	r28, r22
    63d0:	8b 81       	ldd	r24, Y+3	; 0x03
    63d2:	81 ff       	sbrs	r24, 1
    63d4:	1b c0       	rjmp	.+54     	; 0x640c <fputc+0x48>
    63d6:	82 ff       	sbrs	r24, 2
    63d8:	0d c0       	rjmp	.+26     	; 0x63f4 <fputc+0x30>
    63da:	2e 81       	ldd	r18, Y+6	; 0x06
    63dc:	3f 81       	ldd	r19, Y+7	; 0x07
    63de:	8c 81       	ldd	r24, Y+4	; 0x04
    63e0:	9d 81       	ldd	r25, Y+5	; 0x05
    63e2:	28 17       	cp	r18, r24
    63e4:	39 07       	cpc	r19, r25
    63e6:	64 f4       	brge	.+24     	; 0x6400 <fputc+0x3c>
    63e8:	e8 81       	ld	r30, Y
    63ea:	f9 81       	ldd	r31, Y+1	; 0x01
    63ec:	01 93       	st	Z+, r16
    63ee:	f9 83       	std	Y+1, r31	; 0x01
    63f0:	e8 83       	st	Y, r30
    63f2:	06 c0       	rjmp	.+12     	; 0x6400 <fputc+0x3c>
    63f4:	e8 85       	ldd	r30, Y+8	; 0x08
    63f6:	f9 85       	ldd	r31, Y+9	; 0x09
    63f8:	80 2f       	mov	r24, r16
    63fa:	09 95       	icall
    63fc:	89 2b       	or	r24, r25
    63fe:	31 f4       	brne	.+12     	; 0x640c <fputc+0x48>
    6400:	8e 81       	ldd	r24, Y+6	; 0x06
    6402:	9f 81       	ldd	r25, Y+7	; 0x07
    6404:	01 96       	adiw	r24, 0x01	; 1
    6406:	9f 83       	std	Y+7, r25	; 0x07
    6408:	8e 83       	std	Y+6, r24	; 0x06
    640a:	02 c0       	rjmp	.+4      	; 0x6410 <fputc+0x4c>
    640c:	0f ef       	ldi	r16, 0xFF	; 255
    640e:	1f ef       	ldi	r17, 0xFF	; 255
    6410:	c8 01       	movw	r24, r16
    6412:	df 91       	pop	r29
    6414:	cf 91       	pop	r28
    6416:	1f 91       	pop	r17
    6418:	0f 91       	pop	r16
    641a:	08 95       	ret

0000641c <__ultoa_invert>:
    641c:	fa 01       	movw	r30, r20
    641e:	aa 27       	eor	r26, r26
    6420:	28 30       	cpi	r18, 0x08	; 8
    6422:	51 f1       	breq	.+84     	; 0x6478 <__ultoa_invert+0x5c>
    6424:	20 31       	cpi	r18, 0x10	; 16
    6426:	81 f1       	breq	.+96     	; 0x6488 <__ultoa_invert+0x6c>
    6428:	e8 94       	clt
    642a:	6f 93       	push	r22
    642c:	6e 7f       	andi	r22, 0xFE	; 254
    642e:	6e 5f       	subi	r22, 0xFE	; 254
    6430:	7f 4f       	sbci	r23, 0xFF	; 255
    6432:	8f 4f       	sbci	r24, 0xFF	; 255
    6434:	9f 4f       	sbci	r25, 0xFF	; 255
    6436:	af 4f       	sbci	r26, 0xFF	; 255
    6438:	b1 e0       	ldi	r27, 0x01	; 1
    643a:	3e d0       	rcall	.+124    	; 0x64b8 <__ultoa_invert+0x9c>
    643c:	b4 e0       	ldi	r27, 0x04	; 4
    643e:	3c d0       	rcall	.+120    	; 0x64b8 <__ultoa_invert+0x9c>
    6440:	67 0f       	add	r22, r23
    6442:	78 1f       	adc	r23, r24
    6444:	89 1f       	adc	r24, r25
    6446:	9a 1f       	adc	r25, r26
    6448:	a1 1d       	adc	r26, r1
    644a:	68 0f       	add	r22, r24
    644c:	79 1f       	adc	r23, r25
    644e:	8a 1f       	adc	r24, r26
    6450:	91 1d       	adc	r25, r1
    6452:	a1 1d       	adc	r26, r1
    6454:	6a 0f       	add	r22, r26
    6456:	71 1d       	adc	r23, r1
    6458:	81 1d       	adc	r24, r1
    645a:	91 1d       	adc	r25, r1
    645c:	a1 1d       	adc	r26, r1
    645e:	20 d0       	rcall	.+64     	; 0x64a0 <__ultoa_invert+0x84>
    6460:	09 f4       	brne	.+2      	; 0x6464 <__ultoa_invert+0x48>
    6462:	68 94       	set
    6464:	3f 91       	pop	r19
    6466:	2a e0       	ldi	r18, 0x0A	; 10
    6468:	26 9f       	mul	r18, r22
    646a:	11 24       	eor	r1, r1
    646c:	30 19       	sub	r19, r0
    646e:	30 5d       	subi	r19, 0xD0	; 208
    6470:	31 93       	st	Z+, r19
    6472:	de f6       	brtc	.-74     	; 0x642a <__ultoa_invert+0xe>
    6474:	cf 01       	movw	r24, r30
    6476:	08 95       	ret
    6478:	46 2f       	mov	r20, r22
    647a:	47 70       	andi	r20, 0x07	; 7
    647c:	40 5d       	subi	r20, 0xD0	; 208
    647e:	41 93       	st	Z+, r20
    6480:	b3 e0       	ldi	r27, 0x03	; 3
    6482:	0f d0       	rcall	.+30     	; 0x64a2 <__ultoa_invert+0x86>
    6484:	c9 f7       	brne	.-14     	; 0x6478 <__ultoa_invert+0x5c>
    6486:	f6 cf       	rjmp	.-20     	; 0x6474 <__ultoa_invert+0x58>
    6488:	46 2f       	mov	r20, r22
    648a:	4f 70       	andi	r20, 0x0F	; 15
    648c:	40 5d       	subi	r20, 0xD0	; 208
    648e:	4a 33       	cpi	r20, 0x3A	; 58
    6490:	18 f0       	brcs	.+6      	; 0x6498 <__ultoa_invert+0x7c>
    6492:	49 5d       	subi	r20, 0xD9	; 217
    6494:	31 fd       	sbrc	r19, 1
    6496:	40 52       	subi	r20, 0x20	; 32
    6498:	41 93       	st	Z+, r20
    649a:	02 d0       	rcall	.+4      	; 0x64a0 <__ultoa_invert+0x84>
    649c:	a9 f7       	brne	.-22     	; 0x6488 <__ultoa_invert+0x6c>
    649e:	ea cf       	rjmp	.-44     	; 0x6474 <__ultoa_invert+0x58>
    64a0:	b4 e0       	ldi	r27, 0x04	; 4
    64a2:	a6 95       	lsr	r26
    64a4:	97 95       	ror	r25
    64a6:	87 95       	ror	r24
    64a8:	77 95       	ror	r23
    64aa:	67 95       	ror	r22
    64ac:	ba 95       	dec	r27
    64ae:	c9 f7       	brne	.-14     	; 0x64a2 <__ultoa_invert+0x86>
    64b0:	00 97       	sbiw	r24, 0x00	; 0
    64b2:	61 05       	cpc	r22, r1
    64b4:	71 05       	cpc	r23, r1
    64b6:	08 95       	ret
    64b8:	9b 01       	movw	r18, r22
    64ba:	ac 01       	movw	r20, r24
    64bc:	0a 2e       	mov	r0, r26
    64be:	06 94       	lsr	r0
    64c0:	57 95       	ror	r21
    64c2:	47 95       	ror	r20
    64c4:	37 95       	ror	r19
    64c6:	27 95       	ror	r18
    64c8:	ba 95       	dec	r27
    64ca:	c9 f7       	brne	.-14     	; 0x64be <__ultoa_invert+0xa2>
    64cc:	62 0f       	add	r22, r18
    64ce:	73 1f       	adc	r23, r19
    64d0:	84 1f       	adc	r24, r20
    64d2:	95 1f       	adc	r25, r21
    64d4:	a0 1d       	adc	r26, r0
    64d6:	08 95       	ret

000064d8 <__udivmodhi4>:
    64d8:	aa 1b       	sub	r26, r26
    64da:	bb 1b       	sub	r27, r27
    64dc:	51 e1       	ldi	r21, 0x11	; 17
    64de:	07 c0       	rjmp	.+14     	; 0x64ee <__udivmodhi4_ep>

000064e0 <__udivmodhi4_loop>:
    64e0:	aa 1f       	adc	r26, r26
    64e2:	bb 1f       	adc	r27, r27
    64e4:	a6 17       	cp	r26, r22
    64e6:	b7 07       	cpc	r27, r23
    64e8:	10 f0       	brcs	.+4      	; 0x64ee <__udivmodhi4_ep>
    64ea:	a6 1b       	sub	r26, r22
    64ec:	b7 0b       	sbc	r27, r23

000064ee <__udivmodhi4_ep>:
    64ee:	88 1f       	adc	r24, r24
    64f0:	99 1f       	adc	r25, r25
    64f2:	5a 95       	dec	r21
    64f4:	a9 f7       	brne	.-22     	; 0x64e0 <__udivmodhi4_loop>
    64f6:	80 95       	com	r24
    64f8:	90 95       	com	r25
    64fa:	bc 01       	movw	r22, r24
    64fc:	cd 01       	movw	r24, r26
    64fe:	08 95       	ret

00006500 <__prologue_saves__>:
    6500:	2f 92       	push	r2
    6502:	3f 92       	push	r3
    6504:	4f 92       	push	r4
    6506:	5f 92       	push	r5
    6508:	6f 92       	push	r6
    650a:	7f 92       	push	r7
    650c:	8f 92       	push	r8
    650e:	9f 92       	push	r9
    6510:	af 92       	push	r10
    6512:	bf 92       	push	r11
    6514:	cf 92       	push	r12
    6516:	df 92       	push	r13
    6518:	ef 92       	push	r14
    651a:	ff 92       	push	r15
    651c:	0f 93       	push	r16
    651e:	1f 93       	push	r17
    6520:	cf 93       	push	r28
    6522:	df 93       	push	r29
    6524:	cd b7       	in	r28, 0x3d	; 61
    6526:	de b7       	in	r29, 0x3e	; 62
    6528:	ca 1b       	sub	r28, r26
    652a:	db 0b       	sbc	r29, r27
    652c:	0f b6       	in	r0, 0x3f	; 63
    652e:	f8 94       	cli
    6530:	de bf       	out	0x3e, r29	; 62
    6532:	0f be       	out	0x3f, r0	; 63
    6534:	cd bf       	out	0x3d, r28	; 61
    6536:	09 94       	ijmp

00006538 <__epilogue_restores__>:
    6538:	2a 88       	ldd	r2, Y+18	; 0x12
    653a:	39 88       	ldd	r3, Y+17	; 0x11
    653c:	48 88       	ldd	r4, Y+16	; 0x10
    653e:	5f 84       	ldd	r5, Y+15	; 0x0f
    6540:	6e 84       	ldd	r6, Y+14	; 0x0e
    6542:	7d 84       	ldd	r7, Y+13	; 0x0d
    6544:	8c 84       	ldd	r8, Y+12	; 0x0c
    6546:	9b 84       	ldd	r9, Y+11	; 0x0b
    6548:	aa 84       	ldd	r10, Y+10	; 0x0a
    654a:	b9 84       	ldd	r11, Y+9	; 0x09
    654c:	c8 84       	ldd	r12, Y+8	; 0x08
    654e:	df 80       	ldd	r13, Y+7	; 0x07
    6550:	ee 80       	ldd	r14, Y+6	; 0x06
    6552:	fd 80       	ldd	r15, Y+5	; 0x05
    6554:	0c 81       	ldd	r16, Y+4	; 0x04
    6556:	1b 81       	ldd	r17, Y+3	; 0x03
    6558:	aa 81       	ldd	r26, Y+2	; 0x02
    655a:	b9 81       	ldd	r27, Y+1	; 0x01
    655c:	ce 0f       	add	r28, r30
    655e:	d1 1d       	adc	r29, r1
    6560:	0f b6       	in	r0, 0x3f	; 63
    6562:	f8 94       	cli
    6564:	de bf       	out	0x3e, r29	; 62
    6566:	0f be       	out	0x3f, r0	; 63
    6568:	cd bf       	out	0x3d, r28	; 61
    656a:	ed 01       	movw	r28, r26
    656c:	08 95       	ret

0000656e <_exit>:
    656e:	f8 94       	cli

00006570 <__stop_program>:
    6570:	ff cf       	rjmp	.-2      	; 0x6570 <__stop_program>
