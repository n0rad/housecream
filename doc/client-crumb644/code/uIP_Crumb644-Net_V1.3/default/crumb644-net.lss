
crumb644-net.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002a2  00800100  00006c3c  00006cb0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006c3c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000842  008003a2  00006ede  00006f52  2**0
                  ALLOC
  3 .debug_aranges 00000160  00000000  00000000  00006f52  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000ae1  00000000  00000000  000070b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006bc9  00000000  00000000  00007b93  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016d5  00000000  00000000  0000e75c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00004f93  00000000  00000000  0000fe31  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000650  00000000  00000000  00014dc4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000109e  00000000  00000000  00015414  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000258d  00000000  00000000  000164b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000328  00000000  00000000  00018a3f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 d0 0f 	jmp	0x1fa0	; 0x1fa0 <__ctors_end>
       4:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
       8:	0c 94 1c 10 	jmp	0x2038	; 0x2038 <__vector_2>
       c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      10:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      14:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      18:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      1c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      20:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      24:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      28:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      2c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      30:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      34:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      38:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      3c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      40:	0c 94 ef 0f 	jmp	0x1fde	; 0x1fde <__vector_16>
      44:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      48:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      4c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      50:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      54:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      58:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      5c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      60:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      64:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      68:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>
      6c:	0c 94 ed 0f 	jmp	0x1fda	; 0x1fda <__bad_interrupt>

00000070 <__c.2190>:
      70:	1b 5b 50 00                                         .[P.

00000074 <__c.2188>:
      74:	23 00                                               #.

00000076 <__c.2183>:
      76:	0d 0a 72 65 61 64 79 2e 20 0d 0a 00                 ..ready. ...

00000082 <__c.2181>:
      82:	69 6e 69 74 20 43 50 32 32 30 30 20 2e 2e 2e 00     init CP2200 ....

00000092 <__c.2153>:
      92:	48 45 4c 50 00                                      HELP.

00000097 <__c.2151>:
      97:	64 6f 6e 65 20 0a 0d 00                             done ...

0000009f <__c.2149>:
      9f:	43 50 32 32 30 30 20 72 65 73 65 74 20 2e 2e 2e     CP2200 reset ...
	...

000000b0 <__c.2147>:
      b0:	43 50 52 45 53 45 54 00                             CPRESET.

000000b8 <__c.2145>:
      b8:	4e 45 54 4d 41 53 4b 00                             NETMASK.

000000c0 <__c.2143>:
      c0:	49 50 00                                            IP.

000000c3 <__c.2124>:
      c3:	20 20 0d 0a 00                                        ...

000000c8 <__c.2122>:
      c8:	20 20 4e 45 54 4d 41 53 4b 20 3c 78 78 78 2e 78       NETMASK <xxx.x
      d8:	78 78 2e 78 78 78 2e 78 78 78 3e 20 20 20 2f 2f     xx.xxx.xxx>   //
      e8:	20 64 69 73 70 6c 61 79 20 2f 20 73 65 74 20 6e      display / set n
      f8:	65 74 6d 61 73 6b 0d 0a 00                          etmask...

00000101 <__c.2120>:
     101:	20 20 49 50 20 3c 78 78 78 2e 78 78 78 2e 78 78       IP <xxx.xxx.xx
     111:	78 2e 78 78 78 3e 20 20 20 20 20 20 20 20 2f 2f     x.xxx>        //
     121:	20 64 69 73 70 6c 61 79 20 2f 20 73 65 74 20 49      display / set I
     131:	50 20 61 64 64 72 65 73 73 0d 0a 00                 P address...

0000013d <__c.2118>:
     13d:	20 20 43 50 52 45 53 45 54 20 20 20 20 20 20 20       CPRESET       
     14d:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 2f 2f                   //
     15d:	20 72 65 69 6e 69 74 69 61 6c 69 7a 65 20 65 74      reinitialize et
     16d:	68 65 72 6e 65 74 20 63 6f 6e 74 72 6f 6c 6c 65     hernet controlle
     17d:	72 20 0d 0a 00                                      r ...

00000182 <__c.2116>:
     182:	20 43 6f 6d 6d 61 6e 64 73 3a 20 0d 0a 00            Commands: ...

00000190 <__c.2114>:
     190:	20 73 65 72 69 61 6c 3a 20 31 39 32 30 30 20 62      serial: 19200 b
     1a0:	61 75 64 20 38 4e 31 20 0d 0a 00                    aud 8N1 ...

000001ab <__c.2112>:
     1ab:	20 2a 2a 2a 20 65 6d 61 69 6c 3a 20 73 74 65 66      *** email: stef
     1bb:	61 6e 40 70 65 72 7a 62 6f 72 6e 2e 6e 65 74 20     an@perzborn.net 
     1cb:	0d 0a 00                                            ...

000001ce <__c.2110>:
     1ce:	20 2a 2a 2a 20 77 65 62 3a 20 77 77 77 2e 70 65      *** web: www.pe
     1de:	72 7a 62 6f 72 6e 2e 6e 65 74 20 0d 0a 00           rzborn.net ...

000001ec <__c.2108>:
     1ec:	20 2a 2a 2a 20 76 65 72 73 69 6f 6e 20 31 2e 20      *** version 1. 
     1fc:	61 64 61 70 74 65 64 20 62 79 20 53 2e 50 65 72     adapted by S.Per
     20c:	7a 62 6f 72 6e 20 5b 32 33 2e 30 31 2e 32 30 30     zborn [23.01.200
     21c:	39 5d 20 2a 2a 2a 20 0d 0a 00                       9] *** ...

00000226 <__c.2106>:
     226:	0d 0a 41 64 61 6d 20 44 75 6e 6b 65 6c 73 20 75     ..Adam Dunkels u
     236:	49 50 20 77 65 62 73 65 72 76 65 72 20 65 78 61     IP webserver exa
     246:	6d 70 6c 65 20 66 6f 72 20 43 72 75 6d 62 36 34     mple for Crumb64
     256:	34 2d 4e 45 54 0d 0a 00                             4-NET...

0000025e <__c.2062>:
     25e:	0d 0a 00                                            ...

00000261 <__c.2057>:
     261:	2e 00                                               ..

00000263 <__c.2008>:
     263:	0d 0a 00                                            ...

00000266 <__c.2003>:
     266:	2e 00                                               ..

00000268 <__c.1990>:
     268:	20 62 79 74 65 73 20 0d 0a 00                        bytes ...

00000272 <__c.1988>:
     272:	61 76 61 69 6c 61 62 6c 65 20 52 41 4d 20 6d 65     available RAM me
     282:	6d 6f 72 79 3a 00                                   mory:.

00000288 <__c.1900>:
     288:	74 69 6d 65 6f 75 74 0d 0a 00                       timeout...

00000292 <__c.1895>:
     292:	74 69 6d 65 6f 75 74 0d 0a 00                       timeout...

0000029c <__c.1865>:
     29c:	0a 0d 00                                            ...

0000029f <__c.1860>:
     29f:	0a 0d 4d 41 43 3a 00                                ..MAC:.

000002a6 <__c.1762>:
     2a6:	43 50 32 32 30 30 20 62 75 66 66 65 72 20 66 75     CP2200 buffer fu
     2b6:	6c 6c 0d 0a 00                                      ll...

000002bb <__c.1916>:
     2bb:	4c 45 44 3d 30 0d 0a 00                             LED=0...

000002c3 <__c.1914>:
     2c3:	4c 45 44 3d 31 0d 0a 00                             LED=1...

000002cb <__c.1912>:
     2cb:	66 6f 75 6e 64 20 69 6f 2e 73 68 74 6d 6c 0d 0a     found io.shtml..
	...

000002dc <__c.1910>:
     2dc:	66 6f 75 6e 64 20 3f 0d 0a 00                       found ?...

000002e6 <__c.1774>:
     2e6:	0d 0a 53 43 52 49 50 54 00                          ..SCRIPT.

000002ef <data_processes_shtml>:
     2ef:	2f 70 72 6f 63 65 73 73 65 73 2e 73 68 74 6d 6c     /processes.shtml
     2ff:	00 25 21 3a 20 2f 68 65 61 64 65 72 2e 68 74 6d     .%!: /header.htm
     30f:	6c 0a 3c 68 31 3e 53 79 73 74 65 6d 20 70 72 6f     l.<h1>System pro
     31f:	63 65 73 73 65 73 3c 2f 68 31 3e 3c 62 72 3e 3c     cesses</h1><br><
     32f:	74 61 62 6c 65 20 77 69 64 74 68 3d 22 31 30 30     table width="100
     33f:	25 22 3e 0a 3c 74 72 3e 3c 74 68 3e 49 44 3c 2f     %">.<tr><th>ID</
     34f:	74 68 3e 3c 74 68 3e 4e 61 6d 65 3c 2f 74 68 3e     th><th>Name</th>
     35f:	3c 74 68 3e 50 72 69 6f 72 69 74 79 3c 2f 74 68     <th>Priority</th
     36f:	3e 3c 74 68 3e 50 6f 6c 6c 20 68 61 6e 64 6c 65     ><th>Poll handle
     37f:	72 3c 2f 74 68 3e 3c 74 68 3e 45 76 65 6e 74 20     r</th><th>Event 
     38f:	68 61 6e 64 6c 65 72 3c 2f 74 68 3e 3c 74 68 3e     handler</th><th>
     39f:	50 72 6f 63 73 74 61 74 65 3c 2f 74 68 3e 3c 2f     Procstate</th></
     3af:	74 72 3e 0a 25 21 20 70 72 6f 63 65 73 73 65 73     tr>.%! processes
     3bf:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
     3cf:	6c 00                                               l.

000003d1 <data_404_html>:
     3d1:	2f 34 30 34 2e 68 74 6d 6c 00 3c 68 74 6d 6c 3e     /404.html.<html>
     3e1:	0a 20 20 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72     .  <body bgcolor
     3f1:	3d 22 77 68 69 74 65 22 3e 0a 20 20 20 20 3c 63     ="white">.    <c
     401:	65 6e 74 65 72 3e 0a 20 20 20 20 20 20 3c 68 31     enter>.      <h1
     411:	3e 34 30 34 20 2d 20 66 69 6c 65 20 6e 6f 74 20     >404 - file not 
     421:	66 6f 75 6e 64 3c 2f 68 31 3e 0a 20 20 20 20 20     found</h1>.     
     431:	20 3c 68 33 3e 47 6f 20 3c 61 20 68 72 65 66 3d      <h3>Go <a href=
     441:	22 2f 22 3e 68 65 72 65 3c 2f 61 3e 20 69 6e 73     "/">here</a> ins
     451:	74 65 61 64 2e 3c 2f 68 33 3e 0a 20 20 20 20 3c     tead.</h3>.    <
     461:	2f 63 65 6e 74 65 72 3e 0a 20 20 3c 2f 62 6f 64     /center>.  </bod
     471:	79 3e 0a 3c 2f 68 74 6d 6c 3e 00                    y>.</html>.

0000047c <data_files_shtml>:
     47c:	2f 66 69 6c 65 73 2e 73 68 74 6d 6c 00 25 21 3a     /files.shtml.%!:
     48c:	20 2f 68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68      /header.html.<h
     49c:	31 3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63     1>File statistic
     4ac:	73 3c 2f 68 31 3e 0a 3c 63 65 6e 74 65 72 3e 0a     s</h1>.<center>.
     4bc:	3c 74 61 62 6c 65 20 77 69 64 74 68 3d 22 33 30     <table width="30
     4cc:	30 22 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68     0">.<tr><td><a h
     4dc:	72 65 66 3d 22 2f 69 6e 64 65 78 2e 68 74 6d 6c     ref="/index.html
     4ec:	22 3e 2f 69 6e 64 65 78 2e 68 74 6d 6c 3c 2f 61     ">/index.html</a
     4fc:	3e 3c 2f 74 64 3e 0a 3c 74 64 3e 25 21 20 66 69     ></td>.<td>%! fi
     50c:	6c 65 2d 73 74 61 74 73 20 2f 69 6e 64 65 78 2e     le-stats /index.
     51c:	68 74 6d 6c 0a 3c 2f 74 64 3e 3c 74 64 3e 3c 69     html.</td><td><i
     52c:	6d 67 20 73 72 63 3d 22 2f 66 61 64 65 2e 70 6e     mg src="/fade.pn
     53c:	67 22 20 68 65 69 67 68 74 3d 31 30 20 77 69 64     g" height=10 wid
     54c:	74 68 3d 25 21 20 66 69 6c 65 2d 73 74 61 74 73     th=%! file-stats
     55c:	20 2f 69 6e 64 65 78 2e 68 74 6d 6c 0a 3e 20 3c      /index.html.> <
     56c:	2f 74 64 3e 3c 2f 74 72 3e 0a 3c 74 72 3e 3c 74     /td></tr>.<tr><t
     57c:	64 3e 3c 61 20 68 72 65 66 3d 22 2f 66 69 6c 65     d><a href="/file
     58c:	73 2e 73 68 74 6d 6c 22 3e 2f 66 69 6c 65 73 2e     s.shtml">/files.
     59c:	73 68 74 6d 6c 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c     shtml</a></td>.<
     5ac:	74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61 74 73     td>%! file-stats
     5bc:	20 2f 66 69 6c 65 73 2e 73 68 74 6d 6c 0a 3c 2f      /files.shtml.</
     5cc:	74 64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d     td><td><img src=
     5dc:	22 2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67     "/fade.png" heig
     5ec:	68 74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66     ht=10 width=%! f
     5fc:	69 6c 65 2d 73 74 61 74 73 20 2f 66 69 6c 65 73     ile-stats /files
     60c:	2e 73 68 74 6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f     .shtml.> </td></
     61c:	74 72 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68     tr>.<tr><td><a h
     62c:	72 65 66 3d 22 2f 74 63 70 2e 73 68 74 6d 6c 22     ref="/tcp.shtml"
     63c:	3e 2f 74 63 70 2e 73 68 74 6d 6c 3c 2f 61 3e 3c     >/tcp.shtml</a><
     64c:	2f 74 64 3e 0a 3c 74 64 3e 25 21 20 66 69 6c 65     /td>.<td>%! file
     65c:	2d 73 74 61 74 73 20 2f 74 63 70 2e 73 68 74 6d     -stats /tcp.shtm
     66c:	6c 0a 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6d 67 20     l.</td><td><img 
     67c:	73 72 63 3d 22 2f 66 61 64 65 2e 70 6e 67 22 20     src="/fade.png" 
     68c:	68 65 69 67 68 74 3d 31 30 20 77 69 64 74 68 3d     height=10 width=
     69c:	25 21 20 66 69 6c 65 2d 73 74 61 74 73 20 2f 74     %! file-stats /t
     6ac:	63 70 2e 73 68 74 6d 6c 0a 3e 20 3c 2f 74 64 3e     cp.shtml.> </td>
     6bc:	3c 2f 74 72 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61     </tr>.<tr><td><a
     6cc:	20 68 72 65 66 3d 22 2f 73 74 61 74 73 2e 73 68      href="/stats.sh
     6dc:	74 6d 6c 22 3e 2f 73 74 61 74 73 2e 73 68 74 6d     tml">/stats.shtm
     6ec:	6c 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c 74 64 3e 25     l</a></td>.<td>%
     6fc:	21 20 66 69 6c 65 2d 73 74 61 74 73 20 2f 73 74     ! file-stats /st
     70c:	61 74 73 2e 73 68 74 6d 6c 0a 3c 2f 74 64 3e 3c     ats.shtml.</td><
     71c:	74 64 3e 3c 69 6d 67 20 73 72 63 3d 22 2f 66 61     td><img src="/fa
     72c:	64 65 2e 70 6e 67 22 20 68 65 69 67 68 74 3d 31     de.png" height=1
     73c:	30 20 77 69 64 74 68 3d 25 21 20 66 69 6c 65 2d     0 width=%! file-
     74c:	73 74 61 74 73 20 2f 73 74 61 74 73 2e 73 68 74     stats /stats.sht
     75c:	6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a     ml.> </td></tr>.
     76c:	3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65 66 3d     <tr><td><a href=
     77c:	22 2f 73 74 79 6c 65 2e 63 73 73 22 3e 2f 73 74     "/style.css">/st
     78c:	79 6c 65 2e 63 73 73 3c 2f 61 3e 3c 2f 74 64 3e     yle.css</a></td>
     79c:	0a 3c 74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61     .<td>%! file-sta
     7ac:	74 73 20 2f 73 74 79 6c 65 2e 63 73 73 0a 3c 2f     ts /style.css.</
     7bc:	74 64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d     td><td><img src=
     7cc:	22 2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67     "/fade.png" heig
     7dc:	68 74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66     ht=10 width=%! f
     7ec:	69 6c 65 2d 73 74 61 74 73 20 2f 73 74 79 6c 65     ile-stats /style
     7fc:	2e 63 73 73 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72     .css.> </td></tr
     80c:	3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65     >.<tr><td><a hre
     81c:	66 3d 22 2f 34 30 34 2e 68 74 6d 6c 22 3e 2f 34     f="/404.html">/4
     82c:	30 34 2e 68 74 6d 6c 3c 2f 61 3e 3c 2f 74 64 3e     04.html</a></td>
     83c:	0a 3c 74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61     .<td>%! file-sta
     84c:	74 73 20 2f 34 30 34 2e 68 74 6d 6c 0a 3c 2f 74     ts /404.html.</t
     85c:	64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d 22     d><td><img src="
     86c:	2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67 68     /fade.png" heigh
     87c:	74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66 69     t=10 width=%! fi
     88c:	6c 65 2d 73 74 61 74 73 20 2f 34 30 34 2e 68 74     le-stats /404.ht
     89c:	6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a     ml.> </td></tr>.
     8ac:	3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65 66 3d     <tr><td><a href=
     8bc:	22 2f 66 61 64 65 2e 70 6e 67 22 3e 2f 66 61 64     "/fade.png">/fad
     8cc:	65 2e 70 6e 67 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c     e.png</a></td>.<
     8dc:	74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61 74 73     td>%! file-stats
     8ec:	20 2f 66 61 64 65 2e 70 6e 67 0a 3c 2f 74 64 3e      /fade.png.</td>
     8fc:	3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d 22 2f 66     <td><img src="/f
     90c:	61 64 65 2e 70 6e 67 22 20 68 65 69 67 68 74 3d     ade.png" height=
     91c:	31 30 20 77 69 64 74 68 3d 25 21 20 66 69 6c 65     10 width=%! file
     92c:	2d 73 74 61 74 73 20 2f 66 61 64 65 2e 70 6e 67     -stats /fade.png
     93c:	0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a 3c 2f     .> </td></tr>.</
     94c:	74 61 62 6c 65 3e 0a 3c 2f 63 65 6e 74 65 72 3e     table>.</center>
     95c:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
     96c:	6c 0a 00                                            l..

0000096f <data_footer_html>:
     96f:	2f 66 6f 6f 74 65 72 2e 68 74 6d 6c 00 20 20 3c     /footer.html.  <
     97f:	2f 62 6f 64 79 3e 0a 3c 2f 68 74 6d 6c 3e 00        /body>.</html>.

0000098e <data_header_html>:
     98e:	2f 68 65 61 64 65 72 2e 68 74 6d 6c 00 3c 21 44     /header.html.<!D
     99e:	4f 43 54 59 50 45 20 48 54 4d 4c 20 50 55 42 4c     OCTYPE HTML PUBL
     9ae:	49 43 20 22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20     IC "-//W3C//DTD 
     9be:	48 54 4d 4c 20 34 2e 30 31 20 54 72 61 6e 73 69     HTML 4.01 Transi
     9ce:	74 69 6f 6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74     tional//EN" "htt
     9de:	70 3a 2f 2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54     p://www.w3.org/T
     9ee:	52 2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74     R/html4/loose.dt
     9fe:	64 22 3e 0a 3c 68 74 6d 6c 3e 0a 20 20 3c 68 65     d">.<html>.  <he
     a0e:	61 64 3e 0a 20 20 20 20 3c 74 69 74 6c 65 3e 57     ad>.    <title>W
     a1e:	65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 75 49     elcome to the uI
     a2e:	50 20 77 65 62 20 73 65 72 76 65 72 21 3c 2f 74     P web server!</t
     a3e:	69 74 6c 65 3e 0a 20 20 20 20 3c 6c 69 6e 6b 20     itle>.    <link 
     a4e:	72 65 6c 3d 22 73 74 79 6c 65 73 68 65 65 74 22     rel="stylesheet"
     a5e:	20 74 79 70 65 3d 22 74 65 78 74 2f 63 73 73 22      type="text/css"
     a6e:	20 68 72 65 66 3d 22 73 74 79 6c 65 2e 63 73 73      href="style.css
     a7e:	22 3e 20 20 0a 20 20 3c 2f 68 65 61 64 3e 0a 20     ">  .  </head>. 
     a8e:	20 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72 3d 22      <body bgcolor="
     a9e:	23 66 66 66 65 65 63 22 20 74 65 78 74 3d 22 62     #fffeec" text="b
     aae:	6c 61 63 6b 22 3e 0a 0a 20 20 3c 64 69 76 20 63     lack">..  <div c
     abe:	6c 61 73 73 3d 22 6d 65 6e 75 22 3e 0a 20 20 3c     lass="menu">.  <
     ace:	64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62     div class="menub
     ade:	6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 2f 22 3e     ox"><a href="/">
     aee:	46 72 6f 6e 74 20 70 61 67 65 3c 2f 61 3e 3c 2f     Front page</a></
     afe:	64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73     div>.  <div clas
     b0e:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
     b1e:	72 65 66 3d 22 66 69 6c 65 73 2e 73 68 74 6d 6c     ref="files.shtml
     b2e:	22 3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63     ">File statistic
     b3e:	73 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20 3c 64     s</a></div>.  <d
     b4e:	69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f     iv class="menubo
     b5e:	78 22 3e 3c 61 20 68 72 65 66 3d 22 73 74 61 74     x"><a href="stat
     b6e:	73 2e 73 68 74 6d 6c 22 3e 4e 65 74 77 6f 72 6b     s.shtml">Network
     b7e:	20 73 74 61 74 69 73 74 69 63 73 3c 2f 61 3e 3c      statistics</a><
     b8e:	2f 64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61     /div>.  <div cla
     b9e:	73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20     ss="menubox"><a 
     bae:	68 72 65 66 3d 22 74 63 70 2e 73 68 74 6d 6c 22     href="tcp.shtml"
     bbe:	3e 4e 65 74 77 6f 72 6b 0a 20 20 63 6f 6e 6e 65     >Network.  conne
     bce:	63 74 69 6f 6e 73 3c 2f 61 3e 3c 2f 64 69 76 3e     ctions</a></div>
     bde:	0a 20 20 3c 62 72 3e 0a 20 20 3c 2f 64 69 76 3e     .  <br>.  </div>
     bee:	0a 20 20 0a 20 20 3c 64 69 76 20 63 6c 61 73 73     .  .  <div class
     bfe:	3d 22 63 6f 6e 74 65 6e 74 62 6c 6f 63 6b 22 3e     ="contentblock">
     c0e:	0a 00                                               ..

00000c10 <data_index_html>:
     c10:	2f 69 6e 64 65 78 2e 68 74 6d 6c 00 3c 21 44 4f     /index.html.<!DO
     c20:	43 54 59 50 45 20 48 54 4d 4c 20 50 55 42 4c 49     CTYPE HTML PUBLI
     c30:	43 20 22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20 48     C "-//W3C//DTD H
     c40:	54 4d 4c 20 34 2e 30 31 20 54 72 61 6e 73 69 74     TML 4.01 Transit
     c50:	69 6f 6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74 70     ional//EN" "http
     c60:	3a 2f 2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54 52     ://www.w3.org/TR
     c70:	2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74 64     /html4/loose.dtd
     c80:	22 3e 0d 0a 3c 68 74 6d 6c 3e 0d 0a 20 20 3c 68     ">..<html>..  <h
     c90:	65 61 64 3e 0d 0a 20 20 20 20 3c 74 69 74 6c 65     ead>..    <title
     ca0:	3e 57 65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20     >Welcome to the 
     cb0:	75 49 50 20 77 65 62 20 73 65 72 76 65 72 21 3c     uIP web server!<
     cc0:	2f 74 69 74 6c 65 3e 0d 0a 20 20 20 20 3c 6c 69     /title>..    <li
     cd0:	6e 6b 20 72 65 6c 3d 22 73 74 79 6c 65 73 68 65     nk rel="styleshe
     ce0:	65 74 22 20 74 79 70 65 3d 22 74 65 78 74 2f 63     et" type="text/c
     cf0:	73 73 22 20 68 72 65 66 3d 22 73 74 79 6c 65 2e     ss" href="style.
     d00:	63 73 73 22 3e 20 20 0d 0a 20 20 3c 2f 68 65 61     css">  ..  </hea
     d10:	64 3e 0d 0a 20 20 3c 62 6f 64 79 20 62 67 63 6f     d>..  <body bgco
     d20:	6c 6f 72 3d 22 23 66 66 66 65 65 63 22 20 74 65     lor="#fffeec" te
     d30:	78 74 3d 22 62 6c 61 63 6b 22 3e 0d 0a 0d 0a 20     xt="black">.... 
     d40:	20 3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e      <div class="men
     d50:	75 22 3e 0d 0a 20 20 3c 64 69 76 20 63 6c 61 73     u">..  <div clas
     d60:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
     d70:	72 65 66 3d 22 2f 22 3e 46 72 6f 6e 74 20 70 61     ref="/">Front pa
     d80:	67 65 3c 2f 61 3e 3c 2f 64 69 76 3e 0d 0a 0d 0a     ge</a></div>....
     d90:	20 20 3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65       <div class="me
     da0:	6e 75 62 6f 78 22 3e 3c 61 20 68 72 65 66 3d 22     nubox"><a href="
     db0:	66 69 6c 65 73 2e 73 68 74 6d 6c 22 3e 46 69 6c     files.shtml">Fil
     dc0:	65 20 73 74 61 74 69 73 74 69 63 73 3c 2f 61 3e     e statistics</a>
     dd0:	3c 2f 64 69 76 3e 0d 0a 20 20 3c 64 69 76 20 63     </div>..  <div c
     de0:	6c 61 73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c     lass="menubox"><
     df0:	61 20 68 72 65 66 3d 22 73 74 61 74 73 2e 73 68     a href="stats.sh
     e00:	74 6d 6c 22 3e 4e 65 74 77 6f 72 6b 20 73 74 61     tml">Network sta
     e10:	74 69 73 74 69 63 73 3c 2f 61 3e 3c 2f 64 69 76     tistics</a></div
     e20:	3e 0d 0a 20 20 3c 64 69 76 20 63 6c 61 73 73 3d     >..  <div class=
     e30:	22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68 72 65     "menubox"><a hre
     e40:	66 3d 22 74 63 70 2e 73 68 74 6d 6c 22 3e 4e 65     f="tcp.shtml">Ne
     e50:	74 77 6f 72 6b 20 63 6f 6e 6e 65 63 74 69 6f 6e     twork connection
     e60:	73 3c 2f 61 3e 3c 2f 64 69 76 3e 0d 0a 09 3c 64     s</a></div>...<d
     e70:	69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f     iv class="menubo
     e80:	78 22 3e 3c 61 20 68 72 65 66 3d 22 69 6f 2e 73     x"><a href="io.s
     e90:	68 74 6d 6c 22 3e 49 4f 3c 2f 61 3e 3c 2f 64 69     html">IO</a></di
     ea0:	76 3e 0d 0a 20 20 3c 62 72 3e 0d 0a 20 20 3c 2f     v>..  <br>..  </
     eb0:	64 69 76 3e 0d 0a 0d 0a 20 20 3c 64 69 76 20 63     div>....  <div c
     ec0:	6c 61 73 73 3d 22 63 6f 6e 74 65 6e 74 62 6c 6f     lass="contentblo
     ed0:	63 6b 22 3e 0d 0a 20 20 3c 70 3e 0d 0a 53 74 65     ck">..  <p>..Ste
     ee0:	66 61 6e 20 50 65 72 7a 62 6f 72 6e 27 73 20 43     fan Perzborn's C
     ef0:	72 75 6d 62 36 34 34 2d 4e 45 54 20 57 65 62 73     rumb644-NET Webs
     f00:	65 72 76 65 72 20 65 78 61 6d 70 6c 65 20 76 31     erver example v1
     f10:	2e 33 2e 3c 62 72 3e 54 68 65 73 65 20 77 65 62     .3.<br>These web
     f20:	20 70 61 67 65 73 20 61 72 65 20 73 65 72 76 65      pages are serve
     f30:	64 20 62 79 20 61 20 73 6d 61 6c 6c 20 77 65 62     d by a small web
     f40:	20 73 65 72 76 65 72 20 72 75 6e 6e 69 6e 67 20      server running 
     f50:	6f 6e 20 74 6f 70 20 6f 66 20 74 68 65 20 3c 61     on top of the <a
     f60:	20 68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77      href="http://ww
     f70:	77 2e 73 69 63 73 2e 73 65 2f 7e 61 64 61 6d 2f     w.sics.se/~adam/
     f80:	75 69 70 2f 22 3e 75 49 50 20 65 6d 62 65 64 64     uip/">uIP embedd
     f90:	65 64 20 54 43 50 2f 49 50 20 73 74 61 63 6b 3c     ed TCP/IP stack<
     fa0:	2f 61 3e 2e 3c 62 72 3e 0d 0a 50 6f 72 74 65 64     /a>.<br>..Ported
     fb0:	20 74 6f 20 43 72 75 6d 62 36 34 34 2d 4e 45 54      to Crumb644-NET
     fc0:	20 6d 6f 64 75 6c 65 20 62 79 20 53 74 65 66 61      module by Stefa
     fd0:	6e 20 50 65 72 7a 62 6f 72 6e 20 3c 61 20 68 72     n Perzborn <a hr
     fe0:	65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77 2e 70     ef="http://www.p
     ff0:	65 72 7a 62 6f 72 6e 2e 6e 65 74 22 3e 28 77 77     erzborn.net">(ww
    1000:	77 2e 70 65 72 7a 62 6f 72 6e 2e 6e 65 74 29 3c     w.perzborn.net)<
    1010:	2f 61 0d 0a 20 20 3c 2f 70 3e 0d 0a 20 20 3c 70     /a..  </p>..  <p
    1020:	3e 0d 0a 20 20 43 6c 69 63 6b 20 6f 6e 20 74 68     >..  Click on th
    1030:	65 20 6c 69 6e 6b 73 20 61 62 6f 76 65 20 66 6f     e links above fo
    1040:	72 20 77 65 62 20 73 65 72 76 65 72 20 73 65 72     r web server ser
    1050:	76 69 63 65 20 61 6e 64 20 73 74 61 74 69 73 74     vice and statist
    1060:	69 63 73 2e 0d 0a 20 20 3c 2f 70 3e 0d 0a 20 20     ics...  </p>..  
    1070:	3c 2f 62 6f 64 79 3e 0d 0a 3c 2f 68 74 6d 6c 3e     </body>..</html>
    1080:	0d 0a 00                                            ...

00001083 <data_style_css>:
    1083:	2f 73 74 79 6c 65 2e 63 73 73 00 68 31 20 0a 7b     /style.css.h1 .{
    1093:	0a 20 20 74 65 78 74 2d 61 6c 69 67 6e 3a 20 63     .  text-align: c
    10a3:	65 6e 74 65 72 3b 0a 20 20 66 6f 6e 74 2d 73 69     enter;.  font-si
    10b3:	7a 65 3a 31 34 70 74 3b 0a 20 20 66 6f 6e 74 2d     ze:14pt;.  font-
    10c3:	66 61 6d 69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c     family:arial,hel
    10d3:	76 65 74 69 63 61 3b 0a 20 20 66 6f 6e 74 2d 77     vetica;.  font-w
    10e3:	65 69 67 68 74 3a 62 6f 6c 64 3b 0a 20 20 70 61     eight:bold;.  pa
    10f3:	64 64 69 6e 67 3a 31 30 70 78 3b 20 0a 7d 0a 0a     dding:10px; .}..
    1103:	62 6f 64 79 0a 7b 0a 0a 20 20 62 61 63 6b 67 72     body.{..  backgr
    1113:	6f 75 6e 64 2d 63 6f 6c 6f 72 3a 20 23 66 66 66     ound-color: #fff
    1123:	65 65 63 3b 0a 20 20 63 6f 6c 6f 72 3a 62 6c 61     eec;.  color:bla
    1133:	63 6b 3b 0a 0a 20 20 66 6f 6e 74 2d 73 69 7a 65     ck;..  font-size
    1143:	3a 38 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61 6d     :8pt;.  font-fam
    1153:	69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c 76 65 74     ily:arial,helvet
    1163:	69 63 61 3b 0a 7d 0a 0a 2e 6d 65 6e 75 0a 7b 0a     ica;.}...menu.{.
    1173:	20 20 6d 61 72 67 69 6e 3a 20 34 70 78 3b 0a 20       margin: 4px;. 
    1183:	20 77 69 64 74 68 3a 37 30 25 3b 0a 09 0a 20 20      width:70%;...  
    1193:	70 61 64 64 69 6e 67 3a 32 30 70 78 3b 0a 09 0a     padding:20px;...
    11a3:	20 20 62 6f 72 64 65 72 3a 20 73 6f 6c 69 64 20       border: solid 
    11b3:	31 70 78 3b 0a 20 20 62 61 63 6b 67 72 6f 75 6e     1px;.  backgroun
    11c3:	64 2d 63 6f 6c 6f 72 3a 20 23 66 66 66 63 64 32     d-color: #fffcd2
    11d3:	3b 0a 20 20 74 65 78 74 2d 61 6c 69 67 6e 3a 6c     ;.  text-align:l
    11e3:	65 66 74 3b 0a 20 20 0a 20 20 66 6f 6e 74 2d 73     eft;.  .  font-s
    11f3:	69 7a 65 3a 39 70 74 3b 0a 20 20 66 6f 6e 74 2d     ize:9pt;.  font-
    1203:	66 61 6d 69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c     family:arial,hel
    1213:	76 65 74 69 63 61 3b 20 20 0a 7d 0a 0a 64 69 76     vetica;  .}..div
    1223:	2e 6d 65 6e 75 62 6f 78 0a 7b 0a 20 20 77 69 64     .menubox.{.  wid
    1233:	74 68 3a 20 32 30 25 3b 0a 09 0a 20 20 62 6f 72     th: 20%;...  bor
    1243:	64 65 72 3a 20 30 3b 0a 20 20 66 6c 6f 61 74 3a     der: 0;.  float:
    1253:	20 6c 65 66 74 3b 0a 74 65 78 74 2d 61 6c 69 67      left;.text-alig
    1263:	6e 3a 20 63 65 6e 74 65 72 3b 0a 7d 0a 0a 2e 63     n: center;.}...c
    1273:	6f 6e 74 65 6e 74 62 6c 6f 63 6b 0a 7b 20 20 0a     ontentblock.{  .
    1283:	20 20 6d 61 72 67 69 6e 3a 20 34 70 78 3b 0a 20       margin: 4px;. 
    1293:	20 77 69 64 74 68 3a 37 30 25 3b 0a 0a 20 20 70      width:70%;..  p
    12a3:	61 64 64 69 6e 67 3a 32 30 70 78 3b 0a 0a 20 20     adding:20px;..  
    12b3:	62 6f 72 64 65 72 3a 20 31 70 78 20 64 6f 74 74     border: 1px dott
    12c3:	65 64 3b 0a 20 20 62 61 63 6b 67 72 6f 75 6e 64     ed;.  background
    12d3:	2d 63 6f 6c 6f 72 3a 20 77 68 69 74 65 3b 0a 0a     -color: white;..
    12e3:	20 20 66 6f 6e 74 2d 73 69 7a 65 3a 38 70 74 3b       font-size:8pt;
    12f3:	0a 20 20 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a 61     .  font-family:a
    1303:	72 69 61 6c 2c 68 65 6c 76 65 74 69 63 61 3b 20     rial,helvetica; 
    1313:	20 0a 0a 7d 0a 0a 70 2e 69 6e 74 72 6f 0a 7b 0a      ..}..p.intro.{.
    1323:	20 20 6d 61 72 67 69 6e 2d 6c 65 66 74 3a 32 30       margin-left:20
    1333:	70 78 3b 0a 20 20 6d 61 72 67 69 6e 2d 72 69 67     px;.  margin-rig
    1343:	68 74 3a 32 30 70 78 3b 0a 0a 20 20 66 6f 6e 74     ht:20px;..  font
    1353:	2d 73 69 7a 65 3a 31 30 70 74 3b 0a 2f 2a 20 20     -size:10pt;./*  
    1363:	66 6f 6e 74 2d 77 65 69 67 68 74 3a 62 6f 6c 64     font-weight:bold
    1373:	3b 20 2a 2f 0a 20 20 66 6f 6e 74 2d 66 61 6d 69     ; */.  font-fami
    1383:	6c 79 3a 61 72 69 61 6c 2c 68 65 6c 76 65 74 69     ly:arial,helveti
    1393:	63 61 3b 20 20 0a 7d 0a 0a 70 2e 63 6c 69 6e 6b     ca;  .}..p.clink
    13a3:	0a 7b 0a 20 20 66 6f 6e 74 2d 73 69 7a 65 3a 31     .{.  font-size:1
    13b3:	32 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61 6d 69     2pt;.  font-fami
    13c3:	6c 79 3a 63 6f 75 72 69 65 72 2c 6d 6f 6e 6f 73     ly:courier,monos
    13d3:	70 61 63 65 3b 20 20 0a 20 20 74 65 78 74 2d 61     pace;  .  text-a
    13e3:	6c 69 67 6e 3a 63 65 6e 74 65 72 3b 0a 7d 0a 0a     lign:center;.}..
    13f3:	70 2e 63 6c 69 6e 6b 39 0a 7b 0a 20 20 66 6f 6e     p.clink9.{.  fon
    1403:	74 2d 73 69 7a 65 3a 39 70 74 3b 0a 20 20 66 6f     t-size:9pt;.  fo
    1413:	6e 74 2d 66 61 6d 69 6c 79 3a 63 6f 75 72 69 65     nt-family:courie
    1423:	72 2c 6d 6f 6e 6f 73 70 61 63 65 3b 20 20 0a 20     r,monospace;  . 
    1433:	20 74 65 78 74 2d 61 6c 69 67 6e 3a 63 65 6e 74      text-align:cent
    1443:	65 72 3b 0a 7d 0a 0a 0a 70 0a 7b 0a 20 20 70 61     er;.}...p.{.  pa
    1453:	64 64 69 6e 67 2d 6c 65 66 74 3a 31 30 70 78 3b     dding-left:10px;
    1463:	0a 7d 0a 0a 70 2e 72 69 67 68 74 0a 7b 0a 20 20     .}..p.right.{.  
    1473:	74 65 78 74 2d 61 6c 69 67 6e 3a 72 69 67 68 74     text-align:right
    1483:	3b 20 0a 7d 0a 00                                   ; .}..

00001489 <data_tcp_shtml>:
    1489:	2f 74 63 70 2e 73 68 74 6d 6c 00 25 21 3a 20 2f     /tcp.shtml.%!: /
    1499:	68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68 31 3e     header.html.<h1>
    14a9:	43 75 72 72 65 6e 74 20 63 6f 6e 6e 65 63 74 69     Current connecti
    14b9:	6f 6e 73 3c 2f 68 31 3e 3c 62 72 3e 3c 74 61 62     ons</h1><br><tab
    14c9:	6c 65 20 77 69 64 74 68 3d 22 31 30 30 25 22 3e     le width="100%">
    14d9:	0a 3c 74 72 3e 3c 74 68 3e 4c 6f 63 61 6c 3c 2f     .<tr><th>Local</
    14e9:	74 68 3e 3c 74 68 3e 52 65 6d 6f 74 65 3c 2f 74     th><th>Remote</t
    14f9:	68 3e 3c 74 68 3e 53 74 61 74 65 3c 2f 74 68 3e     h><th>State</th>
    1509:	3c 74 68 3e 52 65 74 72 61 6e 73 6d 69 73 73 69     <th>Retransmissi
    1519:	6f 6e 73 3c 2f 74 68 3e 3c 74 68 3e 54 69 6d 65     ons</th><th>Time
    1529:	72 3c 2f 74 68 3e 3c 74 68 3e 46 6c 61 67 73 3c     r</th><th>Flags<
    1539:	2f 74 68 3e 3c 2f 74 72 3e 0a 25 21 20 74 63 70     /th></tr>.%! tcp
    1549:	2d 63 6f 6e 6e 65 63 74 69 6f 6e 73 0a 25 21 3a     -connections.%!:
    1559:	20 2f 66 6f 6f 74 65 72 2e 68 74 6d 6c 0a 0a 00      /footer.html...

00001569 <data_fade_png>:
    1569:	2f 66 61 64 65 2e 70 6e 67 00 89 50 4e 47 0d 0a     /fade.png..PNG..
    1579:	1a 0a 00 00 00 0d 49 48 44 52 00 00 00 04 00 00     ......IHDR......
    1589:	00 0a 08 02 00 00 00 1c 99 68 59 00 00 00 09 70     .........hY....p
    1599:	48 59 73 00 00 0b 13 00 00 0b 13 01 00 9a 9c 18     HYs.............
    15a9:	00 00 00 07 74 49 4d 45 07 d6 06 08 14 1b 39 af     ....tIME......9.
    15b9:	5b c0 e3 00 00 00 1d 74 45 58 74 43 6f 6d 6d 65     [......tEXtComme
    15c9:	6e 74 00 43 72 65 61 74 65 64 20 77 69 74 68 20     nt.Created with 
    15d9:	54 68 65 20 47 49 4d 50 ef 64 25 6e 00 00 00 3a     The GIMP.d%n...:
    15e9:	49 44 41 54 08 d7 75 8c 31 12 00 10 10 c4 2e 37     IDAT..u.1......7
    15f9:	9e 40 65 fd ff 83 f4 0a 1c 8d 54 9b c9 cc 9a 3d     .@e.......T....=
    1609:	90 73 71 67 91 d4 74 36 a9 55 01 f8 29 58 c8 bf     .sqg..t6.U..)X..
    1619:	48 c4 81 74 0b a3 0f 7c db 04 e8 40 05 df a1 f3     H..t...|...@....
    1629:	fc 73 00 00 00 00 49 45 4e 44 ae 42 60 82 00        .s....IEND.B`..

00001638 <data_stats_shtml>:
    1638:	2f 73 74 61 74 73 2e 73 68 74 6d 6c 00 25 21 3a     /stats.shtml.%!:
    1648:	20 2f 68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68      /header.html.<h
    1658:	31 3e 4e 65 74 77 6f 72 6b 20 73 74 61 74 69 73     1>Network statis
    1668:	74 69 63 73 3c 2f 68 31 3e 0a 3c 63 65 6e 74 65     tics</h1>.<cente
    1678:	72 3e 0a 3c 74 61 62 6c 65 20 77 69 64 74 68 3d     r>.<table width=
    1688:	22 33 30 30 22 20 62 6f 72 64 65 72 3d 22 30 22     "300" border="0"
    1698:	3e 0a 3c 74 72 3e 3c 74 64 3e 3c 70 72 65 3e 0a     >.<tr><td><pre>.
    16a8:	49 50 20 20 20 20 20 20 20 20 20 20 20 50 61 63     IP           Pac
    16b8:	6b 65 74 73 20 72 65 63 65 69 76 65 64 0a 20 20     kets received.  
    16c8:	20 20 20 20 20 20 20 20 20 20 20 50 61 63 6b 65                Packe
    16d8:	74 73 20 73 65 6e 74 0a 09 20 20 20 20 20 50 61     ts sent..     Pa
    16e8:	63 6b 65 74 73 20 64 72 6f 70 70 65 64 0a 49 50     ckets dropped.IP
    16f8:	20 65 72 72 6f 72 73 20 20 20 20 49 50 20 76 65      errors    IP ve
    1708:	72 73 69 6f 6e 2f 68 65 61 64 65 72 20 6c 65 6e     rsion/header len
    1718:	67 74 68 0a 20 20 20 20 20 20 20 20 20 20 20 20     gth.            
    1728:	20 49 50 20 6c 65 6e 67 74 68 2c 20 68 69 67 68      IP length, high
    1738:	20 62 79 74 65 0a 20 20 20 20 20 20 20 20 20 20      byte.          
    1748:	20 20 20 49 50 20 6c 65 6e 67 74 68 2c 20 6c 6f        IP length, lo
    1758:	77 20 62 79 74 65 0a 20 20 20 20 20 20 20 20 20     w byte.         
    1768:	20 20 20 20 49 50 20 66 72 61 67 6d 65 6e 74 73         IP fragments
    1778:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 48 65     .             He
    1788:	61 64 65 72 20 63 68 65 63 6b 73 75 6d 0a 20 20     ader checksum.  
    1798:	20 20 20 20 20 20 20 20 20 20 20 57 72 6f 6e 67                Wrong
    17a8:	20 70 72 6f 74 6f 63 6f 6c 0a 49 43 4d 50 09 20      protocol.ICMP. 
    17b8:	20 20 20 20 50 61 63 6b 65 74 73 20 72 65 63 65         Packets rece
    17c8:	69 76 65 64 0a 20 20 20 20 20 20 20 20 20 20 20     ived.           
    17d8:	20 20 50 61 63 6b 65 74 73 20 73 65 6e 74 0a 20       Packets sent. 
    17e8:	20 20 20 20 20 20 20 20 20 20 20 20 50 61 63 6b                 Pack
    17f8:	65 74 73 20 64 72 6f 70 70 65 64 0a 20 20 20 20     ets dropped.    
    1808:	20 20 20 20 20 20 20 20 20 54 79 70 65 20 65 72              Type er
    1818:	72 6f 72 73 0a 54 43 50 20 20 20 20 20 20 20 20     rors.TCP        
    1828:	20 20 50 61 63 6b 65 74 73 20 72 65 63 65 69 76       Packets receiv
    1838:	65 64 0a 20 20 20 20 20 20 20 20 20 20 20 20 20     ed.             
    1848:	50 61 63 6b 65 74 73 20 73 65 6e 74 0a 20 20 20     Packets sent.   
    1858:	20 20 20 20 20 20 20 20 20 20 50 61 63 6b 65 74               Packet
    1868:	73 20 64 72 6f 70 70 65 64 0a 20 20 20 20 20 20     s dropped.      
    1878:	20 20 20 20 20 20 20 43 68 65 63 6b 73 75 6d 20            Checksum 
    1888:	65 72 72 6f 72 73 0a 20 20 20 20 20 20 20 20 20     errors.         
    1898:	20 20 20 20 44 61 74 61 20 70 61 63 6b 65 74 73         Data packets
    18a8:	20 77 69 74 68 6f 75 74 20 41 43 4b 73 0a 20 20      without ACKs.  
    18b8:	20 20 20 20 20 20 20 20 20 20 20 52 65 73 65 74                Reset
    18c8:	73 0a 20 20 20 20 20 20 20 20 20 20 20 20 20 52     s.             R
    18d8:	65 74 72 61 6e 73 6d 69 73 73 69 6f 6e 73 0a 09     etransmissions..
    18e8:	20 20 20 20 20 4e 6f 20 63 6f 6e 6e 65 63 74 69          No connecti
    18f8:	6f 6e 20 61 76 61 6c 69 61 62 6c 65 0a 09 20 20     on avaliable..  
    1908:	20 20 20 43 6f 6e 6e 65 63 74 69 6f 6e 20 61 74        Connection at
    1918:	74 65 6d 70 74 73 20 74 6f 20 63 6c 6f 73 65 64     tempts to closed
    1928:	20 70 6f 72 74 73 0a 3c 2f 70 72 65 3e 3c 2f 74      ports.</pre></t
    1938:	64 3e 3c 74 64 3e 3c 70 72 65 3e 25 21 20 6e 65     d><td><pre>%! ne
    1948:	74 2d 73 74 61 74 73 0a 3c 2f 70 72 65 3e 3c 2f     t-stats.</pre></
    1958:	74 61 62 6c 65 3e 0a 3c 2f 63 65 6e 74 65 72 3e     table>.</center>
    1968:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
    1978:	6c 0a 00                                            l..

0000197b <data_io_shtml>:
    197b:	2f 69 6f 2e 73 68 74 6d 6c 00 3c 21 44 4f 43 54     /io.shtml.<!DOCT
    198b:	59 50 45 20 48 54 4d 4c 20 50 55 42 4c 49 43 20     YPE HTML PUBLIC 
    199b:	22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20 48 54 4d     "-//W3C//DTD HTM
    19ab:	4c 20 34 2e 30 31 20 54 72 61 6e 73 69 74 69 6f     L 4.01 Transitio
    19bb:	6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74 70 3a 2f     nal//EN" "http:/
    19cb:	2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54 52 2f 68     /www.w3.org/TR/h
    19db:	74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74 64 22 3e     tml4/loose.dtd">
    19eb:	0a 3c 68 74 6d 6c 3e 0a 20 20 3c 68 65 61 64 3e     .<html>.  <head>
    19fb:	0a 20 20 20 20 3c 74 69 74 6c 65 3e 55 69 70 20     .    <title>Uip 
    1a0b:	57 65 62 73 65 72 76 65 72 20 6f 75 74 70 75 74     Webserver output
    1a1b:	20 64 65 6d 6f 3c 2f 74 69 74 6c 65 3e 0a 20 20      demo</title>.  
    1a2b:	20 20 3c 6c 69 6e 6b 20 72 65 6c 3d 22 73 74 79       <link rel="sty
    1a3b:	6c 65 73 68 65 65 74 22 20 74 79 70 65 3d 22 74     lesheet" type="t
    1a4b:	65 78 74 2f 63 73 73 22 20 68 72 65 66 3d 22 73     ext/css" href="s
    1a5b:	74 79 6c 65 2e 63 73 73 22 3e 20 20 0a 20 20 3c     tyle.css">  .  <
    1a6b:	2f 68 65 61 64 3e 0a 20 20 3c 62 6f 64 79 20 62     /head>.  <body b
    1a7b:	67 63 6f 6c 6f 72 3d 22 23 66 66 66 65 65 63 22     gcolor="#fffeec"
    1a8b:	20 74 65 78 74 3d 22 62 6c 61 63 6b 22 3e 0a 0a      text="black">..
    1a9b:	20 20 3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65       <div class="me
    1aab:	6e 75 22 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73     nu">.  <div clas
    1abb:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
    1acb:	72 65 66 3d 22 2f 22 3e 46 72 6f 6e 74 20 70 61     ref="/">Front pa
    1adb:	67 65 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20 3c     ge</a></div>.  <
    1aeb:	64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62     div class="menub
    1afb:	6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 66 69 6c     ox"><a href="fil
    1b0b:	65 73 2e 73 68 74 6d 6c 22 3e 46 69 6c 65 20 73     es.shtml">File s
    1b1b:	74 61 74 69 73 74 69 63 73 3c 2f 61 3e 3c 2f 64     tatistics</a></d
    1b2b:	69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73 73     iv>.  <div class
    1b3b:	3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68 72     ="menubox"><a hr
    1b4b:	65 66 3d 22 73 74 61 74 73 2e 73 68 74 6d 6c 22     ef="stats.shtml"
    1b5b:	3e 4e 65 74 77 6f 72 6b 20 73 74 61 74 69 73 74     >Network statist
    1b6b:	69 63 73 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20     ics</a></div>.  
    1b7b:	3c 64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75     <div class="menu
    1b8b:	62 6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 74 63     box"><a href="tc
    1b9b:	70 2e 73 68 74 6d 6c 22 3e 4e 65 74 77 6f 72 6b     p.shtml">Network
    1bab:	20 63 6f 6e 6e 65 63 74 69 6f 6e 73 3c 2f 61 3e      connections</a>
    1bbb:	3c 2f 64 69 76 3e 0a 09 3c 64 69 76 20 63 6c 61     </div>..<div cla
    1bcb:	73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20     ss="menubox"><a 
    1bdb:	68 72 65 66 3d 22 69 6f 2e 73 68 74 6d 6c 22 3e     href="io.shtml">
    1beb:	49 4f 20 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20     IO </a></div>.  
    1bfb:	3c 62 72 3e 0a 20 20 3c 2f 64 69 76 3e 0a 20 20     <br>.  </div>.  
    1c0b:	3c 64 69 76 20 63 6c 61 73 73 3d 22 63 6f 6e 74     <div class="cont
    1c1b:	65 6e 74 62 6c 6f 63 6b 22 3e 0a 09 3c 68 31 3e     entblock">..<h1>
    1c2b:	53 77 69 74 63 68 20 4c 45 44 3c 2f 68 31 3e 0a     Switch LED</h1>.
    1c3b:	09 3c 70 20 73 74 79 6c 65 3d 22 66 6f 6e 74 2d     .<p style="font-
    1c4b:	66 61 6d 69 6c 79 3a 41 72 69 61 6c 2c 73 61 6e     family:Arial,san
    1c5b:	73 2d 73 65 72 69 66 3b 20 66 6f 6e 74 2d 73 69     s-serif; font-si
    1c6b:	7a 65 3a 31 35 70 78 3b 20 63 6f 6c 6f 72 3a 62     ze:15px; color:b
    1c7b:	6c 75 65 22 3e 0a 09 09 5b 3c 61 20 68 72 65 66     lue">...[<a href
    1c8b:	3d 22 2f 69 6f 2e 73 68 74 6d 6c 3f 4c 45 44 31     ="/io.shtml?LED1
    1c9b:	3d 31 22 3e 67 72 65 65 6e 20 4c 45 44 20 4f 4e     =1">green LED ON
    1cab:	3c 2f 61 3e 5d 3c 62 72 3e 0a 09 3c 2f 70 3e 0a     </a>]<br>..</p>.
    1cbb:	09 3c 70 3e 0a 09 09 3c 70 20 73 74 79 6c 65 3d     .<p>...<p style=
    1ccb:	22 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a 41 72 69     "font-family:Ari
    1cdb:	61 6c 2c 73 61 6e 73 2d 73 65 72 69 66 3b 20 66     al,sans-serif; f
    1ceb:	6f 6e 74 2d 73 69 7a 65 3a 31 35 70 78 3b 20 63     ont-size:15px; c
    1cfb:	6f 6c 6f 72 3a 62 6c 75 65 22 3e 0a 09 09 5b 3c     olor:blue">...[<
    1d0b:	61 20 68 72 65 66 3d 22 2f 69 6f 2e 73 68 74 6d     a href="/io.shtm
    1d1b:	6c 3f 4c 45 44 31 3d 30 22 3e 67 72 65 65 6e 20     l?LED1=0">green 
    1d2b:	4c 45 44 20 4f 46 46 3c 2f 61 3e 5d 3c 62 72 3e     LED OFF</a>]<br>
    1d3b:	0a 20 20 3c 2f 70 3e 0a 20 20 3c 2f 62 6f 64 79     .  </p>.  </body
    1d4b:	3e 0a 3c 2f 68 74 6d 6c 3e 0a 00                    >.</html>..

00001d56 <http_http>:
    1d56:	68 74 74 70 3a 2f 2f 00                             http://.

00001d5e <http_200>:
    1d5e:	32 30 30 20 00                                      200 .

00001d63 <http_301>:
    1d63:	33 30 31 20 00                                      301 .

00001d68 <http_302>:
    1d68:	33 30 32 20 00                                      302 .

00001d6d <http_get>:
    1d6d:	47 45 54 20 00                                      GET .

00001d72 <http_10>:
    1d72:	48 54 54 50 2f 31 2e 30 00                          HTTP/1.0.

00001d7b <http_11>:
    1d7b:	48 54 54 50 2f 31 2e 31 00                          HTTP/1.1.

00001d84 <http_content_type>:
    1d84:	63 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 00        content-type: .

00001d93 <http_texthtml>:
    1d93:	74 65 78 74 2f 68 74 6d 6c 00                       text/html.

00001d9d <http_location>:
    1d9d:	6c 6f 63 61 74 69 6f 6e 3a 20 00                    location: .

00001da8 <http_host>:
    1da8:	68 6f 73 74 3a 20 00                                host: .

00001daf <http_crnl>:
    1daf:	0d 0a 00                                            ...

00001db2 <http_index_html>:
    1db2:	2f 69 6e 64 65 78 2e 68 74 6d 6c 00                 /index.html.

00001dbe <http_404_html>:
    1dbe:	2f 34 30 34 2e 68 74 6d 6c 00                       /404.html.

00001dc8 <http_referer>:
    1dc8:	52 65 66 65 72 65 72 3a 00                          Referer:.

00001dd1 <http_header_200>:
    1dd1:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
    1de1:	0a 53 65 72 76 65 72 3a 20 75 49 50 2f 31 2e 30     .Server: uIP/1.0
    1df1:	20 68 74 74 70 3a 2f 2f 77 77 77 2e 73 69 63 73      http://www.sics
    1e01:	2e 73 65 2f 7e 61 64 61 6d 2f 75 69 70 2f 0d 0a     .se/~adam/uip/..
    1e11:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
    1e21:	65 0d 0a 00                                         e...

00001e25 <http_header_404>:
    1e25:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
    1e35:	20 66 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      found..Server: 
    1e45:	75 49 50 2f 31 2e 30 20 68 74 74 70 3a 2f 2f 77     uIP/1.0 http://w
    1e55:	77 77 2e 73 69 63 73 2e 73 65 2f 7e 61 64 61 6d     ww.sics.se/~adam
    1e65:	2f 75 69 70 2f 0d 0a 43 6f 6e 6e 65 63 74 69 6f     /uip/..Connectio
    1e75:	6e 3a 20 63 6c 6f 73 65 0d 0a 00                    n: close...

00001e80 <http_content_type_plain>:
    1e80:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
    1e90:	78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 00              xt/plain.....

00001e9d <http_content_type_html>:
    1e9d:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
    1ead:	78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00                 xt/html.....

00001eb9 <http_content_type_css>:
    1eb9:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
    1ec9:	78 74 2f 63 73 73 0d 0a 0d 0a 00                    xt/css.....

00001ed4 <http_content_type_text>:
    1ed4:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
    1ee4:	78 74 2f 74 65 78 74 0d 0a 0d 0a 00                 xt/text.....

00001ef0 <http_content_type_png>:
    1ef0:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
    1f00:	61 67 65 2f 70 6e 67 0d 0a 0d 0a 00                 age/png.....

00001f0c <http_content_type_gif>:
    1f0c:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
    1f1c:	61 67 65 2f 67 69 66 0d 0a 0d 0a 00                 age/gif.....

00001f28 <http_content_type_jpg>:
    1f28:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
    1f38:	61 67 65 2f 6a 70 65 67 0d 0a 0d 0a 00              age/jpeg.....

00001f45 <http_content_type_binary>:
    1f45:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 61 70     Content-type: ap
    1f55:	70 6c 69 63 61 74 69 6f 6e 2f 6f 63 74 65 74 2d     plication/octet-
    1f65:	73 74 72 65 61 6d 0d 0a 0d 0a 00                    stream.....

00001f70 <http_html>:
    1f70:	2e 68 74 6d 6c 00                                   .html.

00001f76 <http_shtml>:
    1f76:	2e 73 68 74 6d 6c 00                                .shtml.

00001f7d <http_htm>:
    1f7d:	2e 68 74 6d 00                                      .htm.

00001f82 <http_css>:
    1f82:	2e 63 73 73 00                                      .css.

00001f87 <http_png>:
    1f87:	2e 70 6e 67 00                                      .png.

00001f8c <http_gif>:
    1f8c:	2e 67 69 66 00                                      .gif.

00001f91 <http_jpg>:
    1f91:	2e 6a 70 67 00                                      .jpg.

00001f96 <http_text>:
    1f96:	2e 74 78 74 00                                      .txt.

00001f9b <http_txt>:
    1f9b:	2e 74 78 74 00                                      .txt.

00001fa0 <__ctors_end>:
    1fa0:	11 24       	eor	r1, r1
    1fa2:	1f be       	out	0x3f, r1	; 63
    1fa4:	cf ef       	ldi	r28, 0xFF	; 255
    1fa6:	d0 e1       	ldi	r29, 0x10	; 16
    1fa8:	de bf       	out	0x3e, r29	; 62
    1faa:	cd bf       	out	0x3d, r28	; 61

00001fac <__do_copy_data>:
    1fac:	13 e0       	ldi	r17, 0x03	; 3
    1fae:	a0 e0       	ldi	r26, 0x00	; 0
    1fb0:	b1 e0       	ldi	r27, 0x01	; 1
    1fb2:	ec e3       	ldi	r30, 0x3C	; 60
    1fb4:	fc e6       	ldi	r31, 0x6C	; 108
    1fb6:	02 c0       	rjmp	.+4      	; 0x1fbc <.do_copy_data_start>

00001fb8 <.do_copy_data_loop>:
    1fb8:	05 90       	lpm	r0, Z+
    1fba:	0d 92       	st	X+, r0

00001fbc <.do_copy_data_start>:
    1fbc:	a2 3a       	cpi	r26, 0xA2	; 162
    1fbe:	b1 07       	cpc	r27, r17
    1fc0:	d9 f7       	brne	.-10     	; 0x1fb8 <.do_copy_data_loop>

00001fc2 <__do_clear_bss>:
    1fc2:	1b e0       	ldi	r17, 0x0B	; 11
    1fc4:	a2 ea       	ldi	r26, 0xA2	; 162
    1fc6:	b3 e0       	ldi	r27, 0x03	; 3
    1fc8:	01 c0       	rjmp	.+2      	; 0x1fcc <.do_clear_bss_start>

00001fca <.do_clear_bss_loop>:
    1fca:	1d 92       	st	X+, r1

00001fcc <.do_clear_bss_start>:
    1fcc:	a4 3e       	cpi	r26, 0xE4	; 228
    1fce:	b1 07       	cpc	r27, r17
    1fd0:	e1 f7       	brne	.-8      	; 0x1fca <.do_clear_bss_loop>
    1fd2:	0e 94 24 14 	call	0x2848	; 0x2848 <main>
    1fd6:	0c 94 1c 36 	jmp	0x6c38	; 0x6c38 <_exit>

00001fda <__bad_interrupt>:
    1fda:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001fde <__vector_16>:
static char time;
//static char CP2200_status=0;
clock_time_t  sec_counter;

ISR(TIMER0_COMPA_vect)
{
    1fde:	1f 92       	push	r1
    1fe0:	0f 92       	push	r0
    1fe2:	0f b6       	in	r0, 0x3f	; 63
    1fe4:	0f 92       	push	r0
    1fe6:	11 24       	eor	r1, r1
    1fe8:	8f 93       	push	r24
    1fea:	9f 93       	push	r25
	if (--time == 0)
    1fec:	80 91 a3 03 	lds	r24, 0x03A3
    1ff0:	81 50       	subi	r24, 0x01	; 1
    1ff2:	80 93 a3 03 	sts	0x03A3, r24
    1ff6:	88 23       	and	r24, r24
    1ff8:	c1 f4       	brne	.+48     	; 0x202a <__vector_16+0x4c>
	{
		// 1 Sekunden Timer
		time=75;
    1ffa:	8b e4       	ldi	r24, 0x4B	; 75
    1ffc:	80 93 a3 03 	sts	0x03A3, r24
		sec_counter++;
    2000:	80 91 5b 04 	lds	r24, 0x045B
    2004:	90 91 5c 04 	lds	r25, 0x045C
    2008:	01 96       	adiw	r24, 0x01	; 1
    200a:	90 93 5c 04 	sts	0x045C, r25
    200e:	80 93 5b 04 	sts	0x045B, r24
		if (toggle==0)
    2012:	80 91 a2 03 	lds	r24, 0x03A2
    2016:	88 23       	and	r24, r24
    2018:	29 f4       	brne	.+10     	; 0x2024 <__vector_16+0x46>
		{
			PORTC &= ~(1<<PC1); // clear PC1 = LED ON
    201a:	41 98       	cbi	0x08, 1	; 8
			toggle=1;
    201c:	81 e0       	ldi	r24, 0x01	; 1
    201e:	80 93 a2 03 	sts	0x03A2, r24
    2022:	03 c0       	rjmp	.+6      	; 0x202a <__vector_16+0x4c>
		}
		else
		{
			PORTC |= (1<<PC1); // set PC1 = LED OFF
    2024:	41 9a       	sbi	0x08, 1	; 8
			toggle=0;	
    2026:	10 92 a2 03 	sts	0x03A2, r1
		}
	}
}
    202a:	9f 91       	pop	r25
    202c:	8f 91       	pop	r24
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63
    2032:	0f 90       	pop	r0
    2034:	1f 90       	pop	r1
    2036:	18 95       	reti

00002038 <__vector_2>:



ISR(INT1_vect)
{
    2038:	1f 92       	push	r1
    203a:	0f 92       	push	r0
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	0f 92       	push	r0
    2040:	11 24       	eor	r1, r1
	PORTB &= ~(1<<PB0); // clear PB0 = LED ON
    2042:	28 98       	cbi	0x05, 0	; 5
}
    2044:	0f 90       	pop	r0
    2046:	0f be       	out	0x3f, r0	; 63
    2048:	0f 90       	pop	r0
    204a:	1f 90       	pop	r1
    204c:	18 95       	reti

0000204e <InitUART>:


void InitUART(void)
{
    204e:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0H = 0;
	UBRR0L = 64;
    2052:	80 e4       	ldi	r24, 0x40	; 64
    2054:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0) | (1<<TXEN0); // transmit & receive enable 
    2058:	88 e1       	ldi	r24, 0x18	; 24
    205a:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = 0x06; // init RS232: 8,N,1
    205e:	86 e0       	ldi	r24, 0x06	; 6
    2060:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0A = 0x00; 
    2064:	10 92 c0 00 	sts	0x00C0, r1
}
    2068:	08 95       	ret

0000206a <uart_putc_P>:
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    206a:	fc 01       	movw	r30, r24
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    206c:	80 91 c0 00 	lds	r24, 0x00C0
    2070:	85 ff       	sbrs	r24, 5
    2072:	fc cf       	rjmp	.-8      	; 0x206c <uart_putc_P+0x2>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2074:	84 91       	lpm	r24, Z+
    2076:	80 93 c6 00 	sts	0x00C6, r24
    return 0;
}
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	08 95       	ret

00002080 <uart_putc>:

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
    2080:	98 2f       	mov	r25, r24
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2082:	80 91 c0 00 	lds	r24, 0x00C0
    2086:	85 ff       	sbrs	r24, 5
    2088:	fc cf       	rjmp	.-8      	; 0x2082 <uart_putc+0x2>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    208a:	90 93 c6 00 	sts	0x00C6, r25
    return 0;
}
    208e:	80 e0       	ldi	r24, 0x00	; 0
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	08 95       	ret

00002094 <uart_puts>:
 
void uart_puts (char *s)
{
    2094:	fc 01       	movw	r30, r24
    2096:	07 c0       	rjmp	.+14     	; 0x20a6 <uart_puts+0x12>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2098:	80 91 c0 00 	lds	r24, 0x00C0
    209c:	85 ff       	sbrs	r24, 5
    209e:	fc cf       	rjmp	.-8      	; 0x2098 <uart_puts+0x4>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    20a0:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    20a4:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    20a6:	90 81       	ld	r25, Z
    20a8:	99 23       	and	r25, r25
    20aa:	b1 f7       	brne	.-20     	; 0x2098 <uart_puts+0x4>
    {   
        uart_putc(*s);
        s++;
    }
} 
    20ac:	08 95       	ret

000020ae <uart_puts_P>:

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    20ae:	fc 01       	movw	r30, r24
    20b0:	08 c0       	rjmp	.+16     	; 0x20c2 <uart_puts_P+0x14>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    20b2:	80 91 c0 00 	lds	r24, 0x00C0
    20b6:	85 ff       	sbrs	r24, 5
    20b8:	fc cf       	rjmp	.-8      	; 0x20b2 <uart_puts_P+0x4>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    20ba:	84 91       	lpm	r24, Z+
    20bc:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    20c0:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    20c2:	84 91       	lpm	r24, Z+
    20c4:	88 23       	and	r24, r24
    20c6:	a9 f7       	brne	.-22     	; 0x20b2 <uart_puts_P+0x4>
    {   
        uart_putc_P(s);
        s++;
    }
} 
    20c8:	08 95       	ret

000020ca <uart_getc>:

char uart_getc(void)
{
    20ca:	80 91 c0 00 	lds	r24, 0x00C0
    20ce:	87 ff       	sbrs	r24, 7
    20d0:	fc cf       	rjmp	.-8      	; 0x20ca <uart_getc>
  while (!(UCSR0A & (1<<RXC0)));  // warten bis Zeichen verfuegbar
    return UDR0;                   // Zeichen aus UDR an Aufrufer zurueckgeben
    20d2:	80 91 c6 00 	lds	r24, 0x00C6
}
    20d6:	08 95       	ret

000020d8 <itohex>:



// itohex( hexstring, dezimalwert, anzahl der Stellen
void itohex(char *hexstr, int dez, char length)
{
    20d8:	dc 01       	movw	r26, r24
	char i=0;
	char tmp=0;
	if (length > 3)
    20da:	44 30       	cpi	r20, 0x04	; 4
    20dc:	10 f4       	brcc	.+4      	; 0x20e2 <itohex+0xa>
    20de:	20 e0       	ldi	r18, 0x00	; 0
    20e0:	0a c0       	rjmp	.+20     	; 0x20f6 <itohex+0x1e>
	{
		tmp=(dez & 0xF000) >> 12;
    20e2:	87 2f       	mov	r24, r23
    20e4:	82 95       	swap	r24
    20e6:	8f 70       	andi	r24, 0x0F	; 15
		if (tmp > 9)
    20e8:	8a 30       	cpi	r24, 0x0A	; 10
    20ea:	10 f0       	brcs	.+4      	; 0x20f0 <itohex+0x18>
			hexstr[(int)i] = tmp + 'A' - 10;
    20ec:	89 5c       	subi	r24, 0xC9	; 201
    20ee:	01 c0       	rjmp	.+2      	; 0x20f2 <itohex+0x1a>
		else
			hexstr[(int)i] = tmp + '0';
    20f0:	80 5d       	subi	r24, 0xD0	; 208
    20f2:	8c 93       	st	X, r24
    20f4:	21 e0       	ldi	r18, 0x01	; 1
		i++;
	}
	if (length > 2)
    20f6:	43 30       	cpi	r20, 0x03	; 3
    20f8:	78 f0       	brcs	.+30     	; 0x2118 <itohex+0x40>
	{
		tmp=(dez & 0x0F00) >> 8;
    20fa:	87 2f       	mov	r24, r23
    20fc:	8f 70       	andi	r24, 0x0F	; 15
    20fe:	e2 2f       	mov	r30, r18
    2100:	f0 e0       	ldi	r31, 0x00	; 0
		if (tmp > 9)
    2102:	8a 30       	cpi	r24, 0x0A	; 10
    2104:	20 f0       	brcs	.+8      	; 0x210e <itohex+0x36>
			hexstr[(int)i] = tmp + 'A' - 10;
    2106:	ea 0f       	add	r30, r26
    2108:	fb 1f       	adc	r31, r27
    210a:	89 5c       	subi	r24, 0xC9	; 201
    210c:	03 c0       	rjmp	.+6      	; 0x2114 <itohex+0x3c>
		else
			hexstr[(int)i] = tmp + '0';
    210e:	ea 0f       	add	r30, r26
    2110:	fb 1f       	adc	r31, r27
    2112:	80 5d       	subi	r24, 0xD0	; 208
    2114:	80 83       	st	Z, r24
		i++;
    2116:	2f 5f       	subi	r18, 0xFF	; 255
	}
	if (length > 1)
    2118:	42 30       	cpi	r20, 0x02	; 2
    211a:	a8 f0       	brcs	.+42     	; 0x2146 <itohex+0x6e>
	{
		tmp=(dez & 0x00F0) >> 4;
    211c:	cb 01       	movw	r24, r22
    211e:	80 7f       	andi	r24, 0xF0	; 240
    2120:	90 70       	andi	r25, 0x00	; 0
    2122:	34 e0       	ldi	r19, 0x04	; 4
    2124:	95 95       	asr	r25
    2126:	87 95       	ror	r24
    2128:	3a 95       	dec	r19
    212a:	e1 f7       	brne	.-8      	; 0x2124 <itohex+0x4c>
    212c:	e2 2f       	mov	r30, r18
    212e:	f0 e0       	ldi	r31, 0x00	; 0
		if (tmp > 9)
    2130:	8a 30       	cpi	r24, 0x0A	; 10
    2132:	20 f0       	brcs	.+8      	; 0x213c <itohex+0x64>
			hexstr[(int)i] = tmp + 'A' - 10;		
    2134:	ea 0f       	add	r30, r26
    2136:	fb 1f       	adc	r31, r27
    2138:	89 5c       	subi	r24, 0xC9	; 201
    213a:	03 c0       	rjmp	.+6      	; 0x2142 <itohex+0x6a>
		else
			hexstr[(int)i] = tmp + '0';
    213c:	ea 0f       	add	r30, r26
    213e:	fb 1f       	adc	r31, r27
    2140:	80 5d       	subi	r24, 0xD0	; 208
    2142:	80 83       	st	Z, r24
			
		i++;
    2144:	2f 5f       	subi	r18, 0xFF	; 255
	}
	if (length > 0)
    2146:	44 23       	and	r20, r20
    2148:	71 f0       	breq	.+28     	; 0x2166 <itohex+0x8e>
	{
		tmp=dez & 0x000F;
    214a:	6f 70       	andi	r22, 0x0F	; 15
    214c:	e2 2f       	mov	r30, r18
    214e:	f0 e0       	ldi	r31, 0x00	; 0
		if (tmp > 9)
    2150:	6a 30       	cpi	r22, 0x0A	; 10
    2152:	20 f0       	brcs	.+8      	; 0x215c <itohex+0x84>
			hexstr[(int)i] = tmp + 'A' - 10;			
    2154:	ea 0f       	add	r30, r26
    2156:	fb 1f       	adc	r31, r27
    2158:	69 5c       	subi	r22, 0xC9	; 201
    215a:	03 c0       	rjmp	.+6      	; 0x2162 <itohex+0x8a>
		else
			hexstr[(int)i] = tmp + '0';
    215c:	ea 0f       	add	r30, r26
    215e:	fb 1f       	adc	r31, r27
    2160:	60 5d       	subi	r22, 0xD0	; 208
    2162:	60 83       	st	Z, r22
		i++;
    2164:	2f 5f       	subi	r18, 0xFF	; 255
	} 
	hexstr[(int)i]=0;
    2166:	a2 0f       	add	r26, r18
    2168:	b1 1d       	adc	r27, r1
    216a:	1c 92       	st	X, r1
}
    216c:	08 95       	ret

0000216e <clock_init>:
  return(dez);
}
*/

void clock_init(void)
{
    216e:	f8 94       	cli
	cli();
	// Timer0 init
	TCCR0A = 0x02;
    2170:	82 e0       	ldi	r24, 0x02	; 2
    2172:	84 bd       	out	0x24, r24	; 36
	TCCR0B = 0x05;
    2174:	95 e0       	ldi	r25, 0x05	; 5
    2176:	95 bd       	out	0x25, r25	; 37
	OCR0A = 0x80; // compare value
    2178:	90 e8       	ldi	r25, 0x80	; 128
    217a:	97 bd       	out	0x27, r25	; 39
	TIMSK0 = 0x02;
    217c:	80 93 6e 00 	sts	0x006E, r24
	sei();
    2180:	78 94       	sei
}
    2182:	08 95       	ret

00002184 <clock_time>:
	
clock_time_t clock_time(void)
{
    2184:	80 91 5b 04 	lds	r24, 0x045B
    2188:	90 91 5c 04 	lds	r25, 0x045C
    218c:	08 95       	ret

0000218e <uip_log>:
	return(sec_counter);
}

void uip_log(char *text)
{
    218e:	fc 01       	movw	r30, r24
    2190:	07 c0       	rjmp	.+14     	; 0x21a0 <uip_log+0x12>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2192:	80 91 c0 00 	lds	r24, 0x00C0
    2196:	85 ff       	sbrs	r24, 5
    2198:	fc cf       	rjmp	.-8      	; 0x2192 <uip_log+0x4>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    219a:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    219e:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    21a0:	90 81       	ld	r25, Z
    21a2:	99 23       	and	r25, r25
    21a4:	b1 f7       	brne	.-20     	; 0x2192 <uip_log+0x4>
}

void uip_log(char *text)
{
	uart_puts(text);
}
    21a6:	08 95       	ret

000021a8 <cmd_help>:
		uip_setnetmask(ipaddr);			
	}
} // cmd_netmask

void cmd_help(void)
{
    21a8:	e6 e2       	ldi	r30, 0x26	; 38
    21aa:	f2 e0       	ldi	r31, 0x02	; 2
    21ac:	08 c0       	rjmp	.+16     	; 0x21be <cmd_help+0x16>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    21ae:	80 91 c0 00 	lds	r24, 0x00C0
    21b2:	85 ff       	sbrs	r24, 5
    21b4:	fc cf       	rjmp	.-8      	; 0x21ae <cmd_help+0x6>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    21b6:	84 91       	lpm	r24, Z+
    21b8:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    21bc:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    21be:	84 91       	lpm	r24, Z+
    21c0:	88 23       	and	r24, r24
    21c2:	a9 f7       	brne	.-22     	; 0x21ae <cmd_help+0x6>
} // cmd_netmask

void cmd_help(void)
{
	uart_puts_P(PSTR("\r\nAdam Dunkels uIP webserver example for Crumb644-NET\r\n"));
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
    21c4:	ec ee       	ldi	r30, 0xEC	; 236
    21c6:	f1 e0       	ldi	r31, 0x01	; 1
    21c8:	08 c0       	rjmp	.+16     	; 0x21da <cmd_help+0x32>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    21ca:	80 91 c0 00 	lds	r24, 0x00C0
    21ce:	85 ff       	sbrs	r24, 5
    21d0:	fc cf       	rjmp	.-8      	; 0x21ca <cmd_help+0x22>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    21d2:	84 91       	lpm	r24, Z+
    21d4:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    21d8:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    21da:	84 91       	lpm	r24, Z+
    21dc:	88 23       	and	r24, r24
    21de:	a9 f7       	brne	.-22     	; 0x21ca <cmd_help+0x22>

void cmd_help(void)
{
	uart_puts_P(PSTR("\r\nAdam Dunkels uIP webserver example for Crumb644-NET\r\n"));
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
    21e0:	ee ec       	ldi	r30, 0xCE	; 206
    21e2:	f1 e0       	ldi	r31, 0x01	; 1
    21e4:	08 c0       	rjmp	.+16     	; 0x21f6 <cmd_help+0x4e>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    21e6:	80 91 c0 00 	lds	r24, 0x00C0
    21ea:	85 ff       	sbrs	r24, 5
    21ec:	fc cf       	rjmp	.-8      	; 0x21e6 <cmd_help+0x3e>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    21ee:	84 91       	lpm	r24, Z+
    21f0:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    21f4:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    21f6:	84 91       	lpm	r24, Z+
    21f8:	88 23       	and	r24, r24
    21fa:	a9 f7       	brne	.-22     	; 0x21e6 <cmd_help+0x3e>
void cmd_help(void)
{
	uart_puts_P(PSTR("\r\nAdam Dunkels uIP webserver example for Crumb644-NET\r\n"));
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
    21fc:	eb ea       	ldi	r30, 0xAB	; 171
    21fe:	f1 e0       	ldi	r31, 0x01	; 1
    2200:	08 c0       	rjmp	.+16     	; 0x2212 <cmd_help+0x6a>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2202:	80 91 c0 00 	lds	r24, 0x00C0
    2206:	85 ff       	sbrs	r24, 5
    2208:	fc cf       	rjmp	.-8      	; 0x2202 <cmd_help+0x5a>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    220a:	84 91       	lpm	r24, Z+
    220c:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2210:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2212:	84 91       	lpm	r24, Z+
    2214:	88 23       	and	r24, r24
    2216:	a9 f7       	brne	.-22     	; 0x2202 <cmd_help+0x5a>
{
	uart_puts_P(PSTR("\r\nAdam Dunkels uIP webserver example for Crumb644-NET\r\n"));
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
    2218:	e0 e9       	ldi	r30, 0x90	; 144
    221a:	f1 e0       	ldi	r31, 0x01	; 1
    221c:	08 c0       	rjmp	.+16     	; 0x222e <cmd_help+0x86>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    221e:	80 91 c0 00 	lds	r24, 0x00C0
    2222:	85 ff       	sbrs	r24, 5
    2224:	fc cf       	rjmp	.-8      	; 0x221e <cmd_help+0x76>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2226:	84 91       	lpm	r24, Z+
    2228:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    222c:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    222e:	84 91       	lpm	r24, Z+
    2230:	88 23       	and	r24, r24
    2232:	a9 f7       	brne	.-22     	; 0x221e <cmd_help+0x76>
	uart_puts_P(PSTR("\r\nAdam Dunkels uIP webserver example for Crumb644-NET\r\n"));
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
	uart_puts_P(PSTR(" Commands: \r\n"));
    2234:	e2 e8       	ldi	r30, 0x82	; 130
    2236:	f1 e0       	ldi	r31, 0x01	; 1
    2238:	08 c0       	rjmp	.+16     	; 0x224a <cmd_help+0xa2>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    223a:	80 91 c0 00 	lds	r24, 0x00C0
    223e:	85 ff       	sbrs	r24, 5
    2240:	fc cf       	rjmp	.-8      	; 0x223a <cmd_help+0x92>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2242:	84 91       	lpm	r24, Z+
    2244:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2248:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    224a:	84 91       	lpm	r24, Z+
    224c:	88 23       	and	r24, r24
    224e:	a9 f7       	brne	.-22     	; 0x223a <cmd_help+0x92>
	uart_puts_P(PSTR(" *** version 1. adapted by S.Perzborn [23.01.2009] *** \r\n"));
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
	uart_puts_P(PSTR(" Commands: \r\n"));
	uart_puts_P(PSTR("  CPRESET                     // reinitialize ethernet controller \r\n"));
    2250:	ed e3       	ldi	r30, 0x3D	; 61
    2252:	f1 e0       	ldi	r31, 0x01	; 1
    2254:	08 c0       	rjmp	.+16     	; 0x2266 <cmd_help+0xbe>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2256:	80 91 c0 00 	lds	r24, 0x00C0
    225a:	85 ff       	sbrs	r24, 5
    225c:	fc cf       	rjmp	.-8      	; 0x2256 <cmd_help+0xae>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    225e:	84 91       	lpm	r24, Z+
    2260:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2264:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2266:	84 91       	lpm	r24, Z+
    2268:	88 23       	and	r24, r24
    226a:	a9 f7       	brne	.-22     	; 0x2256 <cmd_help+0xae>
	uart_puts_P(PSTR(" *** web: www.perzborn.net \r\n"));
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
	uart_puts_P(PSTR(" Commands: \r\n"));
	uart_puts_P(PSTR("  CPRESET                     // reinitialize ethernet controller \r\n"));
	uart_puts_P(PSTR("  IP <xxx.xxx.xxx.xxx>        // display / set IP address\r\n"));
    226c:	e1 e0       	ldi	r30, 0x01	; 1
    226e:	f1 e0       	ldi	r31, 0x01	; 1
    2270:	08 c0       	rjmp	.+16     	; 0x2282 <cmd_help+0xda>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2272:	80 91 c0 00 	lds	r24, 0x00C0
    2276:	85 ff       	sbrs	r24, 5
    2278:	fc cf       	rjmp	.-8      	; 0x2272 <cmd_help+0xca>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    227a:	84 91       	lpm	r24, Z+
    227c:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2280:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2282:	84 91       	lpm	r24, Z+
    2284:	88 23       	and	r24, r24
    2286:	a9 f7       	brne	.-22     	; 0x2272 <cmd_help+0xca>
	uart_puts_P(PSTR(" *** email: stefan@perzborn.net \r\n"));
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
	uart_puts_P(PSTR(" Commands: \r\n"));
	uart_puts_P(PSTR("  CPRESET                     // reinitialize ethernet controller \r\n"));
	uart_puts_P(PSTR("  IP <xxx.xxx.xxx.xxx>        // display / set IP address\r\n"));
	uart_puts_P(PSTR("  NETMASK <xxx.xxx.xxx.xxx>   // display / set netmask\r\n"));
    2288:	e8 ec       	ldi	r30, 0xC8	; 200
    228a:	f0 e0       	ldi	r31, 0x00	; 0
    228c:	08 c0       	rjmp	.+16     	; 0x229e <cmd_help+0xf6>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    228e:	80 91 c0 00 	lds	r24, 0x00C0
    2292:	85 ff       	sbrs	r24, 5
    2294:	fc cf       	rjmp	.-8      	; 0x228e <cmd_help+0xe6>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2296:	84 91       	lpm	r24, Z+
    2298:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    229c:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    229e:	84 91       	lpm	r24, Z+
    22a0:	88 23       	and	r24, r24
    22a2:	a9 f7       	brne	.-22     	; 0x228e <cmd_help+0xe6>
	uart_puts_P(PSTR(" serial: 19200 baud 8N1 \r\n"));
	uart_puts_P(PSTR(" Commands: \r\n"));
	uart_puts_P(PSTR("  CPRESET                     // reinitialize ethernet controller \r\n"));
	uart_puts_P(PSTR("  IP <xxx.xxx.xxx.xxx>        // display / set IP address\r\n"));
	uart_puts_P(PSTR("  NETMASK <xxx.xxx.xxx.xxx>   // display / set netmask\r\n"));
	uart_puts_P(PSTR("  \r\n"));
    22a4:	e3 ec       	ldi	r30, 0xC3	; 195
    22a6:	f0 e0       	ldi	r31, 0x00	; 0
    22a8:	08 c0       	rjmp	.+16     	; 0x22ba <cmd_help+0x112>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    22aa:	80 91 c0 00 	lds	r24, 0x00C0
    22ae:	85 ff       	sbrs	r24, 5
    22b0:	fc cf       	rjmp	.-8      	; 0x22aa <cmd_help+0x102>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    22b2:	84 91       	lpm	r24, Z+
    22b4:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    22b8:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    22ba:	84 91       	lpm	r24, Z+
    22bc:	88 23       	and	r24, r24
    22be:	a9 f7       	brne	.-22     	; 0x22aa <cmd_help+0x102>
    22c0:	84 ef       	ldi	r24, 0xF4	; 244
    22c2:	91 e0       	ldi	r25, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    22c4:	28 e8       	ldi	r18, 0x88	; 136
    22c6:	33 e1       	ldi	r19, 0x13	; 19
    22c8:	f9 01       	movw	r30, r18
    22ca:	31 97       	sbiw	r30, 0x01	; 1
    22cc:	f1 f7       	brne	.-4      	; 0x22ca <cmd_help+0x122>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22ce:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    22d0:	d9 f7       	brne	.-10     	; 0x22c8 <cmd_help+0x120>
	uart_puts_P(PSTR("  CPRESET                     // reinitialize ethernet controller \r\n"));
	uart_puts_P(PSTR("  IP <xxx.xxx.xxx.xxx>        // display / set IP address\r\n"));
	uart_puts_P(PSTR("  NETMASK <xxx.xxx.xxx.xxx>   // display / set netmask\r\n"));
	uart_puts_P(PSTR("  \r\n"));
	_delay_ms(50);
}
    22d2:	08 95       	ret

000022d4 <cmd_netmask>:
		uip_sethostaddr(ipaddr);			
	}
} // cmd_ip

void cmd_netmask(char *ipstr)
{
    22d4:	cf 92       	push	r12
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	0f 93       	push	r16
    22de:	1f 93       	push	r17
    22e0:	df 93       	push	r29
    22e2:	cf 93       	push	r28
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
    22e8:	2e 97       	sbiw	r28, 0x0e	; 14
    22ea:	0f b6       	in	r0, 0x3f	; 63
    22ec:	f8 94       	cli
    22ee:	de bf       	out	0x3e, r29	; 62
    22f0:	0f be       	out	0x3f, r0	; 63
    22f2:	cd bf       	out	0x3d, r28	; 61
    22f4:	8c 01       	movw	r16, r24
	char *tmp=0;
	unsigned char i=0;
	uip_ipaddr_t ipaddr;
	//struct uip_eth_addr eaddr;
	i=0;
	uip_getnetmask(&ipaddr);
    22f6:	80 91 f8 05 	lds	r24, 0x05F8
    22fa:	90 91 f9 05 	lds	r25, 0x05F9
    22fe:	9a 83       	std	Y+2, r25	; 0x02
    2300:	89 83       	std	Y+1, r24	; 0x01
    2302:	80 91 fa 05 	lds	r24, 0x05FA
    2306:	90 91 fb 05 	lds	r25, 0x05FB
    230a:	9c 83       	std	Y+4, r25	; 0x04
    230c:	8b 83       	std	Y+3, r24	; 0x03
	ip = (char *) &ipaddr;
    230e:	6e 01       	movw	r12, r28
    2310:	08 94       	sec
    2312:	c1 1c       	adc	r12, r1
    2314:	d1 1c       	adc	r13, r1
	
	if (*ipstr == 0)
    2316:	f8 01       	movw	r30, r16
    2318:	80 81       	ld	r24, Z
    231a:	88 23       	and	r24, r24
    231c:	19 f0       	breq	.+6      	; 0x2324 <cmd_netmask+0x50>
    231e:	c8 01       	movw	r24, r16
    2320:	ff 24       	eor	r15, r15
    2322:	68 c0       	rjmp	.+208    	; 0x23f4 <cmd_netmask+0x120>
	{
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
    2324:	4a e0       	ldi	r20, 0x0A	; 10
    2326:	50 e0       	ldi	r21, 0x00	; 0
    2328:	be 01       	movw	r22, r28
    232a:	6b 5f       	subi	r22, 0xFB	; 251
    232c:	7f 4f       	sbci	r23, 0xFF	; 255
    232e:	89 81       	ldd	r24, Y+1	; 0x01
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <itoa>
    2336:	fc 01       	movw	r30, r24
    2338:	07 c0       	rjmp	.+14     	; 0x2348 <cmd_netmask+0x74>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    233a:	80 91 c0 00 	lds	r24, 0x00C0
    233e:	85 ff       	sbrs	r24, 5
    2340:	fc cf       	rjmp	.-8      	; 0x233a <cmd_netmask+0x66>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2342:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    2346:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    2348:	90 81       	ld	r25, Z
    234a:	99 23       	and	r25, r25
    234c:	b1 f7       	brne	.-20     	; 0x233a <cmd_netmask+0x66>
    234e:	8e 01       	movw	r16, r28
    2350:	0f 5f       	subi	r16, 0xFF	; 255
    2352:	1f 4f       	sbci	r17, 0xFF	; 255
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa(ip[i],tmpstr,10));
    2354:	55 e0       	ldi	r21, 0x05	; 5
    2356:	e5 2e       	mov	r14, r21
    2358:	f1 2c       	mov	r15, r1
    235a:	ec 0e       	add	r14, r28
    235c:	fd 1e       	adc	r15, r29
	if (*ipstr == 0)
	{
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    235e:	44 e0       	ldi	r20, 0x04	; 4
    2360:	c4 2e       	mov	r12, r20
    2362:	d1 2c       	mov	r13, r1
    2364:	cc 0e       	add	r12, r28
    2366:	dd 1e       	adc	r13, r29
    2368:	27 c0       	rjmp	.+78     	; 0x23b8 <cmd_netmask+0xe4>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    236a:	80 91 c0 00 	lds	r24, 0x00C0
    236e:	85 ff       	sbrs	r24, 5
    2370:	fc cf       	rjmp	.-8      	; 0x236a <cmd_netmask+0x96>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2372:	84 91       	lpm	r24, Z+
    2374:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2378:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    237a:	84 91       	lpm	r24, Z+
    237c:	88 23       	and	r24, r24
    237e:	a9 f7       	brne	.-22     	; 0x236a <cmd_netmask+0x96>
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa(ip[i],tmpstr,10));
    2380:	4a e0       	ldi	r20, 0x0A	; 10
    2382:	50 e0       	ldi	r21, 0x00	; 0
    2384:	b7 01       	movw	r22, r14
    2386:	f8 01       	movw	r30, r16
    2388:	81 81       	ldd	r24, Z+1	; 0x01
    238a:	90 e0       	ldi	r25, 0x00	; 0
    238c:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <itoa>
    2390:	fc 01       	movw	r30, r24
    2392:	07 c0       	rjmp	.+14     	; 0x23a2 <cmd_netmask+0xce>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2394:	80 91 c0 00 	lds	r24, 0x00C0
    2398:	85 ff       	sbrs	r24, 5
    239a:	fc cf       	rjmp	.-8      	; 0x2394 <cmd_netmask+0xc0>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    239c:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    23a0:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    23a2:	90 81       	ld	r25, Z
    23a4:	99 23       	and	r25, r25
    23a6:	b1 f7       	brne	.-20     	; 0x2394 <cmd_netmask+0xc0>
    23a8:	0f 5f       	subi	r16, 0xFF	; 255
    23aa:	1f 4f       	sbci	r17, 0xFF	; 255
	if (*ipstr == 0)
	{
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    23ac:	0c 15       	cp	r16, r12
    23ae:	1d 05       	cpc	r17, r13
    23b0:	19 f4       	brne	.+6      	; 0x23b8 <cmd_netmask+0xe4>
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa(ip[i],tmpstr,10));
		}
		uart_puts_P(PSTR("\r\n"));
    23b2:	ee e5       	ldi	r30, 0x5E	; 94
    23b4:	f2 e0       	ldi	r31, 0x02	; 2
    23b6:	0b c0       	rjmp	.+22     	; 0x23ce <cmd_netmask+0xfa>
		// show netmask
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
    23b8:	e1 e6       	ldi	r30, 0x61	; 97
    23ba:	f2 e0       	ldi	r31, 0x02	; 2
    23bc:	de cf       	rjmp	.-68     	; 0x237a <cmd_netmask+0xa6>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    23be:	80 91 c0 00 	lds	r24, 0x00C0
    23c2:	85 ff       	sbrs	r24, 5
    23c4:	fc cf       	rjmp	.-8      	; 0x23be <cmd_netmask+0xea>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    23c6:	84 91       	lpm	r24, Z+
    23c8:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    23cc:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    23ce:	84 91       	lpm	r24, Z+
    23d0:	88 23       	and	r24, r24
    23d2:	a9 f7       	brne	.-22     	; 0x23be <cmd_netmask+0xea>
    23d4:	33 c0       	rjmp	.+102    	; 0x243c <cmd_netmask+0x168>
		// set netmask
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
		{
			if (*ipstr=='.') 
    23d6:	2e 32       	cpi	r18, 0x2E	; 46
    23d8:	59 f4       	brne	.+22     	; 0x23f0 <cmd_netmask+0x11c>
			{	
				*ipstr=0;
    23da:	f8 01       	movw	r30, r16
    23dc:	10 82       	st	Z, r1
				ip[i++]=atoi(tmp);
    23de:	0e 94 34 32 	call	0x6468	; 0x6468 <atoi>
    23e2:	f6 01       	movw	r30, r12
    23e4:	ef 0d       	add	r30, r15
    23e6:	f1 1d       	adc	r31, r1
    23e8:	80 83       	st	Z, r24
    23ea:	f3 94       	inc	r15
    23ec:	c8 01       	movw	r24, r16
    23ee:	01 96       	adiw	r24, 0x01	; 1
	else
	{
		// set netmask
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
    23f0:	0f 5f       	subi	r16, 0xFF	; 255
    23f2:	1f 4f       	sbci	r17, 0xFF	; 255
    23f4:	f8 01       	movw	r30, r16
    23f6:	20 81       	ld	r18, Z
    23f8:	22 23       	and	r18, r18
    23fa:	19 f0       	breq	.+6      	; 0x2402 <cmd_netmask+0x12e>
    23fc:	f3 e0       	ldi	r31, 0x03	; 3
    23fe:	ff 15       	cp	r31, r15
    2400:	50 f7       	brcc	.-44     	; 0x23d6 <cmd_netmask+0x102>
				*ipstr=0;
				ip[i++]=atoi(tmp);
				tmp = ipstr + 1;
			}
		}
		*ipstr=0;
    2402:	f8 01       	movw	r30, r16
    2404:	10 82       	st	Z, r1
		ip[i]=atoi(tmp);
    2406:	0e 94 34 32 	call	0x6468	; 0x6468 <atoi>
    240a:	f6 01       	movw	r30, r12
    240c:	ef 0d       	add	r30, r15
    240e:	f1 1d       	adc	r31, r1
    2410:	80 83       	st	Z, r24
		uip_ipaddr(ipaddr, ip[0],ip[1],ip[2],ip[3]);
    2412:	f6 01       	movw	r30, r12
    2414:	92 81       	ldd	r25, Z+2	; 0x02
    2416:	80 e0       	ldi	r24, 0x00	; 0
    2418:	43 81       	ldd	r20, Z+3	; 0x03
    241a:	50 e0       	ldi	r21, 0x00	; 0
    241c:	48 2b       	or	r20, r24
    241e:	59 2b       	or	r21, r25
		uip_setnetmask(ipaddr);			
    2420:	21 81       	ldd	r18, Z+1	; 0x01
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	90 81       	ld	r25, Z
    2426:	80 e0       	ldi	r24, 0x00	; 0
    2428:	28 2b       	or	r18, r24
    242a:	39 2b       	or	r19, r25
    242c:	30 93 f8 05 	sts	0x05F8, r19
    2430:	20 93 f9 05 	sts	0x05F9, r18
    2434:	50 93 fa 05 	sts	0x05FA, r21
    2438:	40 93 fb 05 	sts	0x05FB, r20
	}
} // cmd_netmask
    243c:	2e 96       	adiw	r28, 0x0e	; 14
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	de bf       	out	0x3e, r29	; 62
    2444:	0f be       	out	0x3f, r0	; 63
    2446:	cd bf       	out	0x3d, r28	; 61
    2448:	cf 91       	pop	r28
    244a:	df 91       	pop	r29
    244c:	1f 91       	pop	r17
    244e:	0f 91       	pop	r16
    2450:	ff 90       	pop	r15
    2452:	ef 90       	pop	r14
    2454:	df 90       	pop	r13
    2456:	cf 90       	pop	r12
    2458:	08 95       	ret

0000245a <cmd_ip>:
	return(i);
}


void cmd_ip(char *ipstr)
{
    245a:	cf 92       	push	r12
    245c:	df 92       	push	r13
    245e:	ef 92       	push	r14
    2460:	ff 92       	push	r15
    2462:	0f 93       	push	r16
    2464:	1f 93       	push	r17
    2466:	df 93       	push	r29
    2468:	cf 93       	push	r28
    246a:	cd b7       	in	r28, 0x3d	; 61
    246c:	de b7       	in	r29, 0x3e	; 62
    246e:	2e 97       	sbiw	r28, 0x0e	; 14
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	de bf       	out	0x3e, r29	; 62
    2476:	0f be       	out	0x3f, r0	; 63
    2478:	cd bf       	out	0x3d, r28	; 61
    247a:	8c 01       	movw	r16, r24
	char *tmp=0;
	unsigned char i=0;
	uip_ipaddr_t ipaddr;
	//		struct uip_eth_addr eaddr;
	i=0;
	uip_gethostaddr(&ipaddr);
    247c:	80 91 fc 05 	lds	r24, 0x05FC
    2480:	90 91 fd 05 	lds	r25, 0x05FD
    2484:	9a 83       	std	Y+2, r25	; 0x02
    2486:	89 83       	std	Y+1, r24	; 0x01
    2488:	80 91 fe 05 	lds	r24, 0x05FE
    248c:	90 91 ff 05 	lds	r25, 0x05FF
    2490:	9c 83       	std	Y+4, r25	; 0x04
    2492:	8b 83       	std	Y+3, r24	; 0x03
	ip = (char *) &ipaddr;
    2494:	6e 01       	movw	r12, r28
    2496:	08 94       	sec
    2498:	c1 1c       	adc	r12, r1
    249a:	d1 1c       	adc	r13, r1

	if (*ipstr == 0)
    249c:	f8 01       	movw	r30, r16
    249e:	80 81       	ld	r24, Z
    24a0:	88 23       	and	r24, r24
    24a2:	19 f0       	breq	.+6      	; 0x24aa <cmd_ip+0x50>
    24a4:	c8 01       	movw	r24, r16
    24a6:	ff 24       	eor	r15, r15
    24a8:	68 c0       	rjmp	.+208    	; 0x257a <cmd_ip+0x120>
	{
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
    24aa:	4a e0       	ldi	r20, 0x0A	; 10
    24ac:	50 e0       	ldi	r21, 0x00	; 0
    24ae:	be 01       	movw	r22, r28
    24b0:	6b 5f       	subi	r22, 0xFB	; 251
    24b2:	7f 4f       	sbci	r23, 0xFF	; 255
    24b4:	89 81       	ldd	r24, Y+1	; 0x01
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <itoa>
    24bc:	fc 01       	movw	r30, r24
    24be:	07 c0       	rjmp	.+14     	; 0x24ce <cmd_ip+0x74>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    24c0:	80 91 c0 00 	lds	r24, 0x00C0
    24c4:	85 ff       	sbrs	r24, 5
    24c6:	fc cf       	rjmp	.-8      	; 0x24c0 <cmd_ip+0x66>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    24c8:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    24cc:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    24ce:	90 81       	ld	r25, Z
    24d0:	99 23       	and	r25, r25
    24d2:	b1 f7       	brne	.-20     	; 0x24c0 <cmd_ip+0x66>
    24d4:	8e 01       	movw	r16, r28
    24d6:	0f 5f       	subi	r16, 0xFF	; 255
    24d8:	1f 4f       	sbci	r17, 0xFF	; 255
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa((unsigned char) ip[i],tmpstr,10));
    24da:	75 e0       	ldi	r23, 0x05	; 5
    24dc:	e7 2e       	mov	r14, r23
    24de:	f1 2c       	mov	r15, r1
    24e0:	ec 0e       	add	r14, r28
    24e2:	fd 1e       	adc	r15, r29
	if (*ipstr == 0)
	{
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    24e4:	64 e0       	ldi	r22, 0x04	; 4
    24e6:	c6 2e       	mov	r12, r22
    24e8:	d1 2c       	mov	r13, r1
    24ea:	cc 0e       	add	r12, r28
    24ec:	dd 1e       	adc	r13, r29
    24ee:	27 c0       	rjmp	.+78     	; 0x253e <cmd_ip+0xe4>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    24f0:	80 91 c0 00 	lds	r24, 0x00C0
    24f4:	85 ff       	sbrs	r24, 5
    24f6:	fc cf       	rjmp	.-8      	; 0x24f0 <cmd_ip+0x96>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    24f8:	84 91       	lpm	r24, Z+
    24fa:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    24fe:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2500:	84 91       	lpm	r24, Z+
    2502:	88 23       	and	r24, r24
    2504:	a9 f7       	brne	.-22     	; 0x24f0 <cmd_ip+0x96>
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa((unsigned char) ip[i],tmpstr,10));
    2506:	4a e0       	ldi	r20, 0x0A	; 10
    2508:	50 e0       	ldi	r21, 0x00	; 0
    250a:	b7 01       	movw	r22, r14
    250c:	f8 01       	movw	r30, r16
    250e:	81 81       	ldd	r24, Z+1	; 0x01
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <itoa>
    2516:	fc 01       	movw	r30, r24
    2518:	07 c0       	rjmp	.+14     	; 0x2528 <cmd_ip+0xce>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    251a:	80 91 c0 00 	lds	r24, 0x00C0
    251e:	85 ff       	sbrs	r24, 5
    2520:	fc cf       	rjmp	.-8      	; 0x251a <cmd_ip+0xc0>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2522:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    2526:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    2528:	90 81       	ld	r25, Z
    252a:	99 23       	and	r25, r25
    252c:	b1 f7       	brne	.-20     	; 0x251a <cmd_ip+0xc0>
    252e:	0f 5f       	subi	r16, 0xFF	; 255
    2530:	1f 4f       	sbci	r17, 0xFF	; 255
	if (*ipstr == 0)
	{
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
    2532:	0c 15       	cp	r16, r12
    2534:	1d 05       	cpc	r17, r13
    2536:	19 f4       	brne	.+6      	; 0x253e <cmd_ip+0xe4>
		{
			uart_puts_P(PSTR("."));
			uart_puts(itoa((unsigned char) ip[i],tmpstr,10));
		}
		uart_puts_P(PSTR("\r\n"));
    2538:	e3 e6       	ldi	r30, 0x63	; 99
    253a:	f2 e0       	ldi	r31, 0x02	; 2
    253c:	0b c0       	rjmp	.+22     	; 0x2554 <cmd_ip+0xfa>
		// show ip address
		uart_puts(itoa(ip[i],tmpstr,10));
		i++;
		for (;i<4;i++)
		{
			uart_puts_P(PSTR("."));
    253e:	e6 e6       	ldi	r30, 0x66	; 102
    2540:	f2 e0       	ldi	r31, 0x02	; 2
    2542:	de cf       	rjmp	.-68     	; 0x2500 <cmd_ip+0xa6>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2544:	80 91 c0 00 	lds	r24, 0x00C0
    2548:	85 ff       	sbrs	r24, 5
    254a:	fc cf       	rjmp	.-8      	; 0x2544 <cmd_ip+0xea>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    254c:	84 91       	lpm	r24, Z+
    254e:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2552:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2554:	84 91       	lpm	r24, Z+
    2556:	88 23       	and	r24, r24
    2558:	a9 f7       	brne	.-22     	; 0x2544 <cmd_ip+0xea>
    255a:	33 c0       	rjmp	.+102    	; 0x25c2 <cmd_ip+0x168>
		// set ip address
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
		{
			if (*ipstr=='.') 
    255c:	2e 32       	cpi	r18, 0x2E	; 46
    255e:	59 f4       	brne	.+22     	; 0x2576 <cmd_ip+0x11c>
			{	
				*ipstr=0;
    2560:	f8 01       	movw	r30, r16
    2562:	10 82       	st	Z, r1
				ip[i++]=atoi(tmp);
    2564:	0e 94 34 32 	call	0x6468	; 0x6468 <atoi>
    2568:	f6 01       	movw	r30, r12
    256a:	ef 0d       	add	r30, r15
    256c:	f1 1d       	adc	r31, r1
    256e:	80 83       	st	Z, r24
    2570:	f3 94       	inc	r15
    2572:	c8 01       	movw	r24, r16
    2574:	01 96       	adiw	r24, 0x01	; 1
	else
	{
		// set ip address
		tmp=ipstr;		
		i=0;
		for (i=0;((*ipstr != 0) && (i<4));ipstr++)
    2576:	0f 5f       	subi	r16, 0xFF	; 255
    2578:	1f 4f       	sbci	r17, 0xFF	; 255
    257a:	f8 01       	movw	r30, r16
    257c:	20 81       	ld	r18, Z
    257e:	22 23       	and	r18, r18
    2580:	19 f0       	breq	.+6      	; 0x2588 <cmd_ip+0x12e>
    2582:	f3 e0       	ldi	r31, 0x03	; 3
    2584:	ff 15       	cp	r31, r15
    2586:	50 f7       	brcc	.-44     	; 0x255c <cmd_ip+0x102>
				*ipstr=0;
				ip[i++]=atoi(tmp);
				tmp = ipstr + 1;
			}
		}
		*ipstr=0;
    2588:	f8 01       	movw	r30, r16
    258a:	10 82       	st	Z, r1
		ip[i]=atoi(tmp);
    258c:	0e 94 34 32 	call	0x6468	; 0x6468 <atoi>
    2590:	f6 01       	movw	r30, r12
    2592:	ef 0d       	add	r30, r15
    2594:	f1 1d       	adc	r31, r1
    2596:	80 83       	st	Z, r24
		uip_ipaddr(ipaddr, ip[0],ip[1],ip[2],ip[3]);
    2598:	f6 01       	movw	r30, r12
    259a:	92 81       	ldd	r25, Z+2	; 0x02
    259c:	80 e0       	ldi	r24, 0x00	; 0
    259e:	43 81       	ldd	r20, Z+3	; 0x03
    25a0:	50 e0       	ldi	r21, 0x00	; 0
    25a2:	48 2b       	or	r20, r24
    25a4:	59 2b       	or	r21, r25
		uip_sethostaddr(ipaddr);			
    25a6:	21 81       	ldd	r18, Z+1	; 0x01
    25a8:	30 e0       	ldi	r19, 0x00	; 0
    25aa:	90 81       	ld	r25, Z
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	28 2b       	or	r18, r24
    25b0:	39 2b       	or	r19, r25
    25b2:	30 93 fc 05 	sts	0x05FC, r19
    25b6:	20 93 fd 05 	sts	0x05FD, r18
    25ba:	50 93 fe 05 	sts	0x05FE, r21
    25be:	40 93 ff 05 	sts	0x05FF, r20
	}
} // cmd_ip
    25c2:	2e 96       	adiw	r28, 0x0e	; 14
    25c4:	0f b6       	in	r0, 0x3f	; 63
    25c6:	f8 94       	cli
    25c8:	de bf       	out	0x3e, r29	; 62
    25ca:	0f be       	out	0x3f, r0	; 63
    25cc:	cd bf       	out	0x3d, r28	; 61
    25ce:	cf 91       	pop	r28
    25d0:	df 91       	pop	r29
    25d2:	1f 91       	pop	r17
    25d4:	0f 91       	pop	r16
    25d6:	ff 90       	pop	r15
    25d8:	ef 90       	pop	r14
    25da:	df 90       	pop	r13
    25dc:	cf 90       	pop	r12
    25de:	08 95       	ret

000025e0 <parse>:
	uart_puts_P(PSTR("  \r\n"));
	_delay_ms(50);
}

void parse(char *zeile)
{
    25e0:	ef 92       	push	r14
    25e2:	ff 92       	push	r15
    25e4:	0f 93       	push	r16
    25e6:	1f 93       	push	r17
    25e8:	df 93       	push	r29
    25ea:	cf 93       	push	r28
    25ec:	cd b7       	in	r28, 0x3d	; 61
    25ee:	de b7       	in	r29, 0x3e	; 62
    25f0:	c0 5a       	subi	r28, 0xA0	; 160
    25f2:	d0 40       	sbci	r29, 0x00	; 0
    25f4:	0f b6       	in	r0, 0x3f	; 63
    25f6:	f8 94       	cli
    25f8:	de bf       	out	0x3e, r29	; 62
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	cd bf       	out	0x3d, r28	; 61
    25fe:	ac 01       	movw	r20, r24
    2600:	de 01       	movw	r26, r28
    2602:	11 96       	adiw	r26, 0x01	; 1
    2604:	90 e0       	ldi	r25, 0x00	; 0
    2606:	ee 24       	eor	r14, r14
    2608:	ff 24       	eor	r15, r15
    260a:	01 c0       	rjmp	.+2      	; 0x260e <parse+0x2e>
	// argc = Anzahl der Teilstrings (1..10) 
	// Bei keiner Eingabe (nur Enter) ist argc = 1
	for(;argc<10;)
	{
		// fhrende Leerzeichen berlesen (oder Ende)
		for(;((*(zeile+i) <=' ')&&(*(zeile+i) !=0));i++);
    260c:	9f 5f       	subi	r25, 0xFF	; 255
    260e:	fa 01       	movw	r30, r20
    2610:	e9 0f       	add	r30, r25
    2612:	f1 1d       	adc	r31, r1
    2614:	20 81       	ld	r18, Z
    2616:	82 2f       	mov	r24, r18
    2618:	81 50       	subi	r24, 0x01	; 1
    261a:	80 32       	cpi	r24, 0x20	; 32
    261c:	b8 f3       	brcs	.-18     	; 0x260c <parse+0x2c>
		argv[argc++]=zeile+i;  // pointer auf Teilstring
    261e:	11 96       	adiw	r26, 0x01	; 1
    2620:	fc 93       	st	X, r31
    2622:	ee 93       	st	-X, r30
    2624:	08 94       	sec
    2626:	e1 1c       	adc	r14, r1
    2628:	f1 1c       	adc	r15, r1
		if (*(zeile+i) ==0) break;
    262a:	22 23       	and	r18, r18
    262c:	11 f4       	brne	.+4      	; 0x2632 <parse+0x52>
    262e:	1a c0       	rjmp	.+52     	; 0x2664 <parse+0x84>
		// bis nchsten Leerzeichen lesen (oder Ende)
		for(;((*(zeile+i) >' ')&&(*zeile+i !=0));i++);
    2630:	9f 5f       	subi	r25, 0xFF	; 255
    2632:	29 2f       	mov	r18, r25
    2634:	30 e0       	ldi	r19, 0x00	; 0
    2636:	ba 01       	movw	r22, r20
    2638:	62 0f       	add	r22, r18
    263a:	73 1f       	adc	r23, r19
    263c:	fb 01       	movw	r30, r22
    263e:	80 81       	ld	r24, Z
    2640:	81 32       	cpi	r24, 0x21	; 33
    2642:	18 f4       	brcc	.+6      	; 0x264a <parse+0x6a>
		if (*(zeile+i)==0) break;
    2644:	88 23       	and	r24, r24
    2646:	39 f4       	brne	.+14     	; 0x2656 <parse+0x76>
    2648:	0d c0       	rjmp	.+26     	; 0x2664 <parse+0x84>
		// fhrende Leerzeichen berlesen (oder Ende)
		for(;((*(zeile+i) <=' ')&&(*(zeile+i) !=0));i++);
		argv[argc++]=zeile+i;  // pointer auf Teilstring
		if (*(zeile+i) ==0) break;
		// bis nchsten Leerzeichen lesen (oder Ende)
		for(;((*(zeile+i) >' ')&&(*zeile+i !=0));i++);
    264a:	fa 01       	movw	r30, r20
    264c:	80 81       	ld	r24, Z
    264e:	28 0f       	add	r18, r24
    2650:	31 1d       	adc	r19, r1
    2652:	23 2b       	or	r18, r19
    2654:	69 f7       	brne	.-38     	; 0x2630 <parse+0x50>
		if (*(zeile+i)==0) break;
		*(zeile+i) =0; // Teilsstring terminieren
    2656:	fb 01       	movw	r30, r22
    2658:	10 82       	st	Z, r1
    265a:	12 96       	adiw	r26, 0x02	; 2
	// Eingabestrings in Teilstrings wandeln
	// Trennzeichen = Leerzeichen
	// argv[0..9] = Teilstrings (Nullterminiert) 
	// argc = Anzahl der Teilstrings (1..10) 
	// Bei keiner Eingabe (nur Enter) ist argc = 1
	for(;argc<10;)
    265c:	fa e0       	ldi	r31, 0x0A	; 10
    265e:	ef 16       	cp	r14, r31
    2660:	f1 04       	cpc	r15, r1
    2662:	a1 f6       	brne	.-88     	; 0x260c <parse+0x2c>
		if (*(zeile+i)==0) break;
		*(zeile+i) =0; // Teilsstring terminieren
		i++;
  }
		
	pcmd=argv[0];
    2664:	19 81       	ldd	r17, Y+1	; 0x01
    2666:	0a 81       	ldd	r16, Y+2	; 0x02
	strupr(pcmd);
    2668:	81 2f       	mov	r24, r17
    266a:	90 2f       	mov	r25, r16
    266c:	0e 94 df 32 	call	0x65be	; 0x65be <strupr>
	if ((strcmp_P(pcmd,PSTR("IP"))==0) && (strlen(pcmd) == 2))
    2670:	60 ec       	ldi	r22, 0xC0	; 192
    2672:	70 e0       	ldi	r23, 0x00	; 0
    2674:	81 2f       	mov	r24, r17
    2676:	90 2f       	mov	r25, r16
    2678:	0e 94 66 32 	call	0x64cc	; 0x64cc <strcmp_P>
    267c:	89 2b       	or	r24, r25
    267e:	a9 f4       	brne	.+42     	; 0x26aa <parse+0xca>
    2680:	a1 2f       	mov	r26, r17
    2682:	b0 2f       	mov	r27, r16
    2684:	fd 01       	movw	r30, r26
    2686:	01 90       	ld	r0, Z+
    2688:	00 20       	and	r0, r0
    268a:	e9 f7       	brne	.-6      	; 0x2686 <parse+0xa6>
    268c:	33 97       	sbiw	r30, 0x03	; 3
    268e:	ea 17       	cp	r30, r26
    2690:	fb 07       	cpc	r31, r27
    2692:	59 f4       	brne	.+22     	; 0x26aa <parse+0xca>
	{
		if (argc>1)
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	e8 16       	cp	r14, r24
    2698:	f1 04       	cpc	r15, r1
    269a:	19 f0       	breq	.+6      	; 0x26a2 <parse+0xc2>
			cmd_ip(argv[1]);
    269c:	8b 81       	ldd	r24, Y+3	; 0x03
    269e:	9c 81       	ldd	r25, Y+4	; 0x04
    26a0:	02 c0       	rjmp	.+4      	; 0x26a6 <parse+0xc6>
		else
			cmd_ip("");
    26a2:	80 e0       	ldi	r24, 0x00	; 0
    26a4:	91 e0       	ldi	r25, 0x01	; 1
    26a6:	0e 94 2d 12 	call	0x245a	; 0x245a <cmd_ip>
		unknown=0;
	}
	if ((strcmp_P(pcmd,PSTR("NETMASK"))==0) && (strlen(pcmd) == 7))
    26aa:	68 eb       	ldi	r22, 0xB8	; 184
    26ac:	70 e0       	ldi	r23, 0x00	; 0
    26ae:	81 2f       	mov	r24, r17
    26b0:	90 2f       	mov	r25, r16
    26b2:	0e 94 66 32 	call	0x64cc	; 0x64cc <strcmp_P>
    26b6:	89 2b       	or	r24, r25
    26b8:	a9 f4       	brne	.+42     	; 0x26e4 <parse+0x104>
    26ba:	a1 2f       	mov	r26, r17
    26bc:	b0 2f       	mov	r27, r16
    26be:	fd 01       	movw	r30, r26
    26c0:	01 90       	ld	r0, Z+
    26c2:	00 20       	and	r0, r0
    26c4:	e9 f7       	brne	.-6      	; 0x26c0 <parse+0xe0>
    26c6:	38 97       	sbiw	r30, 0x08	; 8
    26c8:	ea 17       	cp	r30, r26
    26ca:	fb 07       	cpc	r31, r27
    26cc:	59 f4       	brne	.+22     	; 0x26e4 <parse+0x104>
	{
		if (argc>1)
    26ce:	e1 e0       	ldi	r30, 0x01	; 1
    26d0:	ee 16       	cp	r14, r30
    26d2:	f1 04       	cpc	r15, r1
    26d4:	19 f0       	breq	.+6      	; 0x26dc <parse+0xfc>
			cmd_netmask(argv[1]);
    26d6:	8b 81       	ldd	r24, Y+3	; 0x03
    26d8:	9c 81       	ldd	r25, Y+4	; 0x04
    26da:	02 c0       	rjmp	.+4      	; 0x26e0 <parse+0x100>
		else
			cmd_netmask("");
    26dc:	80 e0       	ldi	r24, 0x00	; 0
    26de:	91 e0       	ldi	r25, 0x01	; 1
    26e0:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <cmd_netmask>
		unknown=0;
	}
	if ((strcmp_P(pcmd,PSTR("CPRESET"))==0) && (strlen(pcmd) == 7))
    26e4:	60 eb       	ldi	r22, 0xB0	; 176
    26e6:	70 e0       	ldi	r23, 0x00	; 0
    26e8:	81 2f       	mov	r24, r17
    26ea:	90 2f       	mov	r25, r16
    26ec:	0e 94 66 32 	call	0x64cc	; 0x64cc <strcmp_P>
    26f0:	89 2b       	or	r24, r25
    26f2:	41 f5       	brne	.+80     	; 0x2744 <parse+0x164>
    26f4:	a1 2f       	mov	r26, r17
    26f6:	b0 2f       	mov	r27, r16
    26f8:	fd 01       	movw	r30, r26
    26fa:	01 90       	ld	r0, Z+
    26fc:	00 20       	and	r0, r0
    26fe:	e9 f7       	brne	.-6      	; 0x26fa <parse+0x11a>
    2700:	38 97       	sbiw	r30, 0x08	; 8
    2702:	ea 17       	cp	r30, r26
    2704:	fb 07       	cpc	r31, r27
    2706:	f1 f4       	brne	.+60     	; 0x2744 <parse+0x164>
	{
		unknown=0;
		uart_puts_P(PSTR("CP2200 reset ..."));
    2708:	ef e9       	ldi	r30, 0x9F	; 159
    270a:	f0 e0       	ldi	r31, 0x00	; 0
    270c:	08 c0       	rjmp	.+16     	; 0x271e <parse+0x13e>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    270e:	80 91 c0 00 	lds	r24, 0x00C0
    2712:	85 ff       	sbrs	r24, 5
    2714:	fc cf       	rjmp	.-8      	; 0x270e <parse+0x12e>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2716:	84 91       	lpm	r24, Z+
    2718:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    271c:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    271e:	84 91       	lpm	r24, Z+
    2720:	88 23       	and	r24, r24
    2722:	a9 f7       	brne	.-22     	; 0x270e <parse+0x12e>
	}
	if ((strcmp_P(pcmd,PSTR("CPRESET"))==0) && (strlen(pcmd) == 7))
	{
		unknown=0;
		uart_puts_P(PSTR("CP2200 reset ..."));
		network_device_init();
    2724:	0e 94 58 19 	call	0x32b0	; 0x32b0 <network_device_init>
		uart_puts_P(PSTR("done \n\r"));
    2728:	e7 e9       	ldi	r30, 0x97	; 151
    272a:	f0 e0       	ldi	r31, 0x00	; 0
    272c:	08 c0       	rjmp	.+16     	; 0x273e <parse+0x15e>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    272e:	80 91 c0 00 	lds	r24, 0x00C0
    2732:	85 ff       	sbrs	r24, 5
    2734:	fc cf       	rjmp	.-8      	; 0x272e <parse+0x14e>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2736:	84 91       	lpm	r24, Z+
    2738:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    273c:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    273e:	84 91       	lpm	r24, Z+
    2740:	88 23       	and	r24, r24
    2742:	a9 f7       	brne	.-22     	; 0x272e <parse+0x14e>
		unknown=0;
		uart_puts_P(PSTR("CP2200 reset ..."));
		network_device_init();
		uart_puts_P(PSTR("done \n\r"));
	}
	if ((strcmp_P(pcmd,PSTR("HELP"))==0) && (strlen(pcmd) == 4))
    2744:	62 e9       	ldi	r22, 0x92	; 146
    2746:	70 e0       	ldi	r23, 0x00	; 0
    2748:	81 2f       	mov	r24, r17
    274a:	90 2f       	mov	r25, r16
    274c:	0e 94 66 32 	call	0x64cc	; 0x64cc <strcmp_P>
    2750:	89 2b       	or	r24, r25
    2752:	61 f4       	brne	.+24     	; 0x276c <parse+0x18c>
    2754:	a1 2f       	mov	r26, r17
    2756:	b0 2f       	mov	r27, r16
    2758:	fd 01       	movw	r30, r26
    275a:	01 90       	ld	r0, Z+
    275c:	00 20       	and	r0, r0
    275e:	e9 f7       	brne	.-6      	; 0x275a <parse+0x17a>
    2760:	35 97       	sbiw	r30, 0x05	; 5
    2762:	ea 17       	cp	r30, r26
    2764:	fb 07       	cpc	r31, r27
    2766:	11 f4       	brne	.+4      	; 0x276c <parse+0x18c>
	{
		unknown=0;
		cmd_help();
    2768:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <cmd_help>
	}


} // parse
    276c:	c0 56       	subi	r28, 0x60	; 96
    276e:	df 4f       	sbci	r29, 0xFF	; 255
    2770:	0f b6       	in	r0, 0x3f	; 63
    2772:	f8 94       	cli
    2774:	de bf       	out	0x3e, r29	; 62
    2776:	0f be       	out	0x3f, r0	; 63
    2778:	cd bf       	out	0x3d, r28	; 61
    277a:	cf 91       	pop	r28
    277c:	df 91       	pop	r29
    277e:	1f 91       	pop	r17
    2780:	0f 91       	pop	r16
    2782:	ff 90       	pop	r15
    2784:	ef 90       	pop	r14
    2786:	08 95       	ret

00002788 <AvailRAM>:
	uart_puts(text);
}

// Groesse des freien RAM Speicher ermitteln
unsigned int AvailRAM(void)
{
    2788:	ef 92       	push	r14
    278a:	ff 92       	push	r15
    278c:	0f 93       	push	r16
    278e:	1f 93       	push	r17
    2790:	df 93       	push	r29
    2792:	cf 93       	push	r28
    2794:	cd b7       	in	r28, 0x3d	; 61
    2796:	de b7       	in	r29, 0x3e	; 62
    2798:	2a 97       	sbiw	r28, 0x0a	; 10
    279a:	0f b6       	in	r0, 0x3f	; 63
    279c:	f8 94       	cli
    279e:	de bf       	out	0x3e, r29	; 62
    27a0:	0f be       	out	0x3f, r0	; 63
    27a2:	cd bf       	out	0x3d, r28	; 61
    27a4:	e0 ea       	ldi	r30, 0xA0	; 160
    27a6:	ee 2e       	mov	r14, r30
    27a8:	ef e0       	ldi	r30, 0x0F	; 15
    27aa:	fe 2e       	mov	r15, r30
	char tmpstr[10];
	unsigned int *p=0;
	size_t i;
	for (i=4000;i>1; i-=10)
	{
		p = (unsigned int *) malloc(i);
    27ac:	c7 01       	movw	r24, r14
    27ae:	0e 94 32 31 	call	0x6264	; 0x6264 <malloc>
		if (p != 0) break;
    27b2:	00 97       	sbiw	r24, 0x00	; 0
    27b4:	41 f4       	brne	.+16     	; 0x27c6 <AvailRAM+0x3e>
unsigned int AvailRAM(void)
{
	char tmpstr[10];
	unsigned int *p=0;
	size_t i;
	for (i=4000;i>1; i-=10)
    27b6:	86 ef       	ldi	r24, 0xF6	; 246
    27b8:	9f ef       	ldi	r25, 0xFF	; 255
    27ba:	e8 0e       	add	r14, r24
    27bc:	f9 1e       	adc	r15, r25
    27be:	e1 14       	cp	r14, r1
    27c0:	f1 04       	cpc	r15, r1
    27c2:	a1 f7       	brne	.-24     	; 0x27ac <AvailRAM+0x24>
    27c4:	02 c0       	rjmp	.+4      	; 0x27ca <AvailRAM+0x42>
	{
		p = (unsigned int *) malloc(i);
		if (p != 0) break;
	}
	if (p != 0) free(p);
    27c6:	0e 94 dc 31 	call	0x63b8	; 0x63b8 <free>
	uart_puts_P(PSTR("available RAM memory:"));
    27ca:	e2 e7       	ldi	r30, 0x72	; 114
    27cc:	f2 e0       	ldi	r31, 0x02	; 2
    27ce:	08 c0       	rjmp	.+16     	; 0x27e0 <AvailRAM+0x58>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    27d0:	80 91 c0 00 	lds	r24, 0x00C0
    27d4:	85 ff       	sbrs	r24, 5
    27d6:	fc cf       	rjmp	.-8      	; 0x27d0 <AvailRAM+0x48>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    27d8:	84 91       	lpm	r24, Z+
    27da:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    27de:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    27e0:	84 91       	lpm	r24, Z+
    27e2:	88 23       	and	r24, r24
    27e4:	a9 f7       	brne	.-22     	; 0x27d0 <AvailRAM+0x48>
		p = (unsigned int *) malloc(i);
		if (p != 0) break;
	}
	if (p != 0) free(p);
	uart_puts_P(PSTR("available RAM memory:"));
	itoa(i,tmpstr,10);
    27e6:	4a e0       	ldi	r20, 0x0A	; 10
    27e8:	50 e0       	ldi	r21, 0x00	; 0
    27ea:	8e 01       	movw	r16, r28
    27ec:	0f 5f       	subi	r16, 0xFF	; 255
    27ee:	1f 4f       	sbci	r17, 0xFF	; 255
    27f0:	b8 01       	movw	r22, r16
    27f2:	c7 01       	movw	r24, r14
    27f4:	0e 94 e9 32 	call	0x65d2	; 0x65d2 <itoa>
    27f8:	f8 01       	movw	r30, r16
    27fa:	07 c0       	rjmp	.+14     	; 0x280a <AvailRAM+0x82>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    27fc:	80 91 c0 00 	lds	r24, 0x00C0
    2800:	85 ff       	sbrs	r24, 5
    2802:	fc cf       	rjmp	.-8      	; 0x27fc <AvailRAM+0x74>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2804:	90 93 c6 00 	sts	0x00C6, r25
void uart_puts (char *s)
{
    while (*s)
    {   
        uart_putc(*s);
        s++;
    2808:	31 96       	adiw	r30, 0x01	; 1
    return 0;
}
 
void uart_puts (char *s)
{
    while (*s)
    280a:	90 81       	ld	r25, Z
    280c:	99 23       	and	r25, r25
    280e:	b1 f7       	brne	.-20     	; 0x27fc <AvailRAM+0x74>
	}
	if (p != 0) free(p);
	uart_puts_P(PSTR("available RAM memory:"));
	itoa(i,tmpstr,10);
	uart_puts(tmpstr);
	uart_puts_P(PSTR(" bytes \r\n"));
    2810:	e8 e6       	ldi	r30, 0x68	; 104
    2812:	f2 e0       	ldi	r31, 0x02	; 2
    2814:	08 c0       	rjmp	.+16     	; 0x2826 <AvailRAM+0x9e>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2816:	80 91 c0 00 	lds	r24, 0x00C0
    281a:	85 ff       	sbrs	r24, 5
    281c:	fc cf       	rjmp	.-8      	; 0x2816 <AvailRAM+0x8e>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    281e:	84 91       	lpm	r24, Z+
    2820:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2824:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2826:	84 91       	lpm	r24, Z+
    2828:	88 23       	and	r24, r24
    282a:	a9 f7       	brne	.-22     	; 0x2816 <AvailRAM+0x8e>
	itoa(i,tmpstr,10);
	uart_puts(tmpstr);
	uart_puts_P(PSTR(" bytes \r\n"));
	
	return(i);
}
    282c:	c7 01       	movw	r24, r14
    282e:	2a 96       	adiw	r28, 0x0a	; 10
    2830:	0f b6       	in	r0, 0x3f	; 63
    2832:	f8 94       	cli
    2834:	de bf       	out	0x3e, r29	; 62
    2836:	0f be       	out	0x3f, r0	; 63
    2838:	cd bf       	out	0x3d, r28	; 61
    283a:	cf 91       	pop	r28
    283c:	df 91       	pop	r29
    283e:	1f 91       	pop	r17
    2840:	0f 91       	pop	r16
    2842:	ff 90       	pop	r15
    2844:	ef 90       	pop	r14
    2846:	08 95       	ret

00002848 <main>:

} // parse


int main(void)
{
    2848:	3f 92       	push	r3
    284a:	4f 92       	push	r4
    284c:	5f 92       	push	r5
    284e:	6f 92       	push	r6
    2850:	7f 92       	push	r7
    2852:	8f 92       	push	r8
    2854:	9f 92       	push	r9
    2856:	af 92       	push	r10
    2858:	bf 92       	push	r11
    285a:	cf 92       	push	r12
    285c:	df 92       	push	r13
    285e:	ef 92       	push	r14
    2860:	ff 92       	push	r15
    2862:	0f 93       	push	r16
    2864:	1f 93       	push	r17
    2866:	df 93       	push	r29
    2868:	cf 93       	push	r28
    286a:	cd b7       	in	r28, 0x3d	; 61
    286c:	de b7       	in	r29, 0x3e	; 62
    286e:	c8 55       	subi	r28, 0x58	; 88
    2870:	d0 40       	sbci	r29, 0x00	; 0
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
	char taste=0;
	char zeile[80];
	int i=0;
	struct timer periodic_timer, arp_timer;
	DDRA = 0x00;    
    287c:	11 b8       	out	0x01, r1	; 1
  DDRB = 0xFF;    
    287e:	8f ef       	ldi	r24, 0xFF	; 255
    2880:	84 b9       	out	0x04, r24	; 4
	DDRC = 0xFF;
    2882:	87 b9       	out	0x07, r24	; 7
	PORTA = 0x00;
    2884:	12 b8       	out	0x02, r1	; 2
	PORTB = 0x00;
    2886:	15 b8       	out	0x05, r1	; 5
	PORTC = 0xF7;
    2888:	87 ef       	ldi	r24, 0xF7	; 247
    288a:	88 b9       	out	0x08, r24	; 8
	PORTC |= (1 << nRD); // set RD#
    288c:	45 9a       	sbi	0x08, 5	; 8
	PORTC |= (1 << nWR); // set WR#
    288e:	44 9a       	sbi	0x08, 4	; 8
	PORTC &= ~(1 << ALE); // clear ALE
    2890:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nCS); // clear CS
    2892:	46 98       	cbi	0x08, 6	; 8
	PORTC |= (1 << nLRST); // reset aus, CP2200 wieder laufen lassen
    2894:	47 9a       	sbi	0x08, 7	; 8
}


void InitUART(void)
{
	UBRR0H = 0;
    2896:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = 64;
    289a:	80 e4       	ldi	r24, 0x40	; 64
    289c:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0) | (1<<TXEN0); // transmit & receive enable 
    28a0:	88 e1       	ldi	r24, 0x18	; 24
    28a2:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = 0x06; // init RS232: 8,N,1
    28a6:	86 e0       	ldi	r24, 0x06	; 6
    28a8:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0A = 0x00; 
    28ac:	10 92 c0 00 	sts	0x00C0, r1
	PORTC &= ~(1 << ALE); // clear ALE
	PORTC &= ~(1 << nCS); // clear CS
	PORTC |= (1 << nLRST); // reset aus, CP2200 wieder laufen lassen
	
	InitUART();
	cmd_help();
    28b0:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <cmd_help>
	AvailRAM();
    28b4:	0e 94 c4 13 	call	0x2788	; 0x2788 <AvailRAM>
    28b8:	84 ef       	ldi	r24, 0xF4	; 244
    28ba:	91 e0       	ldi	r25, 0x01	; 1
    28bc:	28 e8       	ldi	r18, 0x88	; 136
    28be:	33 e1       	ldi	r19, 0x13	; 19
    28c0:	f9 01       	movw	r30, r18
    28c2:	31 97       	sbiw	r30, 0x01	; 1
    28c4:	f1 f7       	brne	.-4      	; 0x28c2 <main+0x7a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28c6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28c8:	d9 f7       	brne	.-10     	; 0x28c0 <main+0x78>
	_delay_ms(50);
	//Init_CP2000();
	cli(); // disable inerrupts
    28ca:	f8 94       	cli
	// MCUCR |= (1<<ISC11);  // 1 = INT1 fallede Flanke
	// MCUCR &= ~(1<<ISC10); // 0	= INT1 fallede Flanke
	EICRA = 0x08; // INT1 fallede Flanke
    28cc:	88 e0       	ldi	r24, 0x08	; 8
    28ce:	80 93 69 00 	sts	0x0069, r24
	// GIMSK = 0x80; // enable external int1
	EIMSK = 0x02; // enable external int1
    28d2:	82 e0       	ldi	r24, 0x02	; 2
    28d4:	8d bb       	out	0x1d, r24	; 29
	// GIFR = 0x80;
	sei();  // enable interrupts 
    28d6:	78 94       	sei
	uart_puts_P(PSTR("init CP2200 ..."));
    28d8:	e2 e8       	ldi	r30, 0x82	; 130
    28da:	f0 e0       	ldi	r31, 0x00	; 0
    28dc:	08 c0       	rjmp	.+16     	; 0x28ee <main+0xa6>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    28de:	80 91 c0 00 	lds	r24, 0x00C0
    28e2:	85 ff       	sbrs	r24, 5
    28e4:	fc cf       	rjmp	.-8      	; 0x28de <main+0x96>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    28e6:	84 91       	lpm	r24, Z+
    28e8:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    28ec:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    28ee:	84 91       	lpm	r24, Z+
    28f0:	88 23       	and	r24, r24
    28f2:	a9 f7       	brne	.-22     	; 0x28de <main+0x96>
    28f4:	84 e6       	ldi	r24, 0x64	; 100
    28f6:	90 e0       	ldi	r25, 0x00	; 0
    28f8:	28 e8       	ldi	r18, 0x88	; 136
    28fa:	33 e1       	ldi	r19, 0x13	; 19
    28fc:	f9 01       	movw	r30, r18
    28fe:	31 97       	sbiw	r30, 0x01	; 1
    2900:	f1 f7       	brne	.-4      	; 0x28fe <main+0xb6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2902:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2904:	d9 f7       	brne	.-10     	; 0x28fc <main+0xb4>
	EIMSK = 0x02; // enable external int1
	// GIFR = 0x80;
	sei();  // enable interrupts 
	uart_puts_P(PSTR("init CP2200 ..."));
	_delay_ms(10);
	network_device_init();
    2906:	0e 94 58 19 	call	0x32b0	; 0x32b0 <network_device_init>
		cmd_ip("");
    290a:	80 e0       	ldi	r24, 0x00	; 0
    290c:	91 e0       	ldi	r25, 0x01	; 1
    290e:	0e 94 2d 12 	call	0x245a	; 0x245a <cmd_ip>
}
*/

void clock_init(void)
{
	cli();
    2912:	f8 94       	cli
	// Timer0 init
	TCCR0A = 0x02;
    2914:	82 e0       	ldi	r24, 0x02	; 2
    2916:	84 bd       	out	0x24, r24	; 36
	TCCR0B = 0x05;
    2918:	95 e0       	ldi	r25, 0x05	; 5
    291a:	95 bd       	out	0x25, r25	; 37
	OCR0A = 0x80; // compare value
    291c:	90 e8       	ldi	r25, 0x80	; 128
    291e:	97 bd       	out	0x27, r25	; 39
	TIMSK0 = 0x02;
    2920:	80 93 6e 00 	sts	0x006E, r24
	sei();
    2924:	78 94       	sei
	uart_puts_P(PSTR("init CP2200 ..."));
	_delay_ms(10);
	network_device_init();
		cmd_ip("");
	clock_init();
	timer_set(&periodic_timer, CLOCK_SECOND / 2);
    2926:	64 ef       	ldi	r22, 0xF4	; 244
    2928:	71 e0       	ldi	r23, 0x01	; 1
    292a:	ce 01       	movw	r24, r28
    292c:	01 96       	adiw	r24, 0x01	; 1
    292e:	0e 94 19 24 	call	0x4832	; 0x4832 <timer_set>
	timer_set(&arp_timer, CLOCK_SECOND * 10);
    2932:	60 e1       	ldi	r22, 0x10	; 16
    2934:	77 e2       	ldi	r23, 0x27	; 39
    2936:	ce 01       	movw	r24, r28
    2938:	05 96       	adiw	r24, 0x05	; 5
    293a:	0e 94 19 24 	call	0x4832	; 0x4832 <timer_set>
	uart_puts_P(PSTR("\r\nready. \r\n"));
    293e:	e6 e7       	ldi	r30, 0x76	; 118
    2940:	f0 e0       	ldi	r31, 0x00	; 0
    2942:	08 c0       	rjmp	.+16     	; 0x2954 <main+0x10c>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2944:	80 91 c0 00 	lds	r24, 0x00C0
    2948:	85 ff       	sbrs	r24, 5
    294a:	fc cf       	rjmp	.-8      	; 0x2944 <main+0xfc>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    294c:	84 91       	lpm	r24, Z+
    294e:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2952:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2954:	84 91       	lpm	r24, Z+
    2956:	88 23       	and	r24, r24
    2958:	a9 f7       	brne	.-22     	; 0x2944 <main+0xfc>
    295a:	84 e6       	ldi	r24, 0x64	; 100
    295c:	90 e0       	ldi	r25, 0x00	; 0
    295e:	28 e8       	ldi	r18, 0x88	; 136
    2960:	33 e1       	ldi	r19, 0x13	; 19
    2962:	f9 01       	movw	r30, r18
    2964:	31 97       	sbiw	r30, 0x01	; 1
    2966:	f1 f7       	brne	.-4      	; 0x2964 <main+0x11c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2968:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    296a:	d9 f7       	brne	.-10     	; 0x2962 <main+0x11a>
	timer_set(&periodic_timer, CLOCK_SECOND / 2);
	timer_set(&arp_timer, CLOCK_SECOND * 10);
	uart_puts_P(PSTR("\r\nready. \r\n"));
	_delay_ms(10);

	uip_arp_init();
    296c:	0e 94 26 30 	call	0x604c	; 0x604c <uip_arp_init>
	uip_init();
    2970:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <uip_init>
	httpd_init();
    2974:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <httpd_init>
    2978:	ee 24       	eor	r14, r14
    297a:	ff 24       	eor	r15, r15
				{
					network_device_send();
				}
			}
		} 
		else if(timer_expired(&periodic_timer)) 
    297c:	4e 01       	movw	r8, r28
    297e:	08 94       	sec
    2980:	81 1c       	adc	r8, r1
    2982:	91 1c       	adc	r9, r1
		{
			timer_reset(&periodic_timer);
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
    2984:	8a e6       	ldi	r24, 0x6A	; 106
    2986:	48 2e       	mov	r4, r24
    2988:	84 e0       	ldi	r24, 0x04	; 4
    298a:	58 2e       	mov	r5, r24
    298c:	07 e1       	ldi	r16, 0x17	; 23
    298e:	60 2e       	mov	r6, r16
    2990:	05 e0       	ldi	r16, 0x05	; 5
    2992:	70 2e       	mov	r7, r16
					network_device_send();
				}
			}
			#endif // UIP_UDP */
			/* Call the ARP timer function every 10 seconds. */
			if(timer_expired(&arp_timer)) 
    2994:	15 e0       	ldi	r17, 0x05	; 5
    2996:	a1 2e       	mov	r10, r17
    2998:	b1 2c       	mov	r11, r1
    299a:	ac 0e       	add	r10, r28
    299c:	bd 1e       	adc	r11, r29
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    299e:	ba e0       	ldi	r27, 0x0A	; 10
    29a0:	3b 2e       	mov	r3, r27
			taste = UDR0; // Zeichen abholen
			uart_putc(taste); // Zeichen ausgeben
			if (taste == 13)
			{
				uart_putc('\n');
				zeile[i]=0;
    29a2:	a9 e0       	ldi	r26, 0x09	; 9
    29a4:	ca 2e       	mov	r12, r26
    29a6:	d1 2c       	mov	r13, r1
    29a8:	cc 0e       	add	r12, r28
    29aa:	dd 1e       	adc	r13, r29



	while(1) 
	{
		uip_len = network_device_read();
    29ac:	0e 94 dd 18 	call	0x31ba	; 0x31ba <network_device_read>
    29b0:	90 93 5e 04 	sts	0x045E, r25
    29b4:	80 93 5d 04 	sts	0x045D, r24
		if(uip_len > 0) 
    29b8:	89 2b       	or	r24, r25
    29ba:	89 f1       	breq	.+98     	; 0x2a1e <main+0x1d6>
		{
			if(BUF->type == htons(UIP_ETHTYPE_IP)) 
    29bc:	00 91 0c 06 	lds	r16, 0x060C
    29c0:	10 91 0d 06 	lds	r17, 0x060D
    29c4:	80 e0       	ldi	r24, 0x00	; 0
    29c6:	98 e0       	ldi	r25, 0x08	; 8
    29c8:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    29cc:	08 17       	cp	r16, r24
    29ce:	19 07       	cpc	r17, r25
    29d0:	79 f4       	brne	.+30     	; 0x29f0 <main+0x1a8>
			{
				uip_arp_ipin();
    29d2:	0e 94 0e 2e 	call	0x5c1c	; 0x5c1c <uip_arp_ipin>
				uip_input();
    29d6:	81 e0       	ldi	r24, 0x01	; 1
    29d8:	0e 94 40 26 	call	0x4c80	; 0x4c80 <uip_process>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    29dc:	80 91 5d 04 	lds	r24, 0x045D
    29e0:	90 91 5e 04 	lds	r25, 0x045E
    29e4:	89 2b       	or	r24, r25
    29e6:	09 f4       	brne	.+2      	; 0x29ea <main+0x1a2>
    29e8:	51 c0       	rjmp	.+162    	; 0x2a8c <main+0x244>
				{
					uip_arp_out();
    29ea:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <uip_arp_out>
    29ee:	14 c0       	rjmp	.+40     	; 0x2a18 <main+0x1d0>
					network_device_send();
				}
			}
			else if(BUF->type == htons(UIP_ETHTYPE_ARP)) 
    29f0:	00 91 0c 06 	lds	r16, 0x060C
    29f4:	10 91 0d 06 	lds	r17, 0x060D
    29f8:	86 e0       	ldi	r24, 0x06	; 6
    29fa:	98 e0       	ldi	r25, 0x08	; 8
    29fc:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    2a00:	08 17       	cp	r16, r24
    2a02:	19 07       	cpc	r17, r25
    2a04:	09 f0       	breq	.+2      	; 0x2a08 <main+0x1c0>
    2a06:	42 c0       	rjmp	.+132    	; 0x2a8c <main+0x244>
			{
			
				uip_arp_arpin();
    2a08:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <uip_arp_arpin>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    2a0c:	80 91 5d 04 	lds	r24, 0x045D
    2a10:	90 91 5e 04 	lds	r25, 0x045E
    2a14:	89 2b       	or	r24, r25
    2a16:	d1 f1       	breq	.+116    	; 0x2a8c <main+0x244>
				{
					network_device_send();
    2a18:	0e 94 09 17 	call	0x2e12	; 0x2e12 <network_device_send>
    2a1c:	37 c0       	rjmp	.+110    	; 0x2a8c <main+0x244>
				}
			}
		} 
		else if(timer_expired(&periodic_timer)) 
    2a1e:	c4 01       	movw	r24, r8
    2a20:	0e 94 f7 23 	call	0x47ee	; 0x47ee <timer_expired>
    2a24:	89 2b       	or	r24, r25
    2a26:	91 f1       	breq	.+100    	; 0x2a8c <main+0x244>
		{
			timer_reset(&periodic_timer);
    2a28:	c4 01       	movw	r24, r8
    2a2a:	0e 94 ed 23 	call	0x47da	; 0x47da <timer_reset>
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
    2a2e:	50 92 69 04 	sts	0x0469, r5
    2a32:	40 92 68 04 	sts	0x0468, r4
    2a36:	82 e0       	ldi	r24, 0x02	; 2
    2a38:	0e 94 40 26 	call	0x4c80	; 0x4c80 <uip_process>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    2a3c:	80 91 5d 04 	lds	r24, 0x045D
    2a40:	90 91 5e 04 	lds	r25, 0x045E
    2a44:	89 2b       	or	r24, r25
    2a46:	21 f0       	breq	.+8      	; 0x2a50 <main+0x208>
				{
					uip_arp_out();
    2a48:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <uip_arp_out>
					network_device_send();
    2a4c:	0e 94 09 17 	call	0x2e12	; 0x2e12 <network_device_send>
		else if(timer_expired(&periodic_timer)) 
		{
			timer_reset(&periodic_timer);
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
    2a50:	70 92 69 04 	sts	0x0469, r7
    2a54:	60 92 68 04 	sts	0x0468, r6
    2a58:	82 e0       	ldi	r24, 0x02	; 2
    2a5a:	0e 94 40 26 	call	0x4c80	; 0x4c80 <uip_process>
				/* If the above function invocation resulted in data that
				should be sent out on the network, the global variable
				uip_len is set to a value > 0. */
				if(uip_len > 0) 
    2a5e:	80 91 5d 04 	lds	r24, 0x045D
    2a62:	90 91 5e 04 	lds	r25, 0x045E
    2a66:	89 2b       	or	r24, r25
    2a68:	21 f0       	breq	.+8      	; 0x2a72 <main+0x22a>
				{
					uip_arp_out();
    2a6a:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <uip_arp_out>
					network_device_send();
    2a6e:	0e 94 09 17 	call	0x2e12	; 0x2e12 <network_device_send>
					network_device_send();
				}
			}
			#endif // UIP_UDP */
			/* Call the ARP timer function every 10 seconds. */
			if(timer_expired(&arp_timer)) 
    2a72:	c5 01       	movw	r24, r10
    2a74:	0e 94 f7 23 	call	0x47ee	; 0x47ee <timer_expired>
    2a78:	89 2b       	or	r24, r25
    2a7a:	29 f0       	breq	.+10     	; 0x2a86 <main+0x23e>
			{
				timer_reset(&arp_timer);
    2a7c:	c5 01       	movw	r24, r10
    2a7e:	0e 94 ed 23 	call	0x47da	; 0x47da <timer_reset>
				uip_arp_timer();
    2a82:	0e 94 f9 2f 	call	0x5ff2	; 0x5ff2 <uip_arp_timer>
    2a86:	f2 e0       	ldi	r31, 0x02	; 2
    2a88:	ef 2e       	mov	r14, r31
    2a8a:	f1 2c       	mov	r15, r1
			}
		}

		
		if (UCSR0A & (1<<RXC0))  // Zeichen verfuegbar?
    2a8c:	80 91 c0 00 	lds	r24, 0x00C0
    2a90:	87 ff       	sbrs	r24, 7
    2a92:	8c cf       	rjmp	.-232    	; 0x29ac <main+0x164>
		{
			taste = UDR0; // Zeichen abholen
    2a94:	00 91 c6 00 	lds	r16, 0x00C6
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2a98:	80 91 c0 00 	lds	r24, 0x00C0
    2a9c:	85 ff       	sbrs	r24, 5
    2a9e:	fc cf       	rjmp	.-8      	; 0x2a98 <main+0x250>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2aa0:	00 93 c6 00 	sts	0x00C6, r16
		
		if (UCSR0A & (1<<RXC0))  // Zeichen verfuegbar?
		{
			taste = UDR0; // Zeichen abholen
			uart_putc(taste); // Zeichen ausgeben
			if (taste == 13)
    2aa4:	0d 30       	cpi	r16, 0x0D	; 13
    2aa6:	f1 f4       	brne	.+60     	; 0x2ae4 <main+0x29c>
}

// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc(unsigned char c)
{
	  while(!(UCSR0A & (1<< UDRE0))); // warte, bis UDR bereit 
    2aa8:	80 91 c0 00 	lds	r24, 0x00C0
    2aac:	85 ff       	sbrs	r24, 5
    2aae:	fc cf       	rjmp	.-8      	; 0x2aa8 <main+0x260>
    //while(!(USR & (1 << UDRE))); // warte, bis UDR bereit 
    UDR0 = c;                     // sende Zeichen 
    2ab0:	30 92 c6 00 	sts	0x00C6, r3
			taste = UDR0; // Zeichen abholen
			uart_putc(taste); // Zeichen ausgeben
			if (taste == 13)
			{
				uart_putc('\n');
				zeile[i]=0;
    2ab4:	ec 0c       	add	r14, r12
    2ab6:	fd 1c       	adc	r15, r13
    2ab8:	f7 01       	movw	r30, r14
    2aba:	10 82       	st	Z, r1
				parse(zeile);	
    2abc:	c6 01       	movw	r24, r12
    2abe:	0e 94 f0 12 	call	0x25e0	; 0x25e0 <parse>
				uart_puts_P(PSTR("#"));
    2ac2:	e4 e7       	ldi	r30, 0x74	; 116
    2ac4:	f0 e0       	ldi	r31, 0x00	; 0
    2ac6:	08 c0       	rjmp	.+16     	; 0x2ad8 <main+0x290>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2ac8:	80 91 c0 00 	lds	r24, 0x00C0
    2acc:	85 ff       	sbrs	r24, 5
    2ace:	fc cf       	rjmp	.-8      	; 0x2ac8 <main+0x280>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2ad0:	84 91       	lpm	r24, Z+
    2ad2:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2ad6:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2ad8:	84 91       	lpm	r24, Z+
    2ada:	88 23       	and	r24, r24
    2adc:	a9 f7       	brne	.-22     	; 0x2ac8 <main+0x280>
    2ade:	ee 24       	eor	r14, r14
    2ae0:	ff 24       	eor	r15, r15
    2ae2:	1d c0       	rjmp	.+58     	; 0x2b1e <main+0x2d6>
				uart_puts_P(PSTR("#"));
				i=0;
				
			}
			
			if (taste == 8)
    2ae4:	08 30       	cpi	r16, 0x08	; 8
    2ae6:	b1 f4       	brne	.+44     	; 0x2b14 <main+0x2cc>
			{
				// Backspace key
				if (i>0) 
    2ae8:	e1 14       	cp	r14, r1
    2aea:	f1 04       	cpc	r15, r1
    2aec:	09 f4       	brne	.+2      	; 0x2af0 <main+0x2a8>
    2aee:	5e cf       	rjmp	.-324    	; 0x29ac <main+0x164>
				{
					i--;
					uart_puts_P(PSTR("\x1B[P")); // VT100-Code Backspace
    2af0:	e0 e7       	ldi	r30, 0x70	; 112
    2af2:	f0 e0       	ldi	r31, 0x00	; 0
    2af4:	08 c0       	rjmp	.+16     	; 0x2b06 <main+0x2be>
}
 
// putc fuer AVR mit einem UART (z.B. AT90S8515)
int uart_putc_P(PGM_P c)
{
    while(!(UCSR0A & (1 << UDRE0))); // warte, bis UDR bereit 
    2af6:	80 91 c0 00 	lds	r24, 0x00C0
    2afa:	85 ff       	sbrs	r24, 5
    2afc:	fc cf       	rjmp	.-8      	; 0x2af6 <main+0x2ae>
    UDR0 = pgm_read_byte(c);                     // sende Zeichen 
    2afe:	84 91       	lpm	r24, Z+
    2b00:	80 93 c6 00 	sts	0x00C6, r24
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    {   
        uart_putc_P(s);
        s++;
    2b04:	31 96       	adiw	r30, 0x01	; 1
} 

// konstante aus Flash
void uart_puts_P (PGM_P s)
{
    while (pgm_read_byte(s))
    2b06:	84 91       	lpm	r24, Z+
    2b08:	88 23       	and	r24, r24
    2b0a:	a9 f7       	brne	.-22     	; 0x2af6 <main+0x2ae>
			if (taste == 8)
			{
				// Backspace key
				if (i>0) 
				{
					i--;
    2b0c:	08 94       	sec
    2b0e:	e1 08       	sbc	r14, r1
    2b10:	f1 08       	sbc	r15, r1
    2b12:	4c cf       	rjmp	.-360    	; 0x29ac <main+0x164>
					uart_puts_P(PSTR("\x1B[P")); // VT100-Code Backspace
				}
			}	
			else
			{
				if (i<78)
    2b14:	fe e4       	ldi	r31, 0x4E	; 78
    2b16:	ef 16       	cp	r14, r31
    2b18:	f1 04       	cpc	r15, r1
    2b1a:	0c f0       	brlt	.+2      	; 0x2b1e <main+0x2d6>
    2b1c:	47 cf       	rjmp	.-370    	; 0x29ac <main+0x164>
					zeile[i++]=taste; // Zeichen merken
    2b1e:	f6 01       	movw	r30, r12
    2b20:	ee 0d       	add	r30, r14
    2b22:	ff 1d       	adc	r31, r15
    2b24:	00 83       	st	Z, r16
    2b26:	08 94       	sec
    2b28:	e1 1c       	adc	r14, r1
    2b2a:	f1 1c       	adc	r15, r1
    2b2c:	3f cf       	rjmp	.-386    	; 0x29ac <main+0x164>

00002b2e <CP2200_ReadTXBuffer>:
// globale Variablen
static char CP2200_status=0;

// ---------------------------------------------
unsigned char CP2200_ReadTXBuffer(unsigned int addr)
{
    2b2e:	43 9a       	sbi	0x08, 3	; 8


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
	DDRA = 0xFF; // AD0..7 output
    2b30:	3f ef       	ldi	r19, 0xFF	; 255
    2b32:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2b34:	29 e0       	ldi	r18, 0x09	; 9
    2b36:	22 b9       	out	0x02, r18	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2b38:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2b3a:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2b3c:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2b3e:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2b40:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2b42:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2b44:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2b46:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2b48:	88 e0       	ldi	r24, 0x08	; 8
    2b4a:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2b4c:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2b4e:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2b50:	92 b9       	out	0x02, r25	; 2
	PORTC |= (1 << nWR); // set WR#
    2b52:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2b54:	92 b9       	out	0x02, r25	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2b56:	11 b8       	out	0x01, r1	; 1


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2b58:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2b5a:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2b5c:	84 e0       	ldi	r24, 0x04	; 4
    2b5e:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2b60:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2b62:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2b64:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2b66:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2b68:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2b6a:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2b6c:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2b6e:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2b70:	45 9a       	sbi	0x08, 5	; 8
unsigned char CP2200_ReadTXBuffer(unsigned int addr)
{
	write_CP2200(RAMADDRL,addr & 0xFF); 
	write_CP2200(RAMADDRH,addr >> 8); 
	return (read_CP2200(RAMTXDATA));
}
    2b72:	08 95       	ret

00002b74 <CP2200_WriteTXBuffer>:

// ---------------------------------------------
void CP2200_WriteTXBuffer(unsigned int addr, unsigned char value)
{
    2b74:	43 9a       	sbi	0x08, 3	; 8


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
	DDRA = 0xFF; // AD0..7 output
    2b76:	3f ef       	ldi	r19, 0xFF	; 255
    2b78:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2b7a:	29 e0       	ldi	r18, 0x09	; 9
    2b7c:	22 b9       	out	0x02, r18	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2b7e:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2b80:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2b82:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2b84:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2b86:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2b88:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2b8a:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2b8c:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2b8e:	88 e0       	ldi	r24, 0x08	; 8
    2b90:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2b92:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2b94:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2b96:	92 b9       	out	0x02, r25	; 2
	PORTC |= (1 << nWR); // set WR#
    2b98:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2b9a:	92 b9       	out	0x02, r25	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2b9c:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2b9e:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2ba0:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2ba2:	84 e0       	ldi	r24, 0x04	; 4
    2ba4:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2ba6:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2ba8:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2baa:	62 b9       	out	0x02, r22	; 2
	PORTC |= (1 << nWR); // set WR#
    2bac:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2bae:	62 b9       	out	0x02, r22	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2bb0:	11 b8       	out	0x01, r1	; 1
void CP2200_WriteTXBuffer(unsigned int addr, unsigned char value)
{
	write_CP2200(RAMADDRL,addr & 0xFF); 
	write_CP2200(RAMADDRH,addr >> 8); 
	write_CP2200(RAMTXDATA,value); 
}
    2bb2:	08 95       	ret

00002bb4 <CP2200_ReadRXBuffer>:

// ---------------------------------------------
unsigned char CP2200_ReadRXBuffer(unsigned int addr)
{
    2bb4:	43 9a       	sbi	0x08, 3	; 8


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
	DDRA = 0xFF; // AD0..7 output
    2bb6:	3f ef       	ldi	r19, 0xFF	; 255
    2bb8:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2bba:	29 e0       	ldi	r18, 0x09	; 9
    2bbc:	22 b9       	out	0x02, r18	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2bbe:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2bc0:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2bc2:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2bc4:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2bc6:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2bc8:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2bca:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2bcc:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2bce:	88 e0       	ldi	r24, 0x08	; 8
    2bd0:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2bd2:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2bd4:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2bd6:	92 b9       	out	0x02, r25	; 2
	PORTC |= (1 << nWR); // set WR#
    2bd8:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2bda:	92 b9       	out	0x02, r25	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2bdc:	11 b8       	out	0x01, r1	; 1


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2bde:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2be0:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2be2:	82 e0       	ldi	r24, 0x02	; 2
    2be4:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2be6:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2be8:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2bea:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2bec:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2bee:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2bf0:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2bf2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2bf4:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2bf6:	45 9a       	sbi	0x08, 5	; 8
unsigned char CP2200_ReadRXBuffer(unsigned int addr)
{
	write_CP2200(RAMADDRL, (char) (addr & 0xFF)); 
	write_CP2200(RAMADDRH,(char) (addr >> 8)); 
	return (read_CP2200(RAMRXDATA));
}
    2bf8:	08 95       	ret

00002bfa <CP2200_WriteRXBuffer>:

// ---------------------------------------------
void CP2200_WriteRXBuffer(unsigned int addr, unsigned char value)
{
    2bfa:	43 9a       	sbi	0x08, 3	; 8


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
	DDRA = 0xFF; // AD0..7 output
    2bfc:	3f ef       	ldi	r19, 0xFF	; 255
    2bfe:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2c00:	29 e0       	ldi	r18, 0x09	; 9
    2c02:	22 b9       	out	0x02, r18	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2c04:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2c06:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2c08:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2c0a:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2c0c:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2c0e:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2c10:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2c12:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2c14:	88 e0       	ldi	r24, 0x08	; 8
    2c16:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2c18:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2c1a:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2c1c:	92 b9       	out	0x02, r25	; 2
	PORTC |= (1 << nWR); // set WR#
    2c1e:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2c20:	92 b9       	out	0x02, r25	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2c22:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2c24:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2c26:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2c28:	82 e0       	ldi	r24, 0x02	; 2
    2c2a:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2c2c:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2c2e:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2c30:	62 b9       	out	0x02, r22	; 2
	PORTC |= (1 << nWR); // set WR#
    2c32:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2c34:	62 b9       	out	0x02, r22	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2c36:	11 b8       	out	0x01, r1	; 1
void CP2200_WriteRXBuffer(unsigned int addr, unsigned char value)
{
	write_CP2200(RAMADDRL,addr & 0xFF); 
	write_CP2200(RAMADDRH,addr >> 8); 
	write_CP2200(RAMRXDATA,value); 
}
    2c38:	08 95       	ret

00002c3a <CP2200_ReadPacket>:

// ---------------------------------------------
u16_t CP2200_ReadPacket(void)
{
    2c3a:	43 9a       	sbi	0x08, 3	; 8

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2c3c:	9f ef       	ldi	r25, 0xFF	; 255
    2c3e:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2c40:	8f e1       	ldi	r24, 0x1F	; 31
    2c42:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2c44:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2c46:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2c48:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2c4a:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c4c:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c4e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c50:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2c52:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2c54:	45 9a       	sbi	0x08, 5	; 8
	// uip_buf
	// get packet len
		u16_t packetlen;
	u16_t i;
	packetlen = read_CP2200(CPLENH);
	packetlen = packetlen << 8;
    2c56:	38 2f       	mov	r19, r24
    2c58:	20 e0       	ldi	r18, 0x00	; 0


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2c5a:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2c5c:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2c5e:	80 e2       	ldi	r24, 0x20	; 32
    2c60:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2c62:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2c64:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2c66:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2c68:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c6a:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c6c:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c6e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2c70:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2c72:	45 9a       	sbi	0x08, 5	; 8
	// get packet len
		u16_t packetlen;
	u16_t i;
	packetlen = read_CP2200(CPLENH);
	packetlen = packetlen << 8;
	packetlen |= read_CP2200(CPLENL);
    2c74:	48 2f       	mov	r20, r24
    2c76:	50 e0       	ldi	r21, 0x00	; 0
    2c78:	42 2b       	or	r20, r18
    2c7a:	53 2b       	or	r21, r19
    2c7c:	20 e0       	ldi	r18, 0x00	; 0
    2c7e:	30 e0       	ldi	r19, 0x00	; 0

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2c80:	6f ef       	ldi	r22, 0xFF	; 255
	PORTA = adr; // output address
    2c82:	91 e0       	ldi	r25, 0x01	; 1
    2c84:	12 c0       	rjmp	.+36     	; 0x2caa <CP2200_ReadPacket+0x70>


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2c86:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2c88:	61 b9       	out	0x01, r22	; 1
	PORTA = adr; // output address
    2c8a:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2c8c:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2c8e:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2c90:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2c92:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c94:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c96:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2c98:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2c9a:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2c9c:	45 9a       	sbi	0x08, 5	; 8
	packetlen = read_CP2200(CPLENH);
	packetlen = packetlen << 8;
	packetlen |= read_CP2200(CPLENL);
	for (i=0;i<packetlen;i++)
	{
		*(uip_buf+i) = read_CP2200(RXAUTORD);
    2c9e:	f9 01       	movw	r30, r18
    2ca0:	e0 50       	subi	r30, 0x00	; 0
    2ca2:	fa 4f       	sbci	r31, 0xFA	; 250
    2ca4:	80 83       	st	Z, r24
		u16_t packetlen;
	u16_t i;
	packetlen = read_CP2200(CPLENH);
	packetlen = packetlen << 8;
	packetlen |= read_CP2200(CPLENL);
	for (i=0;i<packetlen;i++)
    2ca6:	2f 5f       	subi	r18, 0xFF	; 255
    2ca8:	3f 4f       	sbci	r19, 0xFF	; 255
    2caa:	24 17       	cp	r18, r20
    2cac:	35 07       	cpc	r19, r21
    2cae:	58 f3       	brcs	.-42     	; 0x2c86 <CP2200_ReadPacket+0x4c>
	{
		*(uip_buf+i) = read_CP2200(RXAUTORD);
	}
	return(packetlen);
}
    2cb0:	ca 01       	movw	r24, r20
    2cb2:	08 95       	ret

00002cb4 <CP2200_WritePacket>:
	return(packetlen);
}

// ---------------------------------------------
void CP2200_WritePacket(void)
{
    2cb4:	0f 93       	push	r16
    2cb6:	1f 93       	push	r17
    2cb8:	cf 93       	push	r28
    2cba:	df 93       	push	r29

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2cbc:	2f ef       	ldi	r18, 0xFF	; 255
	PORTA = adr; // output address
    2cbe:	94 e5       	ldi	r25, 0x54	; 84


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2cc0:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2cc2:	3f ef       	ldi	r19, 0xFF	; 255
    2cc4:	21 b9       	out	0x01, r18	; 1
	PORTA = adr; // output address
    2cc6:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2cc8:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2cca:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2ccc:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2cce:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2cd0:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2cd2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2cd4:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2cd6:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2cd8:	45 9a       	sbi	0x08, 5	; 8
{
	//unsigned int len;
	unsigned int addr;
	unsigned int t;
	// wait for previous packet complete
	while (read_CP2200(TXBUSY) != 0x00);
    2cda:	88 23       	and	r24, r24
    2cdc:	89 f7       	brne	.-30     	; 0x2cc0 <CP2200_WritePacket+0xc>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2cde:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2ce0:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2ce2:	89 e5       	ldi	r24, 0x59	; 89
    2ce4:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2ce6:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2ce8:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2cea:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    2cec:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2cee:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2cf0:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2cf2:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2cf4:	31 b9       	out	0x01, r19	; 1
	PORTA = adr; // output address
    2cf6:	8a e5       	ldi	r24, 0x5A	; 90
    2cf8:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2cfa:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2cfc:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2cfe:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    2d00:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2d02:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2d04:	11 b8       	out	0x01, r1	; 1
    2d06:	80 e0       	ldi	r24, 0x00	; 0
    2d08:	90 e0       	ldi	r25, 0x00	; 0
	
	//hwsend(&uip_buf[0], UIP_LLH_LEN);
	addr=0;
	for (t=0;t < UIP_LLH_LEN;t++)
	{
		CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
    2d0a:	ec 01       	movw	r28, r24
    2d0c:	21 96       	adiw	r28, 0x01	; 1
    2d0e:	fc 01       	movw	r30, r24
    2d10:	e0 50       	subi	r30, 0x00	; 0
    2d12:	fa 4f       	sbci	r31, 0xFA	; 250
    2d14:	60 81       	ld	r22, Z
    2d16:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <CP2200_WriteTXBuffer>
    2d1a:	ce 01       	movw	r24, r28
	write_CP2200(TXSTARTH,0x00);
	write_CP2200(TXSTARTL,0x00);
	
	//hwsend(&uip_buf[0], UIP_LLH_LEN);
	addr=0;
	for (t=0;t < UIP_LLH_LEN;t++)
    2d1c:	ce 30       	cpi	r28, 0x0E	; 14
    2d1e:	d1 05       	cpc	r29, r1
    2d20:	a1 f7       	brne	.-24     	; 0x2d0a <CP2200_WritePacket+0x56>
	{
		CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
	}
	
	if(uip_len <= UIP_LLH_LEN + UIP_TCPIP_HLEN) 
    2d22:	80 91 5d 04 	lds	r24, 0x045D
    2d26:	90 91 5e 04 	lds	r25, 0x045E
    2d2a:	c7 97       	sbiw	r24, 0x37	; 55
    2d2c:	60 f0       	brcs	.+24     	; 0x2d46 <CP2200_WritePacket+0x92>
    2d2e:	13 c0       	rjmp	.+38     	; 0x2d56 <CP2200_WritePacket+0xa2>
	{
		
		//hwsend(&uip_buf[UIP_LLH_LEN], uip_len - UIP_LLH_LEN);
		for (t=UIP_LLH_LEN;t < uip_len;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
    2d30:	8e 01       	movw	r16, r28
    2d32:	0f 5f       	subi	r16, 0xFF	; 255
    2d34:	1f 4f       	sbci	r17, 0xFF	; 255
    2d36:	fe 01       	movw	r30, r28
    2d38:	e0 50       	subi	r30, 0x00	; 0
    2d3a:	fa 4f       	sbci	r31, 0xFA	; 250
    2d3c:	60 81       	ld	r22, Z
    2d3e:	ce 01       	movw	r24, r28
    2d40:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <CP2200_WriteTXBuffer>
    2d44:	e8 01       	movw	r28, r16
	
	if(uip_len <= UIP_LLH_LEN + UIP_TCPIP_HLEN) 
	{
		
		//hwsend(&uip_buf[UIP_LLH_LEN], uip_len - UIP_LLH_LEN);
		for (t=UIP_LLH_LEN;t < uip_len;t++)
    2d46:	80 91 5d 04 	lds	r24, 0x045D
    2d4a:	90 91 5e 04 	lds	r25, 0x045E
    2d4e:	c8 17       	cp	r28, r24
    2d50:	d9 07       	cpc	r29, r25
    2d52:	70 f3       	brcs	.-36     	; 0x2d30 <CP2200_WritePacket+0x7c>
    2d54:	25 c0       	rjmp	.+74     	; 0x2da0 <CP2200_WritePacket+0xec>
    2d56:	ce 01       	movw	r24, r28
	else 
	{
		//hwsend(&uip_buf[UIP_LLH_LEN], UIP_TCPIP_HLEN);
		for (t=UIP_LLH_LEN;t < UIP_TCPIP_HLEN+UIP_LLH_LEN;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
    2d58:	21 96       	adiw	r28, 0x01	; 1
    2d5a:	fc 01       	movw	r30, r24
    2d5c:	e0 50       	subi	r30, 0x00	; 0
    2d5e:	fa 4f       	sbci	r31, 0xFA	; 250
    2d60:	60 81       	ld	r22, Z
    2d62:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <CP2200_WriteTXBuffer>
		}
	} 
	else 
	{
		//hwsend(&uip_buf[UIP_LLH_LEN], UIP_TCPIP_HLEN);
		for (t=UIP_LLH_LEN;t < UIP_TCPIP_HLEN+UIP_LLH_LEN;t++)
    2d66:	c6 33       	cpi	r28, 0x36	; 54
    2d68:	d1 05       	cpc	r29, r1
    2d6a:	a9 f7       	brne	.-22     	; 0x2d56 <CP2200_WritePacket+0xa2>
    2d6c:	0e c0       	rjmp	.+28     	; 0x2d8a <CP2200_WritePacket+0xd6>
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
		}
		//hwsend(uip_appdata, uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN);
		for (t=0;t < uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(((unsigned char *)uip_appdata) + t));
    2d6e:	8e 01       	movw	r16, r28
    2d70:	0f 5f       	subi	r16, 0xFF	; 255
    2d72:	1f 4f       	sbci	r17, 0xFF	; 255
    2d74:	e0 91 66 04 	lds	r30, 0x0466
    2d78:	f0 91 67 04 	lds	r31, 0x0467
    2d7c:	e2 0f       	add	r30, r18
    2d7e:	f3 1f       	adc	r31, r19
    2d80:	60 81       	ld	r22, Z
    2d82:	ce 01       	movw	r24, r28
    2d84:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <CP2200_WriteTXBuffer>
    2d88:	e8 01       	movw	r28, r16
    2d8a:	9e 01       	movw	r18, r28
    2d8c:	26 53       	subi	r18, 0x36	; 54
    2d8e:	30 40       	sbci	r19, 0x00	; 0
		for (t=UIP_LLH_LEN;t < UIP_TCPIP_HLEN+UIP_LLH_LEN;t++)
		{
			CP2200_WriteTXBuffer(addr++, *(uip_buf + t));
		}
		//hwsend(uip_appdata, uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN);
		for (t=0;t < uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN;t++)
    2d90:	80 91 5d 04 	lds	r24, 0x045D
    2d94:	90 91 5e 04 	lds	r25, 0x045E
    2d98:	c6 97       	sbiw	r24, 0x36	; 54
    2d9a:	28 17       	cp	r18, r24
    2d9c:	39 07       	cpc	r19, r25
    2d9e:	38 f3       	brcs	.-50     	; 0x2d6e <CP2200_WritePacket+0xba>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2da0:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2da2:	9f ef       	ldi	r25, 0xFF	; 255
    2da4:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2da6:	87 e5       	ldi	r24, 0x57	; 87
    2da8:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2daa:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2dac:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2dae:	d2 b9       	out	0x02, r29	; 2
	PORTC |= (1 << nWR); // set WR#
    2db0:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2db2:	d2 b9       	out	0x02, r29	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2db4:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2db6:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2db8:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2dba:	88 e5       	ldi	r24, 0x58	; 88
    2dbc:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2dbe:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2dc0:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2dc2:	c2 b9       	out	0x02, r28	; 2
	PORTC |= (1 << nWR); // set WR#
    2dc4:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2dc6:	c2 b9       	out	0x02, r28	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2dc8:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2dca:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2dcc:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2dce:	89 e5       	ldi	r24, 0x59	; 89
    2dd0:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2dd2:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2dd4:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2dd6:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    2dd8:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2dda:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2ddc:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2dde:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2de0:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2de2:	8a e5       	ldi	r24, 0x5A	; 90
    2de4:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2de6:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2de8:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2dea:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    2dec:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2dee:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2df0:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2df2:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2df4:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2df6:	83 e5       	ldi	r24, 0x53	; 83
    2df8:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2dfa:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2dfc:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2dfe:	81 e0       	ldi	r24, 0x01	; 1
    2e00:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2e02:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2e04:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2e06:	11 b8       	out	0x01, r1	; 1
	// set packet start
	write_CP2200(TXSTARTH,0x00);
	write_CP2200(TXSTARTL,0x00);
	write_CP2200(TXCN,0x01); // send packet
	//uart_puts_P(PSTR("[sp] "));	
}
    2e08:	df 91       	pop	r29
    2e0a:	cf 91       	pop	r28
    2e0c:	1f 91       	pop	r17
    2e0e:	0f 91       	pop	r16
    2e10:	08 95       	ret

00002e12 <network_device_send>:

// ---------------------------------------------
void network_device_send(void)
{
    2e12:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <CP2200_WritePacket>
	CP2200_WritePacket();
}
    2e16:	08 95       	ret

00002e18 <write_CP2200>:


void write_CP2200(int adr, char value)
{
    2e18:	43 9a       	sbi	0x08, 3	; 8
	PORTC |= (1 << ALE); // set ALE 
	DDRA = 0xFF; // AD0..7 output
    2e1a:	9f ef       	ldi	r25, 0xFF	; 255
    2e1c:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2e1e:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2e20:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2e22:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2e24:	62 b9       	out	0x02, r22	; 2
	PORTC |= (1 << nWR); // set WR#
    2e26:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2e28:	62 b9       	out	0x02, r22	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2e2a:	11 b8       	out	0x01, r1	; 1
}
    2e2c:	08 95       	ret

00002e2e <read_CP2200>:


char read_CP2200(int adr)
{
    2e2e:	43 9a       	sbi	0x08, 3	; 8
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2e30:	9f ef       	ldi	r25, 0xFF	; 255
    2e32:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2e34:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2e36:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2e38:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2e3a:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2e3c:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2e3e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2e40:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2e42:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2e44:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2e46:	45 9a       	sbi	0x08, 5	; 8
	return(value);
}
    2e48:	08 95       	ret

00002e4a <cpWriteMac>:
}


// ---------------------------------------------
static void cpWriteMac(char adr,int value)
{
    2e4a:	43 9a       	sbi	0x08, 3	; 8


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
	DDRA = 0xFF; // AD0..7 output
    2e4c:	4f ef       	ldi	r20, 0xFF	; 255
    2e4e:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2e50:	9a e0       	ldi	r25, 0x0A	; 10
    2e52:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2e54:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2e56:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2e58:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2e5a:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2e5c:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2e5e:	11 b8       	out	0x01, r1	; 1

// ---------------------------------------------
static void cpWriteMac(char adr,int value)
{
  write_CP2200(MACADDR,adr);
  write_CP2200(MACDATAH,value>>8);
    2e60:	27 2f       	mov	r18, r23
    2e62:	33 27       	eor	r19, r19
    2e64:	27 fd       	sbrc	r18, 7
    2e66:	3a 95       	dec	r19
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2e68:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2e6a:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2e6c:	8b e0       	ldi	r24, 0x0B	; 11
    2e6e:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2e70:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2e72:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2e74:	22 b9       	out	0x02, r18	; 2
	PORTC |= (1 << nWR); // set WR#
    2e76:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2e78:	22 b9       	out	0x02, r18	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2e7a:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2e7c:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2e7e:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2e80:	8c e0       	ldi	r24, 0x0C	; 12
    2e82:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2e84:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2e86:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2e88:	62 b9       	out	0x02, r22	; 2
	PORTC |= (1 << nWR); // set WR#
    2e8a:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2e8c:	62 b9       	out	0x02, r22	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2e8e:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2e90:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2e92:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2e94:	8d e0       	ldi	r24, 0x0D	; 13
    2e96:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2e98:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2e9a:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2e9c:	81 e0       	ldi	r24, 0x01	; 1
    2e9e:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2ea0:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2ea2:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2ea4:	11 b8       	out	0x01, r1	; 1
{
  write_CP2200(MACADDR,adr);
  write_CP2200(MACDATAH,value>>8);
  write_CP2200(MACDATAL,value);
  write_CP2200(MACRW,1);
}
    2ea6:	08 95       	ret

00002ea8 <Init_CP2000>:
	
}

// ---------------------------------------------
void Init_CP2000(void)
{
    2ea8:	0f 93       	push	r16
    2eaa:	1f 93       	push	r17


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2eac:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2eae:	9f ef       	ldi	r25, 0xFF	; 255
    2eb0:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2eb2:	83 e6       	ldi	r24, 0x63	; 99
    2eb4:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2eb6:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2eb8:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2eba:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2ebc:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ebe:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ec0:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ec2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2ec4:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2ec6:	45 9a       	sbi	0x08, 5	; 8
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2ec8:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2eca:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    2ecc:	85 e7       	ldi	r24, 0x75	; 117
    2ece:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2ed0:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2ed2:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2ed4:	84 e0       	ldi	r24, 0x04	; 4
    2ed6:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2ed8:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2eda:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2edc:	11 b8       	out	0x01, r1	; 1

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2ede:	2f ef       	ldi	r18, 0xFF	; 255
	PORTA = adr; // output address
    2ee0:	93 e6       	ldi	r25, 0x63	; 99


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2ee2:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2ee4:	4f ef       	ldi	r20, 0xFF	; 255
    2ee6:	21 b9       	out	0x01, r18	; 1
	PORTA = adr; // output address
    2ee8:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2eea:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2eec:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2eee:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2ef0:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ef2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ef4:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ef6:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2ef8:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2efa:	45 9a       	sbi	0x08, 5	; 8
	unsigned int tmp16;
	unsigned int timeout;
  //reset CP220x
  read_CP2200(CP2200_INT0); //clear CP2200 INT0
  write_CP2200(SWRST,4);
  while (!(read_CP2200(CP2200_INT0)& 0x20)); //wait for reset complete
    2efc:	85 ff       	sbrs	r24, 5
    2efe:	f1 cf       	rjmp	.-30     	; 0x2ee2 <Init_CP2000+0x3a>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2f00:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2f02:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2f04:	89 e7       	ldi	r24, 0x79	; 121
    2f06:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2f08:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2f0a:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2f0c:	8e ef       	ldi	r24, 0xFE	; 254
    2f0e:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2f10:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2f12:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2f14:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2f16:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2f18:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2f1a:	98 e7       	ldi	r25, 0x78	; 120
    2f1c:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2f1e:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2f20:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2f22:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    2f24:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2f26:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2f28:	11 b8       	out	0x01, r1	; 1
    2f2a:	20 e5       	ldi	r18, 0x50	; 80
    2f2c:	33 ec       	ldi	r19, 0xC3	; 195
    2f2e:	f9 01       	movw	r30, r18
    2f30:	31 97       	sbiw	r30, 0x01	; 1
    2f32:	f1 f7       	brne	.-4      	; 0x2f30 <Init_CP2000+0x88>


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2f34:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2f36:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2f38:	8f e7       	ldi	r24, 0x7F	; 127
    2f3a:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2f3c:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2f3e:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2f40:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2f42:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2f44:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2f46:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2f48:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2f4a:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2f4c:	45 9a       	sbi	0x08, 5	; 8
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2f4e:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2f50:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2f52:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2f54:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2f56:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2f58:	80 e8       	ldi	r24, 0x80	; 128
    2f5a:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2f5c:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2f5e:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2f60:	11 b8       	out	0x01, r1	; 1
    2f62:	f9 01       	movw	r30, r18
    2f64:	31 97       	sbiw	r30, 0x01	; 1
    2f66:	f1 f7       	brne	.-4      	; 0x2f64 <Init_CP2000+0xbc>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    2f68:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2f6a:	41 b9       	out	0x01, r20	; 1
	PORTA = adr; // output address
    2f6c:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    2f6e:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    2f70:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    2f72:	80 ee       	ldi	r24, 0xE0	; 224
    2f74:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    2f76:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    2f78:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    2f7a:	11 b8       	out	0x01, r1	; 1
    2f7c:	8e ee       	ldi	r24, 0xEE	; 238
    2f7e:	92 e0       	ldi	r25, 0x02	; 2
    2f80:	28 e8       	ldi	r18, 0x88	; 136
    2f82:	33 e1       	ldi	r19, 0x13	; 19
    2f84:	f9 01       	movw	r30, r18
    2f86:	31 97       	sbiw	r30, 0x01	; 1
    2f88:	f1 f7       	brne	.-4      	; 0x2f86 <Init_CP2000+0xde>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2f8a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2f8c:	d9 f7       	brne	.-10     	; 0x2f84 <Init_CP2000+0xdc>
    2f8e:	28 eb       	ldi	r18, 0xB8	; 184
    2f90:	3b e0       	ldi	r19, 0x0B	; 11

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2f92:	7f ef       	ldi	r23, 0xFF	; 255
	PORTA = adr; // output address
    2f94:	6f e7       	ldi	r22, 0x7F	; 127
    2f96:	40 e5       	ldi	r20, 0x50	; 80
    2f98:	53 ec       	ldi	r21, 0xC3	; 195
    2f9a:	05 c0       	rjmp	.+10     	; 0x2fa6 <Init_CP2000+0xfe>
    2f9c:	ca 01       	movw	r24, r20
    2f9e:	01 97       	sbiw	r24, 0x01	; 1
    2fa0:	f1 f7       	brne	.-4      	; 0x2f9e <Init_CP2000+0xf6>
  _delay_ms(75);
	timeout=3000;
  while ((!(read_CP2200(CP2200_INT1)& 0x01)) && (timeout > 0))
	{
		_delay_ms(1);
		timeout--;
    2fa2:	21 50       	subi	r18, 0x01	; 1
    2fa4:	30 40       	sbci	r19, 0x00	; 0


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2fa6:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2fa8:	71 b9       	out	0x01, r23	; 1
	PORTA = adr; // output address
    2faa:	62 b9       	out	0x02, r22	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2fac:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2fae:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2fb0:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2fb2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2fb4:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2fb6:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2fb8:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    2fba:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    2fbc:	45 9a       	sbi	0x08, 5	; 8
  write_CP2200(PHYCN,0x80);
  _delay_ms(1);
  write_CP2200(PHYCN,0xE0);
  _delay_ms(75);
	timeout=3000;
  while ((!(read_CP2200(CP2200_INT1)& 0x01)) && (timeout > 0))
    2fbe:	80 fd       	sbrc	r24, 0
    2fc0:	04 c0       	rjmp	.+8      	; 0x2fca <Init_CP2000+0x122>
    2fc2:	21 15       	cp	r18, r1
    2fc4:	31 05       	cpc	r19, r1
    2fc6:	51 f7       	brne	.-44     	; 0x2f9c <Init_CP2000+0xf4>
    2fc8:	02 c0       	rjmp	.+4      	; 0x2fce <Init_CP2000+0x126>
	{
		_delay_ms(1);
		timeout--;
	}
	if (timeout < 1)
    2fca:	23 2b       	or	r18, r19
    2fcc:	21 f4       	brne	.+8      	; 0x2fd6 <Init_CP2000+0x12e>
	{
		uart_puts_P(PSTR("timeout\r\n"));
    2fce:	82 e9       	ldi	r24, 0x92	; 146
    2fd0:	92 e0       	ldi	r25, 0x02	; 2
    2fd2:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
    2fd6:	28 eb       	ldi	r18, 0xB8	; 184
    2fd8:	3b e0       	ldi	r19, 0x0B	; 11

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    2fda:	7f ef       	ldi	r23, 0xFF	; 255
	PORTA = adr; // output address
    2fdc:	68 e7       	ldi	r22, 0x78	; 120
    2fde:	40 e5       	ldi	r20, 0x50	; 80
    2fe0:	53 ec       	ldi	r21, 0xC3	; 195
    2fe2:	05 c0       	rjmp	.+10     	; 0x2fee <Init_CP2000+0x146>
    2fe4:	ca 01       	movw	r24, r20
    2fe6:	01 97       	sbiw	r24, 0x01	; 1
    2fe8:	f1 f7       	brne	.-4      	; 0x2fe6 <Init_CP2000+0x13e>
	}
	timeout=3000;
  while ((!(read_CP2200(PHYCN)& 0x01)) && (timeout > 0))
	{
		_delay_ms(1);
		timeout--;
    2fea:	21 50       	subi	r18, 0x01	; 1
    2fec:	30 40       	sbci	r19, 0x00	; 0


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    2fee:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    2ff0:	71 b9       	out	0x01, r23	; 1
	PORTA = adr; // output address
    2ff2:	62 b9       	out	0x02, r22	; 2
	PORTC &= ~(1 << 3); // clear ALE
    2ff4:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    2ff6:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    2ff8:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    2ffa:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ffc:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    2ffe:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3000:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    3002:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    3004:	45 9a       	sbi	0x08, 5	; 8
	if (timeout < 1)
	{
		uart_puts_P(PSTR("timeout\r\n"));
	}
	timeout=3000;
  while ((!(read_CP2200(PHYCN)& 0x01)) && (timeout > 0))
    3006:	80 fd       	sbrc	r24, 0
    3008:	04 c0       	rjmp	.+8      	; 0x3012 <Init_CP2000+0x16a>
    300a:	21 15       	cp	r18, r1
    300c:	31 05       	cpc	r19, r1
    300e:	51 f7       	brne	.-44     	; 0x2fe4 <Init_CP2000+0x13c>
    3010:	02 c0       	rjmp	.+4      	; 0x3016 <Init_CP2000+0x16e>
	{
		_delay_ms(1);
		timeout--;
	}
	if (timeout < 1)
    3012:	23 2b       	or	r18, r19
    3014:	21 f4       	brne	.+8      	; 0x301e <Init_CP2000+0x176>
	{
		uart_puts_P(PSTR("timeout\r\n"));
    3016:	88 e8       	ldi	r24, 0x88	; 136
    3018:	92 e0       	ldi	r25, 0x02	; 2
    301a:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
	}
	//MAC INIT
  cpWriteMac(MACCF,0x40B3);
    301e:	63 eb       	ldi	r22, 0xB3	; 179
    3020:	70 e4       	ldi	r23, 0x40	; 64
    3022:	81 e0       	ldi	r24, 0x01	; 1
    3024:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>
  cpWriteMac(IPGT,0x0015);
    3028:	65 e1       	ldi	r22, 0x15	; 21
    302a:	70 e0       	ldi	r23, 0x00	; 0
    302c:	82 e0       	ldi	r24, 0x02	; 2
    302e:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>
  cpWriteMac(IPGR,0x0C12);
    3032:	62 e1       	ldi	r22, 0x12	; 18
    3034:	7c e0       	ldi	r23, 0x0C	; 12
    3036:	83 e0       	ldi	r24, 0x03	; 3
    3038:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>
  cpWriteMac(MAXLEN,0x05EE);
    303c:	6e ee       	ldi	r22, 0xEE	; 238
    303e:	75 e0       	ldi	r23, 0x05	; 5
    3040:	85 e0       	ldi	r24, 0x05	; 5
    3042:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    3046:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3048:	1f ef       	ldi	r17, 0xFF	; 255
    304a:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    304c:	88 e6       	ldi	r24, 0x68	; 104
    304e:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    3050:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3052:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    3054:	8a ef       	ldi	r24, 0xFA	; 250
    3056:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    3058:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    305a:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    305c:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    305e:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3060:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3062:	89 e6       	ldi	r24, 0x69	; 105
    3064:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    3066:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3068:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    306a:	8f e1       	ldi	r24, 0x1F	; 31
    306c:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    306e:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    3070:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    3072:	11 b8       	out	0x01, r1	; 1


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3074:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3076:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3078:	05 e0       	ldi	r16, 0x05	; 5
    307a:	02 b9       	out	0x02, r16	; 2
	PORTC &= ~(1 << 3); // clear ALE
    307c:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    307e:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    3080:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    3082:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3084:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3086:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3088:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    308a:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    308c:	45 9a       	sbi	0x08, 5	; 8
  cpWriteMac(IPGR,0x0C12);
  cpWriteMac(MAXLEN,0x05EE);
  write_CP2200(FLASHADDRL,0xFA);
  write_CP2200(FLASHADDRH,0x1F);
  tmp16 = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
    308e:	90 e0       	ldi	r25, 0x00	; 0


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3090:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3092:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3094:	02 b9       	out	0x02, r16	; 2
	PORTC &= ~(1 << 3); // clear ALE
    3096:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    3098:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    309a:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    309c:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    309e:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    30a0:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    30a2:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // input D0..7
    30a4:	20 b1       	in	r18, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    30a6:	45 9a       	sbi	0x08, 5	; 8
  write_CP2200(FLASHADDRL,0xFA);
  write_CP2200(FLASHADDRH,0x1F);
  tmp16 = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
  tmp16 |=read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD2,tmp16);
    30a8:	72 2f       	mov	r23, r18
    30aa:	60 e0       	ldi	r22, 0x00	; 0
    30ac:	68 2b       	or	r22, r24
    30ae:	79 2b       	or	r23, r25
    30b0:	82 e1       	ldi	r24, 0x12	; 18
    30b2:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    30b6:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    30b8:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    30ba:	02 b9       	out	0x02, r16	; 2
	PORTC &= ~(1 << 3); // clear ALE
    30bc:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    30be:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    30c0:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    30c2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    30c4:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    30c6:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    30c8:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    30ca:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    30cc:	45 9a       	sbi	0x08, 5	; 8
  tmp16 = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
  tmp16 |=read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD2,tmp16);
	tmp16 = 0x0000;
  tmp16 = read_CP2200(FLASHAUTORD);
    30ce:	90 e0       	ldi	r25, 0x00	; 0


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    30d0:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    30d2:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    30d4:	02 b9       	out	0x02, r16	; 2
	PORTC &= ~(1 << 3); // clear ALE
    30d6:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    30d8:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    30da:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    30dc:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    30de:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    30e0:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    30e2:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // input D0..7
    30e4:	20 b1       	in	r18, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    30e6:	45 9a       	sbi	0x08, 5	; 8
  tmp16 |=read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD2,tmp16);
	tmp16 = 0x0000;
  tmp16 = read_CP2200(FLASHAUTORD);
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD1,tmp16);
    30e8:	72 2f       	mov	r23, r18
    30ea:	60 e0       	ldi	r22, 0x00	; 0
    30ec:	68 2b       	or	r22, r24
    30ee:	79 2b       	or	r23, r25
    30f0:	81 e1       	ldi	r24, 0x11	; 17
    30f2:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    30f6:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    30f8:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    30fa:	02 b9       	out	0x02, r16	; 2
	PORTC &= ~(1 << 3); // clear ALE
    30fc:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    30fe:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    3100:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    3102:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3104:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3106:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3108:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    310a:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    310c:	45 9a       	sbi	0x08, 5	; 8
	tmp16 = 0x0000;
  tmp16 = read_CP2200(FLASHAUTORD);
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD1,tmp16);
  tmp = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
    310e:	90 e0       	ldi	r25, 0x00	; 0


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3110:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3112:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3114:	02 b9       	out	0x02, r16	; 2
	PORTC &= ~(1 << 3); // clear ALE
    3116:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    3118:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    311a:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    311c:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    311e:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    3120:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // Waitstate
    3122:	20 b1       	in	r18, 0x00	; 0
	value = PINA; // input D0..7
    3124:	20 b1       	in	r18, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    3126:	45 9a       	sbi	0x08, 5	; 8
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD1,tmp16);
  tmp = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD0,tmp16);
    3128:	72 2f       	mov	r23, r18
    312a:	60 e0       	ldi	r22, 0x00	; 0
    312c:	68 2b       	or	r22, r24
    312e:	79 2b       	or	r23, r25
    3130:	80 e1       	ldi	r24, 0x10	; 16
    3132:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    3136:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3138:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    313a:	80 e7       	ldi	r24, 0x70	; 112
    313c:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    313e:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3140:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    3142:	8c e0       	ldi	r24, 0x0C	; 12
    3144:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    3146:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    3148:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    314a:	11 b8       	out	0x01, r1	; 1
  tmp = 0x0000;
	tmp16 = read_CP2200(FLASHAUTORD);
  tmp16 |= read_CP2200(FLASHAUTORD)<<8;
  cpWriteMac(MACAD0,tmp16);
	write_CP2200(IOPWR,0x0C);
  cpWriteMac(MACCN,0x01);
    314c:	61 e0       	ldi	r22, 0x01	; 1
    314e:	70 e0       	ldi	r23, 0x00	; 0
    3150:	80 e0       	ldi	r24, 0x00	; 0
    3152:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <cpWriteMac>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    3156:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3158:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    315a:	84 e6       	ldi	r24, 0x64	; 100
    315c:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    315e:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3160:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    3162:	83 e0       	ldi	r24, 0x03	; 3
    3164:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    3166:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    3168:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    316a:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    316c:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    316e:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3170:	8d e7       	ldi	r24, 0x7D	; 125
    3172:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    3174:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3176:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    3178:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    317a:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    317c:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    317e:	11 b8       	out	0x01, r1	; 1


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3180:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3182:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3184:	83 e6       	ldi	r24, 0x63	; 99
    3186:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    3188:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    318a:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    318c:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    318e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3190:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3192:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3194:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    3196:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    3198:	45 9a       	sbi	0x08, 5	; 8


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    319a:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    319c:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    319e:	8f e7       	ldi	r24, 0x7F	; 127
    31a0:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    31a2:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    31a4:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    31a6:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    31a8:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    31aa:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    31ac:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    31ae:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    31b0:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    31b2:	45 9a       	sbi	0x08, 5	; 8
  cpWriteMac(MACCN,0x01);
	write_CP2200(INT0EN,0x03);
	write_CP2200(INT1EN,0x00);
	read_CP2200(CP2200_INT0); 
	read_CP2200(CP2200_INT1); 
}
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	08 95       	ret

000031ba <network_device_read>:
	return(packetlen);
}

// ---------------------------------------------
u16_t network_device_read(void)
{
    31ba:	1f 93       	push	r17


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    31bc:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    31be:	1f ef       	ldi	r17, 0xFF	; 255
    31c0:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    31c2:	83 e6       	ldi	r24, 0x63	; 99
    31c4:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    31c6:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    31c8:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    31ca:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    31cc:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    31ce:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    31d0:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    31d2:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    31d4:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    31d6:	45 9a       	sbi	0x08, 5	; 8
// ---------------------------------------------
u16_t network_device_read(void)
{
	u16_t  packetlen=0;
	int cp_bufptr; // Zeiger auf Paket Puffer
	CP2200_status = read_CP2200(CP2200_INT0);
    31d8:	80 93 a4 03 	sts	0x03A4, r24
	if ((CP2200_status & 0x02) == 0x02)
    31dc:	81 ff       	sbrs	r24, 1
    31de:	18 c0       	rjmp	.+48     	; 0x3210 <network_device_read+0x56>
	{
		uart_puts_P(PSTR("CP2200 buffer full\r\n"));	
    31e0:	86 ea       	ldi	r24, 0xA6	; 166
    31e2:	92 e0       	ldi	r25, 0x02	; 2
    31e4:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    31e8:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    31ea:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    31ec:	91 e1       	ldi	r25, 0x11	; 17
    31ee:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    31f0:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    31f2:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    31f4:	81 e0       	ldi	r24, 0x01	; 1
    31f6:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    31f8:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    31fa:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    31fc:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    31fe:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3200:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3202:	92 b9       	out	0x02, r25	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    3204:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3206:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    3208:	12 b8       	out	0x02, r1	; 2
	PORTC |= (1 << nWR); // set WR#
    320a:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    320c:	12 b8       	out	0x02, r1	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    320e:	11 b8       	out	0x01, r1	; 1
	{
		uart_puts_P(PSTR("CP2200 buffer full\r\n"));	
		write_CP2200(RXCN,0x01);
		write_CP2200(RXCN,0x00);
	}
	CP2200_status=0;
    3210:	10 92 a4 03 	sts	0x03A4, r1


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3214:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3216:	1f ef       	ldi	r17, 0xFF	; 255
    3218:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    321a:	8d e1       	ldi	r24, 0x1D	; 29
    321c:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    321e:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    3220:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    3222:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    3224:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3226:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3228:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    322a:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    322c:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    322e:	45 9a       	sbi	0x08, 5	; 8
		write_CP2200(RXCN,0x01);
		write_CP2200(RXCN,0x00);
	}
	CP2200_status=0;
	// Paket im Empfangspuffer?
	if (((read_CP2200(CPINFOH) &0x80) != 0) && (read_CP2200(CPINFOL) &0x80) != 0)
    3230:	87 ff       	sbrs	r24, 7
    3232:	39 c0       	rjmp	.+114    	; 0x32a6 <network_device_read+0xec>


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3234:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3236:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3238:	8e e1       	ldi	r24, 0x1E	; 30
    323a:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    323c:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    323e:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    3240:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    3242:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3244:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3246:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3248:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    324a:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    324c:	45 9a       	sbi	0x08, 5	; 8
		write_CP2200(RXCN,0x01);
		write_CP2200(RXCN,0x00);
	}
	CP2200_status=0;
	// Paket im Empfangspuffer?
	if (((read_CP2200(CPINFOH) &0x80) != 0) && (read_CP2200(CPINFOL) &0x80) != 0)
    324e:	87 ff       	sbrs	r24, 7
    3250:	2a c0       	rjmp	.+84     	; 0x32a6 <network_device_read+0xec>
	{
		PORTB |= (1<<PB0); // set PB0 = LED OFF
    3252:	28 9a       	sbi	0x05, 0	; 5


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3254:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3256:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3258:	87 e1       	ldi	r24, 0x17	; 23
    325a:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    325c:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    325e:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    3260:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    3262:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3264:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3266:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3268:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    326a:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    326c:	45 9a       	sbi	0x08, 5	; 8


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    326e:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3270:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3272:	88 e1       	ldi	r24, 0x18	; 24
    3274:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << 3); // clear ALE
    3276:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    3278:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    327a:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    327c:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    327e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3280:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3282:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    3284:	80 b1       	in	r24, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    3286:	45 9a       	sbi	0x08, 5	; 8
		// Zeiger auf Paket Puffer merken
		cp_bufptr = read_CP2200(RXFIFOHEADH);
		cp_bufptr = cp_bufptr << 8;
		cp_bufptr |= read_CP2200(RXFIFOHEADL);
	
		packetlen = CP2200_ReadPacket();
    3288:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <CP2200_ReadPacket>
    328c:	9c 01       	movw	r18, r24
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    328e:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3290:	11 b9       	out	0x01, r17	; 1
	PORTA = adr; // output address
    3292:	81 e1       	ldi	r24, 0x11	; 17
    3294:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    3296:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    3298:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    329a:	86 e0       	ldi	r24, 0x06	; 6
    329c:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    329e:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    32a0:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    32a2:	11 b8       	out	0x01, r1	; 1
    32a4:	02 c0       	rjmp	.+4      	; 0x32aa <network_device_read+0xf0>
    32a6:	20 e0       	ldi	r18, 0x00	; 0
    32a8:	30 e0       	ldi	r19, 0x00	; 0
		write_CP2200(RXCN,0x06); // discharge package

		//	write_CP2200(RXCN,0x04); // discharge package
	}
	return(packetlen);
}
    32aa:	c9 01       	movw	r24, r18
    32ac:	1f 91       	pop	r17
    32ae:	08 95       	ret

000032b0 <network_device_init>:
}


// ---------------------------------------------
void network_device_init(void)
{
    32b0:	cf 92       	push	r12
    32b2:	df 92       	push	r13
    32b4:	ef 92       	push	r14
    32b6:	ff 92       	push	r15
    32b8:	0f 93       	push	r16
    32ba:	1f 93       	push	r17
    32bc:	df 93       	push	r29
    32be:	cf 93       	push	r28
    32c0:	cd b7       	in	r28, 0x3d	; 61
    32c2:	de b7       	in	r29, 0x3e	; 62
    32c4:	60 97       	sbiw	r28, 0x10	; 16
    32c6:	0f b6       	in	r0, 0x3f	; 63
    32c8:	f8 94       	cli
    32ca:	de bf       	out	0x3e, r29	; 62
    32cc:	0f be       	out	0x3f, r0	; 63
    32ce:	cd bf       	out	0x3d, r28	; 61
	char hexstr[10];
	uip_ipaddr_t ipaddr;
	struct uip_eth_addr eaddr;
	unsigned int i;
	
	Init_CP2000();
    32d0:	0e 94 54 17 	call	0x2ea8	; 0x2ea8 <Init_CP2000>
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    32d4:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    32d6:	9f ef       	ldi	r25, 0xFF	; 255
    32d8:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    32da:	88 e6       	ldi	r24, 0x68	; 104
    32dc:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    32de:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    32e0:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    32e2:	8a ef       	ldi	r24, 0xFA	; 250
    32e4:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    32e6:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    32e8:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    32ea:	11 b8       	out	0x01, r1	; 1
}


void write_CP2200(int adr, char value)
{
	PORTC |= (1 << ALE); // set ALE 
    32ec:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    32ee:	91 b9       	out	0x01, r25	; 1
	PORTA = adr; // output address
    32f0:	89 e6       	ldi	r24, 0x69	; 105
    32f2:	82 b9       	out	0x02, r24	; 2
	PORTC &= ~(1 << ALE); // clear ALE
    32f4:	43 98       	cbi	0x08, 3	; 8
	PORTC &= ~(1 << nWR); // clear WR#
    32f6:	44 98       	cbi	0x08, 4	; 8
	PORTA = value; // D0..7 output 
    32f8:	8f e1       	ldi	r24, 0x1F	; 31
    32fa:	82 b9       	out	0x02, r24	; 2
	PORTC |= (1 << nWR); // set WR#
    32fc:	44 9a       	sbi	0x08, 4	; 8
	PORTA = value;
    32fe:	82 b9       	out	0x02, r24	; 2
	DDRA = 0x00; // AD0..7 Tri-state
    3300:	11 b8       	out	0x01, r1	; 1
	Init_CP2000();
	
	// own mac address (get from CP2200 flash memory)
	write_CP2200(FLASHADDRL,0xFA);
	write_CP2200(FLASHADDRH,0x1F);
	uart_puts_P(PSTR("\n\rMAC:"));
    3302:	8f e9       	ldi	r24, 0x9F	; 159
    3304:	92 e0       	ldi	r25, 0x02	; 2
    3306:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
    330a:	8e 01       	movw	r16, r28
    330c:	0f 5f       	subi	r16, 0xFF	; 255
    330e:	1f 4f       	sbci	r17, 0xFF	; 255

char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
	DDRA = 0xFF; // AD0..7 output
    3310:	cc 24       	eor	r12, r12
    3312:	ca 94       	dec	r12
	PORTA = adr; // output address
    3314:	25 e0       	ldi	r18, 0x05	; 5
    3316:	d2 2e       	mov	r13, r18
	write_CP2200(FLASHADDRH,0x1F);
	uart_puts_P(PSTR("\n\rMAC:"));
	for (i=0;i<6;i++)
	{
		eaddr.addr[i]=read_CP2200(FLASHAUTORD); // mac address from CP2200 
		itohex(hexstr,eaddr.addr[i] , 2);
    3318:	97 e0       	ldi	r25, 0x07	; 7
    331a:	e9 2e       	mov	r14, r25
    331c:	f1 2c       	mov	r15, r1
    331e:	ec 0e       	add	r14, r28
    3320:	fd 1e       	adc	r15, r29


char read_CP2200(int adr)
{
	char value;
	PORTC |= (1 << ALE); // set ALE
    3322:	43 9a       	sbi	0x08, 3	; 8
	DDRA = 0xFF; // AD0..7 output
    3324:	c1 b8       	out	0x01, r12	; 1
	PORTA = adr; // output address
    3326:	d2 b8       	out	0x02, r13	; 2
	PORTC &= ~(1 << 3); // clear ALE
    3328:	43 98       	cbi	0x08, 3	; 8
	DDRA = 0x00; // AD0..7 input
    332a:	11 b8       	out	0x01, r1	; 1
	PORTC &= ~(1 << 5); // clear RD#
    332c:	45 98       	cbi	0x08, 5	; 8
	value = PINA; // Waitstate
    332e:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3330:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3332:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // Waitstate
    3334:	80 b1       	in	r24, 0x00	; 0
	value = PINA; // input D0..7
    3336:	60 b1       	in	r22, 0x00	; 0
	PORTC |= (1 << nRD); // set RD#
    3338:	45 9a       	sbi	0x08, 5	; 8
	write_CP2200(FLASHADDRL,0xFA);
	write_CP2200(FLASHADDRH,0x1F);
	uart_puts_P(PSTR("\n\rMAC:"));
	for (i=0;i<6;i++)
	{
		eaddr.addr[i]=read_CP2200(FLASHAUTORD); // mac address from CP2200 
    333a:	f8 01       	movw	r30, r16
    333c:	61 93       	st	Z+, r22
    333e:	8f 01       	movw	r16, r30
		itohex(hexstr,eaddr.addr[i] , 2);
    3340:	42 e0       	ldi	r20, 0x02	; 2
    3342:	70 e0       	ldi	r23, 0x00	; 0
    3344:	c7 01       	movw	r24, r14
    3346:	0e 94 6c 10 	call	0x20d8	; 0x20d8 <itohex>
		uart_puts(hexstr);
    334a:	c7 01       	movw	r24, r14
    334c:	0e 94 4a 10 	call	0x2094	; 0x2094 <uart_puts>
	
	// own mac address (get from CP2200 flash memory)
	write_CP2200(FLASHADDRL,0xFA);
	write_CP2200(FLASHADDRH,0x1F);
	uart_puts_P(PSTR("\n\rMAC:"));
	for (i=0;i<6;i++)
    3350:	0e 15       	cp	r16, r14
    3352:	1f 05       	cpc	r17, r15
    3354:	31 f7       	brne	.-52     	; 0x3322 <network_device_init+0x72>
		eaddr.addr[i]=read_CP2200(FLASHAUTORD); // mac address from CP2200 
		itohex(hexstr,eaddr.addr[i] , 2);
		uart_puts(hexstr);
		
	}
	uart_puts_P(PSTR("\n\r"));
    3356:	8c e9       	ldi	r24, 0x9C	; 156
    3358:	92 e0       	ldi	r25, 0x02	; 2
    335a:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
	// set mac address of this modules 
	uip_setethaddr(eaddr);
    335e:	89 81       	ldd	r24, Y+1	; 0x01
    3360:	80 93 bd 03 	sts	0x03BD, r24
    3364:	8a 81       	ldd	r24, Y+2	; 0x02
    3366:	80 93 be 03 	sts	0x03BE, r24
    336a:	8b 81       	ldd	r24, Y+3	; 0x03
    336c:	80 93 bf 03 	sts	0x03BF, r24
    3370:	8c 81       	ldd	r24, Y+4	; 0x04
    3372:	80 93 c0 03 	sts	0x03C0, r24
    3376:	8d 81       	ldd	r24, Y+5	; 0x05
    3378:	80 93 c1 03 	sts	0x03C1, r24
    337c:	8e 81       	ldd	r24, Y+6	; 0x06
    337e:	80 93 c2 03 	sts	0x03C2, r24
	
	// set netmask
	uip_ipaddr(ipaddr, 255,255,255,0);
	uip_setnetmask(ipaddr);
    3382:	8f ef       	ldi	r24, 0xFF	; 255
    3384:	9f ef       	ldi	r25, 0xFF	; 255
    3386:	90 93 f9 05 	sts	0x05F9, r25
    338a:	80 93 f8 05 	sts	0x05F8, r24
    338e:	8f ef       	ldi	r24, 0xFF	; 255
    3390:	90 e0       	ldi	r25, 0x00	; 0
    3392:	90 93 fb 05 	sts	0x05FB, r25
    3396:	80 93 fa 05 	sts	0x05FA, r24
	
	// set ip address of this module
	uip_ipaddr(ipaddr, 192,168,178,14);
	uip_sethostaddr(ipaddr);
    339a:	20 ec       	ldi	r18, 0xC0	; 192
    339c:	38 ea       	ldi	r19, 0xA8	; 168
    339e:	30 93 fd 05 	sts	0x05FD, r19
    33a2:	20 93 fc 05 	sts	0x05FC, r18
    33a6:	82 eb       	ldi	r24, 0xB2	; 178
    33a8:	9e e0       	ldi	r25, 0x0E	; 14
    33aa:	90 93 ff 05 	sts	0x05FF, r25
    33ae:	80 93 fe 05 	sts	0x05FE, r24
	
	// set gateway address (default router address)
	uip_ipaddr(ipaddr, 192,168,178,1);
	uip_setdraddr(ipaddr);
    33b2:	30 93 c9 05 	sts	0x05C9, r19
    33b6:	20 93 c8 05 	sts	0x05C8, r18
    33ba:	82 eb       	ldi	r24, 0xB2	; 178
    33bc:	91 e0       	ldi	r25, 0x01	; 1
    33be:	90 93 cb 05 	sts	0x05CB, r25
    33c2:	80 93 ca 05 	sts	0x05CA, r24
	
}
    33c6:	60 96       	adiw	r28, 0x10	; 16
    33c8:	0f b6       	in	r0, 0x3f	; 63
    33ca:	f8 94       	cli
    33cc:	de bf       	out	0x3e, r29	; 62
    33ce:	0f be       	out	0x3f, r0	; 63
    33d0:	cd bf       	out	0x3d, r28	; 61
    33d2:	cf 91       	pop	r28
    33d4:	df 91       	pop	r29
    33d6:	1f 91       	pop	r17
    33d8:	0f 91       	pop	r16
    33da:	ff 90       	pop	r15
    33dc:	ef 90       	pop	r14
    33de:	df 90       	pop	r13
    33e0:	cf 90       	pop	r12
    33e2:	08 95       	ret

000033e4 <httpd_init>:
 *             This function initializes the web server and should be
 *             called at system boot-up.
 */
void
httpd_init(void)
{
    33e4:	80 e0       	ldi	r24, 0x00	; 0
    33e6:	90 e5       	ldi	r25, 0x50	; 80
    33e8:	0e 94 e3 25 	call	0x4bc6	; 0x4bc6 <uip_listen>
  uip_listen(HTONS(80));
}
    33ec:	08 95       	ret

000033ee <send_headers>:
  PT_END(&s->scriptpt);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_headers(struct httpd_state *s, const char *statushdr))
{
    33ee:	0f 93       	push	r16
    33f0:	1f 93       	push	r17
    33f2:	cf 93       	push	r28
    33f4:	df 93       	push	r29
    33f6:	8c 01       	movw	r16, r24
    33f8:	eb 01       	movw	r28, r22
  char *ptr;
  PSOCK_BEGIN(&s->sout);
    33fa:	fc 01       	movw	r30, r24
    33fc:	86 89       	ldd	r24, Z+22	; 0x16
    33fe:	97 89       	ldd	r25, Z+23	; 0x17
    3400:	89 3e       	cpi	r24, 0xE9	; 233
    3402:	91 05       	cpc	r25, r1
    3404:	09 f4       	brne	.+2      	; 0x3408 <send_headers+0x1a>
    3406:	7d c0       	rjmp	.+250    	; 0x3502 <send_headers+0x114>
    3408:	8a 3e       	cpi	r24, 0xEA	; 234
    340a:	91 05       	cpc	r25, r1
    340c:	88 f4       	brcc	.+34     	; 0x3430 <send_headers+0x42>
    340e:	8f 3d       	cpi	r24, 0xDF	; 223
    3410:	91 05       	cpc	r25, r1
    3412:	41 f1       	breq	.+80     	; 0x3464 <send_headers+0x76>
    3414:	80 3e       	cpi	r24, 0xE0	; 224
    3416:	91 05       	cpc	r25, r1
    3418:	18 f4       	brcc	.+6      	; 0x3420 <send_headers+0x32>
    341a:	89 2b       	or	r24, r25
    341c:	f1 f0       	breq	.+60     	; 0x345a <send_headers+0x6c>
    341e:	cd c0       	rjmp	.+410    	; 0x35ba <send_headers+0x1cc>
    3420:	84 3e       	cpi	r24, 0xE4	; 228
    3422:	91 05       	cpc	r25, r1
    3424:	d1 f1       	breq	.+116    	; 0x349a <send_headers+0xac>
    3426:	87 3e       	cpi	r24, 0xE7	; 231
    3428:	91 05       	cpc	r25, r1
    342a:	09 f0       	breq	.+2      	; 0x342e <send_headers+0x40>
    342c:	c6 c0       	rjmp	.+396    	; 0x35ba <send_headers+0x1cc>
    342e:	53 c0       	rjmp	.+166    	; 0x34d6 <send_headers+0xe8>
    3430:	8d 3e       	cpi	r24, 0xED	; 237
    3432:	91 05       	cpc	r25, r1
    3434:	09 f4       	brne	.+2      	; 0x3438 <send_headers+0x4a>
    3436:	91 c0       	rjmp	.+290    	; 0x355a <send_headers+0x16c>
    3438:	8e 3e       	cpi	r24, 0xEE	; 238
    343a:	91 05       	cpc	r25, r1
    343c:	28 f4       	brcc	.+10     	; 0x3448 <send_headers+0x5a>
    343e:	8b 3e       	cpi	r24, 0xEB	; 235
    3440:	91 05       	cpc	r25, r1
    3442:	09 f0       	breq	.+2      	; 0x3446 <send_headers+0x58>
    3444:	ba c0       	rjmp	.+372    	; 0x35ba <send_headers+0x1cc>
    3446:	73 c0       	rjmp	.+230    	; 0x352e <send_headers+0x140>
    3448:	8f 3e       	cpi	r24, 0xEF	; 239
    344a:	91 05       	cpc	r25, r1
    344c:	09 f4       	brne	.+2      	; 0x3450 <send_headers+0x62>
    344e:	9b c0       	rjmp	.+310    	; 0x3586 <send_headers+0x198>
    3450:	81 3f       	cpi	r24, 0xF1	; 241
    3452:	91 05       	cpc	r25, r1
    3454:	09 f0       	breq	.+2      	; 0x3458 <send_headers+0x6a>
    3456:	b1 c0       	rjmp	.+354    	; 0x35ba <send_headers+0x1cc>
    3458:	a3 c0       	rjmp	.+326    	; 0x35a0 <send_headers+0x1b2>
  PSOCK_SEND_STR_P(&s->sout, statushdr);
    345a:	8f ed       	ldi	r24, 0xDF	; 223
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	f8 01       	movw	r30, r16
    3460:	97 8b       	std	Z+23, r25	; 0x17
    3462:	86 8b       	std	Z+22, r24	; 0x16
    3464:	ce 01       	movw	r24, r28
    3466:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    346a:	ac 01       	movw	r20, r24
    346c:	be 01       	movw	r22, r28
    346e:	c8 01       	movw	r24, r16
    3470:	46 96       	adiw	r24, 0x16	; 22
    3472:	0e 94 79 23 	call	0x46f2	; 0x46f2 <psock_send_P>
    3476:	88 23       	and	r24, r24
    3478:	09 f4       	brne	.+2      	; 0x347c <send_headers+0x8e>
    347a:	a4 c0       	rjmp	.+328    	; 0x35c4 <send_headers+0x1d6>
	
  ptr = strrchr(s->filename, ISO_period);
    347c:	6e e2       	ldi	r22, 0x2E	; 46
    347e:	70 e0       	ldi	r23, 0x00	; 0
    3480:	c8 01       	movw	r24, r16
    3482:	80 59       	subi	r24, 0x90	; 144
    3484:	9f 4f       	sbci	r25, 0xFF	; 255
    3486:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <strrchr>
    348a:	ec 01       	movw	r28, r24
	
	if(ptr == NULL) {
    348c:	00 97       	sbiw	r24, 0x00	; 0
    348e:	69 f4       	brne	.+26     	; 0x34aa <send_headers+0xbc>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_binary);
    3490:	84 ee       	ldi	r24, 0xE4	; 228
    3492:	90 e0       	ldi	r25, 0x00	; 0
    3494:	f8 01       	movw	r30, r16
    3496:	97 8b       	std	Z+23, r25	; 0x17
    3498:	86 8b       	std	Z+22, r24	; 0x16
    349a:	85 e4       	ldi	r24, 0x45	; 69
    349c:	9f e1       	ldi	r25, 0x1F	; 31
    349e:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    34a2:	ac 01       	movw	r20, r24
    34a4:	65 e4       	ldi	r22, 0x45	; 69
    34a6:	7f e1       	ldi	r23, 0x1F	; 31
    34a8:	82 c0       	rjmp	.+260    	; 0x35ae <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_html, 5) == 0 ||
    34aa:	45 e0       	ldi	r20, 0x05	; 5
    34ac:	50 e0       	ldi	r21, 0x00	; 0
    34ae:	60 e7       	ldi	r22, 0x70	; 112
    34b0:	7f e1       	ldi	r23, 0x1F	; 31
    34b2:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    34b6:	89 2b       	or	r24, r25
    34b8:	49 f0       	breq	.+18     	; 0x34cc <send_headers+0xde>
    34ba:	46 e0       	ldi	r20, 0x06	; 6
    34bc:	50 e0       	ldi	r21, 0x00	; 0
    34be:	66 e7       	ldi	r22, 0x76	; 118
    34c0:	7f e1       	ldi	r23, 0x1F	; 31
    34c2:	ce 01       	movw	r24, r28
    34c4:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    34c8:	89 2b       	or	r24, r25
    34ca:	69 f4       	brne	.+26     	; 0x34e6 <send_headers+0xf8>
	    strncmp_P(ptr, http_shtml, 6) == 0) {
	  PSOCK_SEND_STR_P(&s->sout, http_content_type_html);
    34cc:	87 ee       	ldi	r24, 0xE7	; 231
    34ce:	90 e0       	ldi	r25, 0x00	; 0
    34d0:	f8 01       	movw	r30, r16
    34d2:	97 8b       	std	Z+23, r25	; 0x17
    34d4:	86 8b       	std	Z+22, r24	; 0x16
    34d6:	8d e9       	ldi	r24, 0x9D	; 157
    34d8:	9e e1       	ldi	r25, 0x1E	; 30
    34da:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    34de:	ac 01       	movw	r20, r24
    34e0:	6d e9       	ldi	r22, 0x9D	; 157
    34e2:	7e e1       	ldi	r23, 0x1E	; 30
    34e4:	64 c0       	rjmp	.+200    	; 0x35ae <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_css, 4) == 0) {
    34e6:	44 e0       	ldi	r20, 0x04	; 4
    34e8:	50 e0       	ldi	r21, 0x00	; 0
    34ea:	62 e8       	ldi	r22, 0x82	; 130
    34ec:	7f e1       	ldi	r23, 0x1F	; 31
    34ee:	ce 01       	movw	r24, r28
    34f0:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    34f4:	89 2b       	or	r24, r25
    34f6:	69 f4       	brne	.+26     	; 0x3512 <send_headers+0x124>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_css);
    34f8:	89 ee       	ldi	r24, 0xE9	; 233
    34fa:	90 e0       	ldi	r25, 0x00	; 0
    34fc:	f8 01       	movw	r30, r16
    34fe:	97 8b       	std	Z+23, r25	; 0x17
    3500:	86 8b       	std	Z+22, r24	; 0x16
    3502:	89 eb       	ldi	r24, 0xB9	; 185
    3504:	9e e1       	ldi	r25, 0x1E	; 30
    3506:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    350a:	ac 01       	movw	r20, r24
    350c:	69 eb       	ldi	r22, 0xB9	; 185
    350e:	7e e1       	ldi	r23, 0x1E	; 30
    3510:	4e c0       	rjmp	.+156    	; 0x35ae <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_png, 4) == 0) {
    3512:	44 e0       	ldi	r20, 0x04	; 4
    3514:	50 e0       	ldi	r21, 0x00	; 0
    3516:	67 e8       	ldi	r22, 0x87	; 135
    3518:	7f e1       	ldi	r23, 0x1F	; 31
    351a:	ce 01       	movw	r24, r28
    351c:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    3520:	89 2b       	or	r24, r25
    3522:	69 f4       	brne	.+26     	; 0x353e <send_headers+0x150>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_png);
    3524:	8b ee       	ldi	r24, 0xEB	; 235
    3526:	90 e0       	ldi	r25, 0x00	; 0
    3528:	f8 01       	movw	r30, r16
    352a:	97 8b       	std	Z+23, r25	; 0x17
    352c:	86 8b       	std	Z+22, r24	; 0x16
    352e:	80 ef       	ldi	r24, 0xF0	; 240
    3530:	9e e1       	ldi	r25, 0x1E	; 30
    3532:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    3536:	ac 01       	movw	r20, r24
    3538:	60 ef       	ldi	r22, 0xF0	; 240
    353a:	7e e1       	ldi	r23, 0x1E	; 30
    353c:	38 c0       	rjmp	.+112    	; 0x35ae <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_gif, 4) == 0) {
    353e:	44 e0       	ldi	r20, 0x04	; 4
    3540:	50 e0       	ldi	r21, 0x00	; 0
    3542:	6c e8       	ldi	r22, 0x8C	; 140
    3544:	7f e1       	ldi	r23, 0x1F	; 31
    3546:	ce 01       	movw	r24, r28
    3548:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    354c:	89 2b       	or	r24, r25
    354e:	69 f4       	brne	.+26     	; 0x356a <send_headers+0x17c>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_gif);
    3550:	8d ee       	ldi	r24, 0xED	; 237
    3552:	90 e0       	ldi	r25, 0x00	; 0
    3554:	f8 01       	movw	r30, r16
    3556:	97 8b       	std	Z+23, r25	; 0x17
    3558:	86 8b       	std	Z+22, r24	; 0x16
    355a:	8c e0       	ldi	r24, 0x0C	; 12
    355c:	9f e1       	ldi	r25, 0x1F	; 31
    355e:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    3562:	ac 01       	movw	r20, r24
    3564:	6c e0       	ldi	r22, 0x0C	; 12
    3566:	7f e1       	ldi	r23, 0x1F	; 31
    3568:	22 c0       	rjmp	.+68     	; 0x35ae <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_jpg, 4) == 0) {
    356a:	44 e0       	ldi	r20, 0x04	; 4
    356c:	50 e0       	ldi	r21, 0x00	; 0
    356e:	61 e9       	ldi	r22, 0x91	; 145
    3570:	7f e1       	ldi	r23, 0x1F	; 31
    3572:	ce 01       	movw	r24, r28
    3574:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    3578:	89 2b       	or	r24, r25
    357a:	69 f4       	brne	.+26     	; 0x3596 <send_headers+0x1a8>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_jpg);
    357c:	8f ee       	ldi	r24, 0xEF	; 239
    357e:	90 e0       	ldi	r25, 0x00	; 0
    3580:	f8 01       	movw	r30, r16
    3582:	97 8b       	std	Z+23, r25	; 0x17
    3584:	86 8b       	std	Z+22, r24	; 0x16
    3586:	88 e2       	ldi	r24, 0x28	; 40
    3588:	9f e1       	ldi	r25, 0x1F	; 31
    358a:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    358e:	ac 01       	movw	r20, r24
    3590:	68 e2       	ldi	r22, 0x28	; 40
    3592:	7f e1       	ldi	r23, 0x1F	; 31
    3594:	0c c0       	rjmp	.+24     	; 0x35ae <send_headers+0x1c0>
  } else {
    PSOCK_SEND_STR_P(&s->sout, http_content_type_plain);
    3596:	81 ef       	ldi	r24, 0xF1	; 241
    3598:	90 e0       	ldi	r25, 0x00	; 0
    359a:	f8 01       	movw	r30, r16
    359c:	97 8b       	std	Z+23, r25	; 0x17
    359e:	86 8b       	std	Z+22, r24	; 0x16
    35a0:	80 e8       	ldi	r24, 0x80	; 128
    35a2:	9e e1       	ldi	r25, 0x1E	; 30
    35a4:	0e 94 76 32 	call	0x64ec	; 0x64ec <strlen_P>
    35a8:	ac 01       	movw	r20, r24
    35aa:	60 e8       	ldi	r22, 0x80	; 128
    35ac:	7e e1       	ldi	r23, 0x1E	; 30
    35ae:	c8 01       	movw	r24, r16
    35b0:	46 96       	adiw	r24, 0x16	; 22
    35b2:	0e 94 79 23 	call	0x46f2	; 0x46f2 <psock_send_P>
    35b6:	88 23       	and	r24, r24
    35b8:	29 f0       	breq	.+10     	; 0x35c4 <send_headers+0x1d6>
  }
  PSOCK_END(&s->sout);
    35ba:	f8 01       	movw	r30, r16
    35bc:	17 8a       	std	Z+23, r1	; 0x17
    35be:	16 8a       	std	Z+22, r1	; 0x16
    35c0:	82 e0       	ldi	r24, 0x02	; 2
    35c2:	01 c0       	rjmp	.+2      	; 0x35c6 <send_headers+0x1d8>
    35c4:	80 e0       	ldi	r24, 0x00	; 0
}
    35c6:	df 91       	pop	r29
    35c8:	cf 91       	pop	r28
    35ca:	1f 91       	pop	r17
    35cc:	0f 91       	pop	r16
    35ce:	08 95       	ret

000035d0 <send_file>:
  return s->len;
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_file(struct httpd_state *s))
{
    35d0:	cf 93       	push	r28
    35d2:	df 93       	push	r29
    35d4:	ec 01       	movw	r28, r24
	PSOCK_BEGIN(&s->sout);
    35d6:	8e 89       	ldd	r24, Y+22	; 0x16
    35d8:	9f 89       	ldd	r25, Y+23	; 0x17
    35da:	00 97       	sbiw	r24, 0x00	; 0
    35dc:	21 f0       	breq	.+8      	; 0x35e6 <send_file+0x16>
    35de:	83 37       	cpi	r24, 0x73	; 115
    35e0:	91 05       	cpc	r25, r1
    35e2:	49 f5       	brne	.+82     	; 0x3636 <send_file+0x66>
    35e4:	04 c0       	rjmp	.+8      	; 0x35ee <send_file+0x1e>
	//uart_puts_P(PSTR("\n\r\x1B[1mSend File\x1B[0m"));
	do {
    PSOCK_GENERATOR_SEND(&s->sout, generate_part_of_file, s);
    35e6:	83 e7       	ldi	r24, 0x73	; 115
    35e8:	90 e0       	ldi	r25, 0x00	; 0
    35ea:	9f 8b       	std	Y+23, r25	; 0x17
    35ec:	8e 8b       	std	Y+22, r24	; 0x16
    35ee:	ae 01       	movw	r20, r28
    35f0:	68 ee       	ldi	r22, 0xE8	; 232
    35f2:	7d e1       	ldi	r23, 0x1D	; 29
    35f4:	ce 01       	movw	r24, r28
    35f6:	46 96       	adiw	r24, 0x16	; 22
    35f8:	0e 94 ab 22 	call	0x4556	; 0x4556 <psock_generator_send>
    35fc:	88 23       	and	r24, r24
    35fe:	f1 f0       	breq	.+60     	; 0x363c <send_file+0x6c>
    s->file.len -= s->len;
    3600:	fe 01       	movw	r30, r28
    3602:	e9 57       	subi	r30, 0x79	; 121
    3604:	ff 4f       	sbci	r31, 0xFF	; 255
    3606:	c7 57       	subi	r28, 0x77	; 119
    3608:	df 4f       	sbci	r29, 0xFF	; 255
    360a:	20 81       	ld	r18, Z
    360c:	31 81       	ldd	r19, Z+1	; 0x01
    360e:	48 81       	ld	r20, Y
    3610:	59 81       	ldd	r21, Y+1	; 0x01
    3612:	c9 58       	subi	r28, 0x89	; 137
    3614:	d0 40       	sbci	r29, 0x00	; 0
    3616:	24 1b       	sub	r18, r20
    3618:	35 0b       	sbc	r19, r21
    361a:	31 83       	std	Z+1, r19	; 0x01
    361c:	20 83       	st	Z, r18
    s->file.data += s->len;
    361e:	fe 01       	movw	r30, r28
    3620:	eb 57       	subi	r30, 0x7B	; 123
    3622:	ff 4f       	sbci	r31, 0xFF	; 255
    3624:	80 81       	ld	r24, Z
    3626:	91 81       	ldd	r25, Z+1	; 0x01
    3628:	84 0f       	add	r24, r20
    362a:	95 1f       	adc	r25, r21
    362c:	91 83       	std	Z+1, r25	; 0x01
    362e:	80 83       	st	Z, r24
  } while(s->file.len > 0);
    3630:	12 16       	cp	r1, r18
    3632:	13 06       	cpc	r1, r19
    3634:	c4 f2       	brlt	.-80     	; 0x35e6 <send_file+0x16>
	PSOCK_END(&s->sout);
    3636:	1f 8a       	std	Y+23, r1	; 0x17
    3638:	1e 8a       	std	Y+22, r1	; 0x16
    363a:	82 e0       	ldi	r24, 0x02	; 2
}
    363c:	df 91       	pop	r29
    363e:	cf 91       	pop	r28
    3640:	08 95       	ret

00003642 <handle_connection>:
  PSOCK_END(&s->sin);
}
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
    3642:	ef 92       	push	r14
    3644:	ff 92       	push	r15
    3646:	0f 93       	push	r16
    3648:	1f 93       	push	r17
    364a:	cf 93       	push	r28
    364c:	df 93       	push	r29
    364e:	ec 01       	movw	r28, r24
static
PT_THREAD(handle_input(struct httpd_state *s))
{
	unsigned int i;
	
	PSOCK_BEGIN(&s->sin);
    3650:	89 81       	ldd	r24, Y+1	; 0x01
    3652:	9a 81       	ldd	r25, Y+2	; 0x02
    3654:	21 e0       	ldi	r18, 0x01	; 1
    3656:	8e 31       	cpi	r24, 0x1E	; 30
    3658:	92 07       	cpc	r25, r18
    365a:	a1 f0       	breq	.+40     	; 0x3684 <handle_connection+0x42>
    365c:	a1 e0       	ldi	r26, 0x01	; 1
    365e:	8f 31       	cpi	r24, 0x1F	; 31
    3660:	9a 07       	cpc	r25, r26
    3662:	18 f4       	brcc	.+6      	; 0x366a <handle_connection+0x28>
    3664:	89 2b       	or	r24, r25
    3666:	51 f0       	breq	.+20     	; 0x367c <handle_connection+0x3a>
    3668:	bf c0       	rjmp	.+382    	; 0x37e8 <handle_connection+0x1a6>
    366a:	b1 e0       	ldi	r27, 0x01	; 1
    366c:	84 32       	cpi	r24, 0x24	; 36
    366e:	9b 07       	cpc	r25, r27
    3670:	f9 f0       	breq	.+62     	; 0x36b0 <handle_connection+0x6e>
    3672:	87 53       	subi	r24, 0x37	; 55
    3674:	91 40       	sbci	r25, 0x01	; 1
    3676:	09 f0       	breq	.+2      	; 0x367a <handle_connection+0x38>
    3678:	b7 c0       	rjmp	.+366    	; 0x37e8 <handle_connection+0x1a6>
    367a:	54 c0       	rjmp	.+168    	; 0x3724 <handle_connection+0xe2>
	
  PSOCK_READTO(&s->sin, ISO_space);
    367c:	8e e1       	ldi	r24, 0x1E	; 30
    367e:	91 e0       	ldi	r25, 0x01	; 1
    3680:	9a 83       	std	Y+2, r25	; 0x02
    3682:	89 83       	std	Y+1, r24	; 0x01
    3684:	60 e2       	ldi	r22, 0x20	; 32
    3686:	ce 01       	movw	r24, r28
    3688:	01 96       	adiw	r24, 0x01	; 1
    368a:	0e 94 03 21 	call	0x4206	; 0x4206 <psock_readto>
    368e:	88 23       	and	r24, r24
    3690:	09 f4       	brne	.+2      	; 0x3694 <handle_connection+0x52>
    3692:	ac c0       	rjmp	.+344    	; 0x37ec <handle_connection+0x1aa>

  if(strncmp_P(s->inputbuf, http_get, 4) != 0) 
    3694:	44 e0       	ldi	r20, 0x04	; 4
    3696:	50 e0       	ldi	r21, 0x00	; 0
    3698:	6d e6       	ldi	r22, 0x6D	; 109
    369a:	7d e1       	ldi	r23, 0x1D	; 29
    369c:	ce 01       	movw	r24, r28
    369e:	8f 96       	adiw	r24, 0x2f	; 47
    36a0:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    36a4:	89 2b       	or	r24, r25
    36a6:	89 f4       	brne	.+34     	; 0x36ca <handle_connection+0x88>
	{
    PSOCK_CLOSE_EXIT(&s->sin);
  }
  PSOCK_READTO(&s->sin, ISO_space);
    36a8:	84 e2       	ldi	r24, 0x24	; 36
    36aa:	91 e0       	ldi	r25, 0x01	; 1
    36ac:	9a 83       	std	Y+2, r25	; 0x02
    36ae:	89 83       	std	Y+1, r24	; 0x01
    36b0:	8e 01       	movw	r16, r28
    36b2:	0f 5f       	subi	r16, 0xFF	; 255
    36b4:	1f 4f       	sbci	r17, 0xFF	; 255
    36b6:	60 e2       	ldi	r22, 0x20	; 32
    36b8:	c8 01       	movw	r24, r16
    36ba:	0e 94 03 21 	call	0x4206	; 0x4206 <psock_readto>
    36be:	88 23       	and	r24, r24
    36c0:	09 f4       	brne	.+2      	; 0x36c4 <handle_connection+0x82>
    36c2:	94 c0       	rjmp	.+296    	; 0x37ec <handle_connection+0x1aa>
	
  if(s->inputbuf[0] != ISO_slash) 
    36c4:	8f a5       	ldd	r24, Y+47	; 0x2f
    36c6:	8f 32       	cpi	r24, 0x2F	; 47
    36c8:	21 f0       	breq	.+8      	; 0x36d2 <handle_connection+0x90>
	{
    PSOCK_CLOSE_EXIT(&s->sin);
    36ca:	80 e1       	ldi	r24, 0x10	; 16
    36cc:	80 93 65 04 	sts	0x0465, r24
    36d0:	8b c0       	rjmp	.+278    	; 0x37e8 <handle_connection+0x1a6>
  }
	
  if(s->inputbuf[1] == ISO_space) 
    36d2:	88 a9       	ldd	r24, Y+48	; 0x30
    36d4:	20 e7       	ldi	r18, 0x70	; 112
    36d6:	e2 2e       	mov	r14, r18
    36d8:	f1 2c       	mov	r15, r1
    36da:	ec 0e       	add	r14, r28
    36dc:	fd 1e       	adc	r15, r29
    36de:	80 32       	cpi	r24, 0x20	; 32
    36e0:	41 f4       	brne	.+16     	; 0x36f2 <handle_connection+0xb0>
	{
    strncpy_P(s->filename, http_index_html, sizeof(s->filename));
    36e2:	44 e1       	ldi	r20, 0x14	; 20
    36e4:	50 e0       	ldi	r21, 0x00	; 0
    36e6:	62 eb       	ldi	r22, 0xB2	; 178
    36e8:	7d e1       	ldi	r23, 0x1D	; 29
    36ea:	c7 01       	movw	r24, r14
    36ec:	0e 94 8d 32 	call	0x651a	; 0x651a <strncpy_P>
    36f0:	0f c0       	rjmp	.+30     	; 0x3710 <handle_connection+0xce>
  } 
	else 
	{
    s->inputbuf[PSOCK_DATALEN(&s->sin) - 1] = 0;
    36f2:	c8 01       	movw	r24, r16
    36f4:	0e 94 e5 20 	call	0x41ca	; 0x41ca <psock_datalen>
    36f8:	fe 01       	movw	r30, r28
    36fa:	e8 0f       	add	r30, r24
    36fc:	f9 1f       	adc	r31, r25
    36fe:	16 a6       	std	Z+46, r1	; 0x2e
    strncpy(s->filename, &s->inputbuf[0], sizeof(s->filename));
    3700:	be 01       	movw	r22, r28
    3702:	61 5d       	subi	r22, 0xD1	; 209
    3704:	7f 4f       	sbci	r23, 0xFF	; 255
    3706:	44 e1       	ldi	r20, 0x14	; 20
    3708:	50 e0       	ldi	r21, 0x00	; 0
    370a:	c7 01       	movw	r24, r14
    370c:	0e 94 c5 32 	call	0x658a	; 0x658a <strncpy>
  }
	s->state = STATE_OUTPUT;
    3710:	cc 57       	subi	r28, 0x7C	; 124
    3712:	df 4f       	sbci	r29, 0xFF	; 255
    3714:	81 e0       	ldi	r24, 0x01	; 1
    3716:	88 83       	st	Y, r24
    3718:	c4 58       	subi	r28, 0x84	; 132
    371a:	d0 40       	sbci	r29, 0x00	; 0
	while(1) 
	{
    PSOCK_READTO(&s->sin, ISO_nl);
    371c:	87 e3       	ldi	r24, 0x37	; 55
    371e:	91 e0       	ldi	r25, 0x01	; 1
    3720:	9a 83       	std	Y+2, r25	; 0x02
    3722:	89 83       	std	Y+1, r24	; 0x01
    3724:	7e 01       	movw	r14, r28
    3726:	08 94       	sec
    3728:	e1 1c       	adc	r14, r1
    372a:	f1 1c       	adc	r15, r1
    372c:	6a e0       	ldi	r22, 0x0A	; 10
    372e:	c7 01       	movw	r24, r14
    3730:	0e 94 03 21 	call	0x4206	; 0x4206 <psock_readto>
    3734:	88 23       	and	r24, r24
    3736:	09 f4       	brne	.+2      	; 0x373a <handle_connection+0xf8>
    3738:	59 c0       	rjmp	.+178    	; 0x37ec <handle_connection+0x1aa>
	  if(strncmp_P(s->inputbuf, http_referer, 8) == 0) 
    373a:	8e 01       	movw	r16, r28
    373c:	01 5d       	subi	r16, 0xD1	; 209
    373e:	1f 4f       	sbci	r17, 0xFF	; 255
    3740:	48 e0       	ldi	r20, 0x08	; 8
    3742:	50 e0       	ldi	r21, 0x00	; 0
    3744:	68 ec       	ldi	r22, 0xC8	; 200
    3746:	7d e1       	ldi	r23, 0x1D	; 29
    3748:	c8 01       	movw	r24, r16
    374a:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    374e:	89 2b       	or	r24, r25
    3750:	29 f7       	brne	.-54     	; 0x371c <handle_connection+0xda>
		{
      s->inputbuf[PSOCK_DATALEN(&s->sin) - 2] = 0;
    3752:	c7 01       	movw	r24, r14
    3754:	0e 94 e5 20 	call	0x41ca	; 0x41ca <psock_datalen>
    3758:	fe 01       	movw	r30, r28
    375a:	e8 0f       	add	r30, r24
    375c:	f9 1f       	adc	r31, r25
    375e:	15 a6       	std	Z+45, r1	; 0x2d
			//uart_puts(">>http_referer<<\r\n");
			uart_puts(s->inputbuf);
    3760:	c8 01       	movw	r24, r16
    3762:	0e 94 4a 10 	call	0x2094	; 0x2094 <uart_puts>
			uart_puts("\r\n");
    3766:	81 e0       	ldi	r24, 0x01	; 1
    3768:	91 e0       	ldi	r25, 0x01	; 1
    376a:	0e 94 4a 10 	call	0x2094	; 0x2094 <uart_puts>
    376e:	f8 01       	movw	r30, r16
    3770:	00 e0       	ldi	r16, 0x00	; 0
    3772:	10 e0       	ldi	r17, 0x00	; 0
    3774:	02 c0       	rjmp	.+4      	; 0x377a <handle_connection+0x138>
      /*      httpd_log(&s->inputbuf[9]);*/
			// check URL for '?'
			for (i=0;((s->inputbuf[i]!=0) && (s->inputbuf[i]!='?'));i++);
    3776:	0f 5f       	subi	r16, 0xFF	; 255
    3778:	1f 4f       	sbci	r17, 0xFF	; 255
    377a:	80 81       	ld	r24, Z
    377c:	88 23       	and	r24, r24
    377e:	71 f2       	breq	.-100    	; 0x371c <handle_connection+0xda>
    3780:	31 96       	adiw	r30, 0x01	; 1
    3782:	8f 33       	cpi	r24, 0x3F	; 63
    3784:	c1 f7       	brne	.-16     	; 0x3776 <handle_connection+0x134>
    3786:	ba c1       	rjmp	.+884    	; 0x3afc <handle_connection+0x4ba>
			{
			uart_puts_P(PSTR("found ?\r\n"));
				// compare path / file
				if(strncmp(s->inputbuf+i-strlen("io.shtml"), "io.shtml", strlen("io.shtml")) == 0)
				{
					uart_puts_P(PSTR("found io.shtml\r\n"));
    3788:	8b ec       	ldi	r24, 0xCB	; 203
    378a:	92 e0       	ldi	r25, 0x02	; 2
    378c:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
					// compare query
					if(strncmp(s->inputbuf+i+1, "LED1=1", strlen("LED1=1")) == 0)
    3790:	78 01       	movw	r14, r16
    3792:	08 94       	sec
    3794:	e1 1c       	adc	r14, r1
    3796:	f1 1c       	adc	r15, r1
    3798:	00 5d       	subi	r16, 0xD0	; 208
    379a:	1f 4f       	sbci	r17, 0xFF	; 255
    379c:	46 e0       	ldi	r20, 0x06	; 6
    379e:	50 e0       	ldi	r21, 0x00	; 0
    37a0:	64 e0       	ldi	r22, 0x04	; 4
    37a2:	71 e0       	ldi	r23, 0x01	; 1
    37a4:	ce 01       	movw	r24, r28
    37a6:	80 0f       	add	r24, r16
    37a8:	91 1f       	adc	r25, r17
    37aa:	0e 94 b7 32 	call	0x656e	; 0x656e <strncmp>
    37ae:	00 97       	sbiw	r24, 0x00	; 0
    37b0:	29 f4       	brne	.+10     	; 0x37bc <handle_connection+0x17a>
					{
						// LED1=1
						PORTC &= ~(1<<PC0); // clear PC0 = LED ON
    37b2:	40 98       	cbi	0x08, 0	; 8
						
						uart_puts_P(PSTR("LED=1\r\n"));
    37b4:	83 ec       	ldi	r24, 0xC3	; 195
    37b6:	92 e0       	ldi	r25, 0x02	; 2
    37b8:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>

					}
					if(strncmp(s->inputbuf+i+1, "LED1=0",strlen("LED1=0")) == 0)
    37bc:	8f e2       	ldi	r24, 0x2F	; 47
    37be:	90 e0       	ldi	r25, 0x00	; 0
    37c0:	e8 0e       	add	r14, r24
    37c2:	f9 1e       	adc	r15, r25
    37c4:	46 e0       	ldi	r20, 0x06	; 6
    37c6:	50 e0       	ldi	r21, 0x00	; 0
    37c8:	6b e0       	ldi	r22, 0x0B	; 11
    37ca:	71 e0       	ldi	r23, 0x01	; 1
    37cc:	ce 01       	movw	r24, r28
    37ce:	8e 0d       	add	r24, r14
    37d0:	9f 1d       	adc	r25, r15
    37d2:	0e 94 b7 32 	call	0x656e	; 0x656e <strncmp>
    37d6:	00 97       	sbiw	r24, 0x00	; 0
    37d8:	09 f0       	breq	.+2      	; 0x37dc <handle_connection+0x19a>
    37da:	a0 cf       	rjmp	.-192    	; 0x371c <handle_connection+0xda>
					{
						// LED1=0
						PORTC |= (1<<PC0); // set PC0 = LED OFF
    37dc:	40 9a       	sbi	0x08, 0	; 8
						uart_puts_P(PSTR("LED=0\r\n"));
    37de:	8b eb       	ldi	r24, 0xBB	; 187
    37e0:	92 e0       	ldi	r25, 0x02	; 2
    37e2:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
    37e6:	9a cf       	rjmp	.-204    	; 0x371c <handle_connection+0xda>
				}
			}
    }
  }
  
  PSOCK_END(&s->sin);
    37e8:	1a 82       	std	Y+2, r1	; 0x02
    37ea:	19 82       	std	Y+1, r1	; 0x01
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
  handle_input(s);
  if(s->state == STATE_OUTPUT) {
    37ec:	cc 57       	subi	r28, 0x7C	; 124
    37ee:	df 4f       	sbci	r29, 0xFF	; 255
    37f0:	88 81       	ld	r24, Y
    37f2:	c4 58       	subi	r28, 0x84	; 132
    37f4:	d0 40       	sbci	r29, 0x00	; 0
    37f6:	81 30       	cpi	r24, 0x01	; 1
    37f8:	09 f0       	breq	.+2      	; 0x37fc <handle_connection+0x1ba>
    37fa:	92 c1       	rjmp	.+804    	; 0x3b20 <handle_connection+0x4de>
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_output(struct httpd_state *s))
{
	char *ptr;
  PT_BEGIN(&s->outputpt);
    37fc:	8b a5       	ldd	r24, Y+43	; 0x2b
    37fe:	9c a5       	ldd	r25, Y+44	; 0x2c
    3800:	a1 e0       	ldi	r26, 0x01	; 1
    3802:	81 30       	cpi	r24, 0x01	; 1
    3804:	9a 07       	cpc	r25, r26
    3806:	09 f4       	brne	.+2      	; 0x380a <handle_connection+0x1c8>
    3808:	6e c1       	rjmp	.+732    	; 0x3ae6 <handle_connection+0x4a4>
    380a:	b1 e0       	ldi	r27, 0x01	; 1
    380c:	82 30       	cpi	r24, 0x02	; 2
    380e:	9b 07       	cpc	r25, r27
    3810:	38 f4       	brcc	.+14     	; 0x3820 <handle_connection+0x1de>
    3812:	00 97       	sbiw	r24, 0x00	; 0
    3814:	a1 f0       	breq	.+40     	; 0x383e <handle_connection+0x1fc>
    3816:	80 50       	subi	r24, 0x00	; 0
    3818:	91 40       	sbci	r25, 0x01	; 1
    381a:	09 f0       	breq	.+2      	; 0x381e <handle_connection+0x1dc>
    381c:	6c c1       	rjmp	.+728    	; 0x3af6 <handle_connection+0x4b4>
    381e:	2b c0       	rjmp	.+86     	; 0x3876 <handle_connection+0x234>
    3820:	f1 e0       	ldi	r31, 0x01	; 1
    3822:	8c 30       	cpi	r24, 0x0C	; 12
    3824:	9f 07       	cpc	r25, r31
    3826:	09 f4       	brne	.+2      	; 0x382a <handle_connection+0x1e8>
    3828:	56 c0       	rjmp	.+172    	; 0x38d6 <handle_connection+0x294>
    382a:	21 e0       	ldi	r18, 0x01	; 1
    382c:	80 31       	cpi	r24, 0x10	; 16
    382e:	92 07       	cpc	r25, r18
    3830:	09 f4       	brne	.+2      	; 0x3834 <handle_connection+0x1f2>
    3832:	59 c1       	rjmp	.+690    	; 0x3ae6 <handle_connection+0x4a4>
    3834:	85 50       	subi	r24, 0x05	; 5
    3836:	91 40       	sbci	r25, 0x01	; 1
    3838:	09 f0       	breq	.+2      	; 0x383c <handle_connection+0x1fa>
    383a:	5d c1       	rjmp	.+698    	; 0x3af6 <handle_connection+0x4b4>
    383c:	2b c0       	rjmp	.+86     	; 0x3894 <handle_connection+0x252>
	//uart_puts_P(PSTR("\n\r\x1B[1mHandle Output\x1B[0m"));
  if(!httpd_fs_open(s->filename, &s->file))
    383e:	8e 01       	movw	r16, r28
    3840:	0b 57       	subi	r16, 0x7B	; 123
    3842:	1f 4f       	sbci	r17, 0xFF	; 255
    3844:	90 e7       	ldi	r25, 0x70	; 112
    3846:	e9 2e       	mov	r14, r25
    3848:	f1 2c       	mov	r15, r1
    384a:	ec 0e       	add	r14, r28
    384c:	fd 1e       	adc	r15, r29
    384e:	b8 01       	movw	r22, r16
    3850:	c7 01       	movw	r24, r14
    3852:	0e 94 08 20 	call	0x4010	; 0x4010 <httpd_fs_open>
    3856:	89 2b       	or	r24, r25
    3858:	c9 f4       	brne	.+50     	; 0x388c <handle_connection+0x24a>
	{
    httpd_fs_open_P(http_404_html, &s->file);
    385a:	b8 01       	movw	r22, r16
    385c:	8e eb       	ldi	r24, 0xBE	; 190
    385e:	9d e1       	ldi	r25, 0x1D	; 29
    3860:	0e 94 54 20 	call	0x40a8	; 0x40a8 <httpd_fs_open_P>
    strcpy_P(s->filename, http_404_html);
    3864:	6e eb       	ldi	r22, 0xBE	; 190
    3866:	7d e1       	ldi	r23, 0x1D	; 29
    3868:	c7 01       	movw	r24, r14
    386a:	0e 94 6f 32 	call	0x64de	; 0x64de <strcpy_P>
    PT_WAIT_THREAD(&s->outputpt,send_headers(s,http_header_404));
    386e:	80 e0       	ldi	r24, 0x00	; 0
    3870:	91 e0       	ldi	r25, 0x01	; 1
    3872:	9c a7       	std	Y+44, r25	; 0x2c
    3874:	8b a7       	std	Y+43, r24	; 0x2b
    3876:	65 e2       	ldi	r22, 0x25	; 37
    3878:	7e e1       	ldi	r23, 0x1E	; 30
    387a:	ce 01       	movw	r24, r28
    387c:	0e 94 f7 19 	call	0x33ee	; 0x33ee <send_headers>
    3880:	88 23       	and	r24, r24
    3882:	09 f4       	brne	.+2      	; 0x3886 <handle_connection+0x244>
    3884:	4d c1       	rjmp	.+666    	; 0x3b20 <handle_connection+0x4de>
    PT_WAIT_THREAD(&s->outputpt,send_file(s));
    3886:	81 e0       	ldi	r24, 0x01	; 1
    3888:	91 e0       	ldi	r25, 0x01	; 1
    388a:	2b c1       	rjmp	.+598    	; 0x3ae2 <handle_connection+0x4a0>
  } 
	else 
	{
    PT_WAIT_THREAD(&s->outputpt,send_headers(s,http_header_200));
    388c:	85 e0       	ldi	r24, 0x05	; 5
    388e:	91 e0       	ldi	r25, 0x01	; 1
    3890:	9c a7       	std	Y+44, r25	; 0x2c
    3892:	8b a7       	std	Y+43, r24	; 0x2b
    3894:	61 ed       	ldi	r22, 0xD1	; 209
    3896:	7d e1       	ldi	r23, 0x1D	; 29
    3898:	ce 01       	movw	r24, r28
    389a:	0e 94 f7 19 	call	0x33ee	; 0x33ee <send_headers>
    389e:	88 23       	and	r24, r24
    38a0:	09 f4       	brne	.+2      	; 0x38a4 <handle_connection+0x262>
    38a2:	3e c1       	rjmp	.+636    	; 0x3b20 <handle_connection+0x4de>
		
		// s->filename = RAM
    ptr = strchr(s->filename, ISO_period);
    38a4:	6e e2       	ldi	r22, 0x2E	; 46
    38a6:	70 e0       	ldi	r23, 0x00	; 0
    38a8:	ce 01       	movw	r24, r28
    38aa:	80 59       	subi	r24, 0x90	; 144
    38ac:	9f 4f       	sbci	r25, 0xFF	; 255
    38ae:	0e 94 ac 32 	call	0x6558	; 0x6558 <strchr>
    if(ptr != NULL && strncmp_P(ptr, http_shtml, 6) == 0) 
    38b2:	00 97       	sbiw	r24, 0x00	; 0
    38b4:	09 f4       	brne	.+2      	; 0x38b8 <handle_connection+0x276>
    38b6:	13 c1       	rjmp	.+550    	; 0x3ade <handle_connection+0x49c>
    38b8:	46 e0       	ldi	r20, 0x06	; 6
    38ba:	50 e0       	ldi	r21, 0x00	; 0
    38bc:	66 e7       	ldi	r22, 0x76	; 118
    38be:	7f e1       	ldi	r23, 0x1F	; 31
    38c0:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    38c4:	89 2b       	or	r24, r25
    38c6:	09 f0       	breq	.+2      	; 0x38ca <handle_connection+0x288>
    38c8:	0a c1       	rjmp	.+532    	; 0x3ade <handle_connection+0x49c>
		{
      PT_INIT(&s->scriptpt);
    38ca:	1e a6       	std	Y+46, r1	; 0x2e
    38cc:	1d a6       	std	Y+45, r1	; 0x2d
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    38ce:	8c e0       	ldi	r24, 0x0C	; 12
    38d0:	91 e0       	ldi	r25, 0x01	; 1
    38d2:	9c a7       	std	Y+44, r25	; 0x2c
    38d4:	8b a7       	std	Y+43, r24	; 0x2b
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
	PT_BEGIN(&s->scriptpt);
    38d6:	8d a5       	ldd	r24, Y+45	; 0x2d
    38d8:	9e a5       	ldd	r25, Y+46	; 0x2e
    38da:	8f 3a       	cpi	r24, 0xAF	; 175
    38dc:	91 05       	cpc	r25, r1
    38de:	09 f4       	brne	.+2      	; 0x38e2 <handle_connection+0x2a0>
    38e0:	3d c0       	rjmp	.+122    	; 0x395c <handle_connection+0x31a>
    38e2:	80 3b       	cpi	r24, 0xB0	; 176
    38e4:	91 05       	cpc	r25, r1
    38e6:	18 f4       	brcc	.+6      	; 0x38ee <handle_connection+0x2ac>
    38e8:	89 2b       	or	r24, r25
    38ea:	51 f0       	breq	.+20     	; 0x3900 <handle_connection+0x2be>
    38ec:	f5 c0       	rjmp	.+490    	; 0x3ad8 <handle_connection+0x496>
    38ee:	82 3b       	cpi	r24, 0xB2	; 178
    38f0:	91 05       	cpc	r25, r1
    38f2:	09 f4       	brne	.+2      	; 0x38f6 <handle_connection+0x2b4>
    38f4:	3b c0       	rjmp	.+118    	; 0x396c <handle_connection+0x32a>
    38f6:	81 3d       	cpi	r24, 0xD1	; 209
    38f8:	91 05       	cpc	r25, r1
    38fa:	09 f0       	breq	.+2      	; 0x38fe <handle_connection+0x2bc>
    38fc:	ed c0       	rjmp	.+474    	; 0x3ad8 <handle_connection+0x496>
    38fe:	ac c0       	rjmp	.+344    	; 0x3a58 <handle_connection+0x416>
	uart_puts_P(PSTR("\r\nSCRIPT"));
    3900:	86 ee       	ldi	r24, 0xE6	; 230
    3902:	92 e0       	ldi	r25, 0x02	; 2
    3904:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
    3908:	dd c0       	rjmp	.+442    	; 0x3ac4 <handle_connection+0x482>
	while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if((pgm_read_byte(s->file.data) == ISO_percent) &&
    390a:	de 01       	movw	r26, r28
    390c:	ab 57       	subi	r26, 0x7B	; 123
    390e:	bf 4f       	sbci	r27, 0xFF	; 255
    3910:	ed 91       	ld	r30, X+
    3912:	fc 91       	ld	r31, X
    3914:	11 97       	sbiw	r26, 0x01	; 1
    3916:	84 91       	lpm	r24, Z+
    3918:	85 32       	cpi	r24, 0x25	; 37
    391a:	09 f0       	breq	.+2      	; 0x391e <handle_connection+0x2dc>
    391c:	5d c0       	rjmp	.+186    	; 0x39d8 <handle_connection+0x396>
       (pgm_read_byte(s->file.data + 1) == ISO_bang)) {
    391e:	31 96       	adiw	r30, 0x01	; 1
    3920:	84 91       	lpm	r24, Z+
    3922:	31 97       	sbiw	r30, 0x01	; 1
	PT_BEGIN(&s->scriptpt);
	uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if((pgm_read_byte(s->file.data) == ISO_percent) &&
    3924:	81 32       	cpi	r24, 0x21	; 33
    3926:	09 f0       	breq	.+2      	; 0x392a <handle_connection+0x2e8>
    3928:	57 c0       	rjmp	.+174    	; 0x39d8 <handle_connection+0x396>
       (pgm_read_byte(s->file.data + 1) == ISO_bang)) {
      s->scriptptr = s->file.data + 3;
    392a:	c5 57       	subi	r28, 0x75	; 117
    392c:	df 4f       	sbci	r29, 0xFF	; 255
    392e:	33 96       	adiw	r30, 0x03	; 3
    3930:	e9 93       	st	Y+, r30
    3932:	f9 93       	st	Y+, r31
      s->scriptlen = s->file.len - 3;
    3934:	23 50       	subi	r18, 0x03	; 3
    3936:	30 40       	sbci	r19, 0x00	; 0
    3938:	39 83       	std	Y+1, r19	; 0x01
    393a:	28 83       	st	Y, r18
    393c:	cd 58       	subi	r28, 0x8D	; 141
    393e:	d0 40       	sbci	r29, 0x00	; 0
			if(pgm_read_byte(s->scriptptr - 1) == ISO_colon) {
    3940:	31 97       	sbiw	r30, 0x01	; 1
    3942:	84 91       	lpm	r24, Z+
    3944:	32 97       	sbiw	r30, 0x02	; 2
    3946:	8a 33       	cpi	r24, 0x3A	; 58
    3948:	69 f4       	brne	.+26     	; 0x3964 <handle_connection+0x322>

				httpd_fs_open_P(s->scriptptr + 1, &s->file);
    394a:	bd 01       	movw	r22, r26
    394c:	cf 01       	movw	r24, r30
    394e:	04 96       	adiw	r24, 0x04	; 4
    3950:	0e 94 54 20 	call	0x40a8	; 0x40a8 <httpd_fs_open_P>
			PT_WAIT_THREAD(&s->scriptpt, send_file(s));
    3954:	8f ea       	ldi	r24, 0xAF	; 175
    3956:	90 e0       	ldi	r25, 0x00	; 0
    3958:	9e a7       	std	Y+46, r25	; 0x2e
    395a:	8d a7       	std	Y+45, r24	; 0x2d
    395c:	ce 01       	movw	r24, r28
    395e:	0e 94 e8 1a 	call	0x35d0	; 0x35d0 <send_file>
    3962:	12 c0       	rjmp	.+36     	; 0x3988 <handle_connection+0x346>
			
      } else {
				PT_WAIT_THREAD(&s->scriptpt, httpd_cgi(s->scriptptr)(s, s->scriptptr));
    3964:	82 eb       	ldi	r24, 0xB2	; 178
    3966:	90 e0       	ldi	r25, 0x00	; 0
    3968:	9e a7       	std	Y+46, r25	; 0x2e
    396a:	8d a7       	std	Y+45, r24	; 0x2d
    396c:	8e 01       	movw	r16, r28
    396e:	05 57       	subi	r16, 0x75	; 117
    3970:	1f 4f       	sbci	r17, 0xFF	; 255
    3972:	f8 01       	movw	r30, r16
    3974:	80 81       	ld	r24, Z
    3976:	91 81       	ldd	r25, Z+1	; 0x01
    3978:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <httpd_cgi>
    397c:	fc 01       	movw	r30, r24
    397e:	d8 01       	movw	r26, r16
    3980:	6d 91       	ld	r22, X+
    3982:	7c 91       	ld	r23, X
    3984:	ce 01       	movw	r24, r28
    3986:	09 95       	icall
    3988:	88 23       	and	r24, r24
    398a:	09 f4       	brne	.+2      	; 0x398e <handle_connection+0x34c>
    398c:	c9 c0       	rjmp	.+402    	; 0x3b20 <handle_connection+0x4de>
/*---------------------------------------------------------------------------*/
static void
next_scriptstate(struct httpd_state *s)
{
  char *p;
  p = (char *) strchr_P(s->scriptptr, ISO_nl) + 1;
    398e:	8b e8       	ldi	r24, 0x8B	; 139
    3990:	e8 2e       	mov	r14, r24
    3992:	f1 2c       	mov	r15, r1
    3994:	ec 0e       	add	r14, r28
    3996:	fd 1e       	adc	r15, r29
    3998:	f7 01       	movw	r30, r14
    399a:	00 81       	ld	r16, Z
    399c:	11 81       	ldd	r17, Z+1	; 0x01
    399e:	6a e0       	ldi	r22, 0x0A	; 10
    39a0:	70 e0       	ldi	r23, 0x00	; 0
    39a2:	c8 01       	movw	r24, r16
    39a4:	0e 94 5b 32 	call	0x64b6	; 0x64b6 <strchr_P>
    39a8:	01 96       	adiw	r24, 0x01	; 1
  s->scriptlen -= (unsigned short)(p - s->scriptptr);
    39aa:	fe 01       	movw	r30, r28
    39ac:	e3 57       	subi	r30, 0x73	; 115
    39ae:	ff 4f       	sbci	r31, 0xFF	; 255
    39b0:	08 1b       	sub	r16, r24
    39b2:	19 0b       	sbc	r17, r25
    39b4:	20 81       	ld	r18, Z
    39b6:	31 81       	ldd	r19, Z+1	; 0x01
    39b8:	02 0f       	add	r16, r18
    39ba:	13 1f       	adc	r17, r19
    39bc:	11 83       	std	Z+1, r17	; 0x01
    39be:	00 83       	st	Z, r16
  s->scriptptr = p;
    39c0:	d7 01       	movw	r26, r14
    39c2:	8d 93       	st	X+, r24
    39c4:	9c 93       	st	X, r25
      }
      next_scriptstate(s);
      
      /* The script is over, so we reset the pointers and continue
			sending the rest of the file. */
      s->file.data = s->scriptptr;
    39c6:	cb 57       	subi	r28, 0x7B	; 123
    39c8:	df 4f       	sbci	r29, 0xFF	; 255
    39ca:	89 93       	st	Y+, r24
    39cc:	99 93       	st	Y+, r25
      s->file.len = s->scriptlen;
    39ce:	19 83       	std	Y+1, r17	; 0x01
    39d0:	08 83       	st	Y, r16
    39d2:	c7 58       	subi	r28, 0x87	; 135
    39d4:	d0 40       	sbci	r29, 0x00	; 0
    39d6:	76 c0       	rjmp	.+236    	; 0x3ac4 <handle_connection+0x482>
    } else {
      /* See if we find the start of script marker in the block of HTML
	 to be sent. */
			//uart_puts_P(PSTR("\n\r\x1B[1mscript marker\x1B[0m"));
      if(s->file.len > uip_mss()) {
    39d8:	e0 90 68 04 	lds	r14, 0x0468
    39dc:	f0 90 69 04 	lds	r15, 0x0469
    39e0:	f7 01       	movw	r30, r14
    39e2:	82 89       	ldd	r24, Z+18	; 0x12
    39e4:	93 89       	ldd	r25, Z+19	; 0x13
    39e6:	fe 01       	movw	r30, r28
    39e8:	e7 57       	subi	r30, 0x77	; 119
    39ea:	ff 4f       	sbci	r31, 0xFF	; 255
    39ec:	82 17       	cp	r24, r18
    39ee:	93 07       	cpc	r25, r19
    39f0:	18 f4       	brcc	.+6      	; 0x39f8 <handle_connection+0x3b6>
				s->len = uip_mss();
    39f2:	91 83       	std	Z+1, r25	; 0x01
    39f4:	80 83       	st	Z, r24
    39f6:	02 c0       	rjmp	.+4      	; 0x39fc <handle_connection+0x3ba>
      } else {
				s->len = s->file.len;
    39f8:	31 83       	std	Z+1, r19	; 0x01
    39fa:	20 83       	st	Z, r18
      }

			if(pgm_read_byte(s->file.data) == ISO_percent) {
    39fc:	cb 57       	subi	r28, 0x7B	; 123
    39fe:	df 4f       	sbci	r29, 0xFF	; 255
    3a00:	08 81       	ld	r16, Y
    3a02:	19 81       	ldd	r17, Y+1	; 0x01
    3a04:	c5 58       	subi	r28, 0x85	; 133
    3a06:	d0 40       	sbci	r29, 0x00	; 0
    3a08:	f8 01       	movw	r30, r16
    3a0a:	84 91       	lpm	r24, Z+
    3a0c:	85 32       	cpi	r24, 0x25	; 37
    3a0e:	29 f4       	brne	.+10     	; 0x3a1a <handle_connection+0x3d8>
				ptr = (char *) strchr_P(s->file.data + 1, ISO_percent);
    3a10:	65 e2       	ldi	r22, 0x25	; 37
    3a12:	70 e0       	ldi	r23, 0x00	; 0
    3a14:	c8 01       	movw	r24, r16
    3a16:	01 96       	adiw	r24, 0x01	; 1
    3a18:	03 c0       	rjmp	.+6      	; 0x3a20 <handle_connection+0x3de>
      } else {
				ptr = (char *) strchr_P(s->file.data, ISO_percent); 
    3a1a:	65 e2       	ldi	r22, 0x25	; 37
    3a1c:	70 e0       	ldi	r23, 0x00	; 0
    3a1e:	c8 01       	movw	r24, r16
    3a20:	0e 94 5b 32 	call	0x64b6	; 0x64b6 <strchr_P>
      }
      if(ptr != NULL && ptr != s->file.data) {
    3a24:	00 97       	sbiw	r24, 0x00	; 0
    3a26:	a1 f0       	breq	.+40     	; 0x3a50 <handle_connection+0x40e>
    3a28:	80 17       	cp	r24, r16
    3a2a:	91 07       	cpc	r25, r17
    3a2c:	89 f0       	breq	.+34     	; 0x3a50 <handle_connection+0x40e>
				s->len = (int)(ptr - s->file.data);
    3a2e:	80 1b       	sub	r24, r16
    3a30:	91 0b       	sbc	r25, r17
    3a32:	fe 01       	movw	r30, r28
    3a34:	e7 57       	subi	r30, 0x77	; 119
    3a36:	ff 4f       	sbci	r31, 0xFF	; 255
    3a38:	91 83       	std	Z+1, r25	; 0x01
    3a3a:	80 83       	st	Z, r24
				if(s->len >= uip_mss()) {
    3a3c:	d7 01       	movw	r26, r14
    3a3e:	52 96       	adiw	r26, 0x12	; 18
    3a40:	2d 91       	ld	r18, X+
    3a42:	3c 91       	ld	r19, X
    3a44:	53 97       	sbiw	r26, 0x13	; 19
    3a46:	82 17       	cp	r24, r18
    3a48:	93 07       	cpc	r25, r19
    3a4a:	10 f0       	brcs	.+4      	; 0x3a50 <handle_connection+0x40e>
					s->len = uip_mss();
    3a4c:	31 83       	std	Z+1, r19	; 0x01
    3a4e:	20 83       	st	Z, r18
				}
      }
			//uart_puts_P(PSTR("\n\r\x1B[1msend ???\x1B[0m"));
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
    3a50:	81 ed       	ldi	r24, 0xD1	; 209
    3a52:	90 e0       	ldi	r25, 0x00	; 0
    3a54:	9e a7       	std	Y+46, r25	; 0x2e
    3a56:	8d a7       	std	Y+45, r24	; 0x2d
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_part_of_file(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sout);
    3a58:	8e 89       	ldd	r24, Y+22	; 0x16
    3a5a:	9f 89       	ldd	r25, Y+23	; 0x17
    3a5c:	00 97       	sbiw	r24, 0x00	; 0
    3a5e:	21 f0       	breq	.+8      	; 0x3a68 <handle_connection+0x426>
    3a60:	87 38       	cpi	r24, 0x87	; 135
    3a62:	91 05       	cpc	r25, r1
    3a64:	a9 f4       	brne	.+42     	; 0x3a90 <handle_connection+0x44e>
    3a66:	04 c0       	rjmp	.+8      	; 0x3a70 <handle_connection+0x42e>
		if (((char*)uip_appdata)[t]!='\n')
			//	uart_putc( ((unsigned char *)uip_appdata)[t]);
			uart_putc(pgm_read_byte((char *)(s->file.data+t)));
	uart_puts_P(PSTR("<<<\r\n"));*/
  
  PSOCK_SEND_P(&s->sout, s->file.data, s->len);
    3a68:	87 e8       	ldi	r24, 0x87	; 135
    3a6a:	90 e0       	ldi	r25, 0x00	; 0
    3a6c:	9f 8b       	std	Y+23, r25	; 0x17
    3a6e:	8e 8b       	std	Y+22, r24	; 0x16
    3a70:	c7 57       	subi	r28, 0x77	; 119
    3a72:	df 4f       	sbci	r29, 0xFF	; 255
    3a74:	48 81       	ld	r20, Y
    3a76:	59 81       	ldd	r21, Y+1	; 0x01
    3a78:	24 97       	sbiw	r28, 0x04	; 4
    3a7a:	68 81       	ld	r22, Y
    3a7c:	79 81       	ldd	r23, Y+1	; 0x01
    3a7e:	c5 58       	subi	r28, 0x85	; 133
    3a80:	d0 40       	sbci	r29, 0x00	; 0
    3a82:	ce 01       	movw	r24, r28
    3a84:	46 96       	adiw	r24, 0x16	; 22
    3a86:	0e 94 79 23 	call	0x46f2	; 0x46f2 <psock_send_P>
    3a8a:	88 23       	and	r24, r24
    3a8c:	09 f4       	brne	.+2      	; 0x3a90 <handle_connection+0x44e>
    3a8e:	48 c0       	rjmp	.+144    	; 0x3b20 <handle_connection+0x4de>
  
  PSOCK_END(&s->sout);
    3a90:	1f 8a       	std	Y+23, r1	; 0x17
    3a92:	1e 8a       	std	Y+22, r1	; 0x16
					s->len = uip_mss();
				}
      }
			//uart_puts_P(PSTR("\n\r\x1B[1msend ???\x1B[0m"));
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
      s->file.data += s->len;
    3a94:	fe 01       	movw	r30, r28
    3a96:	eb 57       	subi	r30, 0x7B	; 123
    3a98:	ff 4f       	sbci	r31, 0xFF	; 255
    3a9a:	c7 57       	subi	r28, 0x77	; 119
    3a9c:	df 4f       	sbci	r29, 0xFF	; 255
    3a9e:	80 81       	ld	r24, Z
    3aa0:	91 81       	ldd	r25, Z+1	; 0x01
    3aa2:	28 81       	ld	r18, Y
    3aa4:	39 81       	ldd	r19, Y+1	; 0x01
    3aa6:	c9 58       	subi	r28, 0x89	; 137
    3aa8:	d0 40       	sbci	r29, 0x00	; 0
    3aaa:	82 0f       	add	r24, r18
    3aac:	93 1f       	adc	r25, r19
    3aae:	91 83       	std	Z+1, r25	; 0x01
    3ab0:	80 83       	st	Z, r24
      s->file.len -= s->len;
    3ab2:	fe 01       	movw	r30, r28
    3ab4:	e9 57       	subi	r30, 0x79	; 121
    3ab6:	ff 4f       	sbci	r31, 0xFF	; 255
    3ab8:	80 81       	ld	r24, Z
    3aba:	91 81       	ldd	r25, Z+1	; 0x01
    3abc:	82 1b       	sub	r24, r18
    3abe:	93 0b       	sbc	r25, r19
    3ac0:	91 83       	std	Z+1, r25	; 0x01
    3ac2:	80 83       	st	Z, r24
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
	PT_BEGIN(&s->scriptpt);
	uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {
    3ac4:	c9 57       	subi	r28, 0x79	; 121
    3ac6:	df 4f       	sbci	r29, 0xFF	; 255
    3ac8:	28 81       	ld	r18, Y
    3aca:	39 81       	ldd	r19, Y+1	; 0x01
    3acc:	c7 58       	subi	r28, 0x87	; 135
    3ace:	d0 40       	sbci	r29, 0x00	; 0
    3ad0:	12 16       	cp	r1, r18
    3ad2:	13 06       	cpc	r1, r19
    3ad4:	0c f4       	brge	.+2      	; 0x3ad8 <handle_connection+0x496>
    3ad6:	19 cf       	rjmp	.-462    	; 0x390a <handle_connection+0x2c8>
      s->file.data += s->len;
      s->file.len -= s->len;
    }
  }
  
  PT_END(&s->scriptpt);
    3ad8:	1e a6       	std	Y+46, r1	; 0x2e
    3ada:	1d a6       	std	Y+45, r1	; 0x2d
    3adc:	09 c0       	rjmp	.+18     	; 0x3af0 <handle_connection+0x4ae>
      PT_INIT(&s->scriptpt);
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    } 
		else 
		{
      PT_WAIT_THREAD(&s->outputpt,send_file(s));
    3ade:	80 e1       	ldi	r24, 0x10	; 16
    3ae0:	91 e0       	ldi	r25, 0x01	; 1
    3ae2:	9c a7       	std	Y+44, r25	; 0x2c
    3ae4:	8b a7       	std	Y+43, r24	; 0x2b
    3ae6:	ce 01       	movw	r24, r28
    3ae8:	0e 94 e8 1a 	call	0x35d0	; 0x35d0 <send_file>
    3aec:	88 23       	and	r24, r24
    3aee:	c1 f0       	breq	.+48     	; 0x3b20 <handle_connection+0x4de>
    }
  }
  PSOCK_CLOSE(&s->sout);
    3af0:	80 e1       	ldi	r24, 0x10	; 16
    3af2:	80 93 65 04 	sts	0x0465, r24
  PT_END(&s->outputpt);
    3af6:	1c a6       	std	Y+44, r1	; 0x2c
    3af8:	1b a6       	std	Y+43, r1	; 0x2b
    3afa:	12 c0       	rjmp	.+36     	; 0x3b20 <handle_connection+0x4de>
      /*      httpd_log(&s->inputbuf[9]);*/
			// check URL for '?'
			for (i=0;((s->inputbuf[i]!=0) && (s->inputbuf[i]!='?'));i++);
			if (s->inputbuf[i]=='?')
			{
			uart_puts_P(PSTR("found ?\r\n"));
    3afc:	8c ed       	ldi	r24, 0xDC	; 220
    3afe:	92 e0       	ldi	r25, 0x02	; 2
    3b00:	0e 94 57 10 	call	0x20ae	; 0x20ae <uart_puts_P>
				// compare path / file
				if(strncmp(s->inputbuf+i-strlen("io.shtml"), "io.shtml", strlen("io.shtml")) == 0)
    3b04:	c8 01       	movw	r24, r16
    3b06:	87 96       	adiw	r24, 0x27	; 39
    3b08:	48 e0       	ldi	r20, 0x08	; 8
    3b0a:	50 e0       	ldi	r21, 0x00	; 0
    3b0c:	62 e1       	ldi	r22, 0x12	; 18
    3b0e:	71 e0       	ldi	r23, 0x01	; 1
    3b10:	8c 0f       	add	r24, r28
    3b12:	9d 1f       	adc	r25, r29
    3b14:	0e 94 b7 32 	call	0x656e	; 0x656e <strncmp>
    3b18:	00 97       	sbiw	r24, 0x00	; 0
    3b1a:	09 f0       	breq	.+2      	; 0x3b1e <handle_connection+0x4dc>
    3b1c:	ff cd       	rjmp	.-1026   	; 0x371c <handle_connection+0xda>
    3b1e:	34 ce       	rjmp	.-920    	; 0x3788 <handle_connection+0x146>
{
  handle_input(s);
  if(s->state == STATE_OUTPUT) {
    handle_output(s);
  }
}
    3b20:	df 91       	pop	r29
    3b22:	cf 91       	pop	r28
    3b24:	1f 91       	pop	r17
    3b26:	0f 91       	pop	r16
    3b28:	ff 90       	pop	r15
    3b2a:	ef 90       	pop	r14
    3b2c:	08 95       	ret

00003b2e <httpd_appcall>:
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
    3b2e:	ef 92       	push	r14
    3b30:	ff 92       	push	r15
    3b32:	0f 93       	push	r16
    3b34:	1f 93       	push	r17
    3b36:	cf 93       	push	r28
    3b38:	df 93       	push	r29
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);
    3b3a:	c0 91 68 04 	lds	r28, 0x0468
    3b3e:	d0 91 69 04 	lds	r29, 0x0469

	//uart_puts_P(PSTR("\n\r\x1B[1mAppcall\x1B[0m"));
	
  if(uip_closed() || uip_aborted() || uip_timedout()) {
    3b42:	90 91 65 04 	lds	r25, 0x0465
    3b46:	94 fd       	sbrc	r25, 4
    3b48:	3c c0       	rjmp	.+120    	; 0x3bc2 <httpd_appcall+0x94>
    3b4a:	95 fd       	sbrc	r25, 5
    3b4c:	3a c0       	rjmp	.+116    	; 0x3bc2 <httpd_appcall+0x94>
    3b4e:	97 fd       	sbrc	r25, 7
    3b50:	38 c0       	rjmp	.+112    	; 0x3bc2 <httpd_appcall+0x94>
}
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);
    3b52:	3c e1       	ldi	r19, 0x1C	; 28
    3b54:	e3 2e       	mov	r14, r19
    3b56:	f1 2c       	mov	r15, r1
    3b58:	ec 0e       	add	r14, r28
    3b5a:	fd 1e       	adc	r15, r29

	//uart_puts_P(PSTR("\n\r\x1B[1mAppcall\x1B[0m"));
	
  if(uip_closed() || uip_aborted() || uip_timedout()) {
  } else if(uip_connected()) {
    3b5c:	96 ff       	sbrs	r25, 6
    3b5e:	1b c0       	rjmp	.+54     	; 0x3b96 <httpd_appcall+0x68>
    PSOCK_INIT(&s->sin, s->inputbuf, sizeof(s->inputbuf) - 1);
    3b60:	8e 01       	movw	r16, r28
    3b62:	05 5b       	subi	r16, 0xB5	; 181
    3b64:	1f 4f       	sbci	r17, 0xFF	; 255
    3b66:	40 e4       	ldi	r20, 0x40	; 64
    3b68:	50 e0       	ldi	r21, 0x00	; 0
    3b6a:	b8 01       	movw	r22, r16
    3b6c:	ce 01       	movw	r24, r28
    3b6e:	4d 96       	adiw	r24, 0x1d	; 29
    3b70:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <psock_init>
    PSOCK_INIT(&s->sout, s->inputbuf, sizeof(s->inputbuf) - 1);
    3b74:	40 e4       	ldi	r20, 0x40	; 64
    3b76:	50 e0       	ldi	r21, 0x00	; 0
    3b78:	b8 01       	movw	r22, r16
    3b7a:	ce 01       	movw	r24, r28
    3b7c:	c2 96       	adiw	r24, 0x32	; 50
    3b7e:	0e 94 d1 21 	call	0x43a2	; 0x43a2 <psock_init>
    PT_INIT(&s->outputpt);
    3b82:	c9 5b       	subi	r28, 0xB9	; 185
    3b84:	df 4f       	sbci	r29, 0xFF	; 255
    3b86:	19 82       	std	Y+1, r1	; 0x01
    3b88:	18 82       	st	Y, r1
    s->state = STATE_WAITING;
    3b8a:	c7 5a       	subi	r28, 0xA7	; 167
    3b8c:	df 4f       	sbci	r29, 0xFF	; 255
    3b8e:	18 82       	st	Y, r1
    3b90:	c0 5a       	subi	r28, 0xA0	; 160
    3b92:	d0 40       	sbci	r29, 0x00	; 0
    3b94:	0e c0       	rjmp	.+28     	; 0x3bb2 <httpd_appcall+0x84>
    /*    timer_set(&s->ti3mer, CLOCK_SECOND * 100);*/
    s->timer = 0;
    handle_connection(s);
		} else if(s != NULL) {
    3b96:	e1 14       	cp	r14, r1
    3b98:	f1 04       	cpc	r15, r1
    3b9a:	81 f0       	breq	.+32     	; 0x3bbc <httpd_appcall+0x8e>
			if(uip_poll()) {
    3b9c:	93 ff       	sbrs	r25, 3
    3b9e:	09 c0       	rjmp	.+18     	; 0x3bb2 <httpd_appcall+0x84>
				++s->timer;
    3ba0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3ba2:	8f 5f       	subi	r24, 0xFF	; 255
    3ba4:	8c 8f       	std	Y+28, r24	; 0x1c
				if(s->timer >= 20) {
    3ba6:	84 31       	cpi	r24, 0x14	; 20
    3ba8:	28 f0       	brcs	.+10     	; 0x3bb4 <httpd_appcall+0x86>
					uip_abort();
    3baa:	80 e2       	ldi	r24, 0x20	; 32
    3bac:	80 93 65 04 	sts	0x0465, r24
    3bb0:	01 c0       	rjmp	.+2      	; 0x3bb4 <httpd_appcall+0x86>
				}
			} else {
      s->timer = 0;
    3bb2:	1c 8e       	std	Y+28, r1	; 0x1c
    }
    handle_connection(s);
    3bb4:	c7 01       	movw	r24, r14
    3bb6:	0e 94 21 1b 	call	0x3642	; 0x3642 <handle_connection>
    3bba:	03 c0       	rjmp	.+6      	; 0x3bc2 <httpd_appcall+0x94>
  } else {
    uip_abort();
    3bbc:	80 e2       	ldi	r24, 0x20	; 32
    3bbe:	80 93 65 04 	sts	0x0465, r24
  }
}
    3bc2:	df 91       	pop	r29
    3bc4:	cf 91       	pop	r28
    3bc6:	1f 91       	pop	r17
    3bc8:	0f 91       	pop	r16
    3bca:	ff 90       	pop	r15
    3bcc:	ef 90       	pop	r14
    3bce:	08 95       	ret

00003bd0 <generate_part_of_file>:


/*---------------------------------------------------------------------------*/
static unsigned short
generate_part_of_file(void *state)
{
    3bd0:	0f 93       	push	r16
    3bd2:	1f 93       	push	r17
  struct httpd_state *s = (struct httpd_state *)state;
    3bd4:	dc 01       	movw	r26, r24

  if(s->file.len > uip_mss()) {
    3bd6:	a9 57       	subi	r26, 0x79	; 121
    3bd8:	bf 4f       	sbci	r27, 0xFF	; 255
    3bda:	2d 91       	ld	r18, X+
    3bdc:	3c 91       	ld	r19, X
    3bde:	11 97       	sbiw	r26, 0x01	; 1
    3be0:	a7 58       	subi	r26, 0x87	; 135
    3be2:	b0 40       	sbci	r27, 0x00	; 0
    3be4:	e0 91 68 04 	lds	r30, 0x0468
    3be8:	f0 91 69 04 	lds	r31, 0x0469
    3bec:	82 89       	ldd	r24, Z+18	; 0x12
    3bee:	93 89       	ldd	r25, Z+19	; 0x13
    3bf0:	fd 01       	movw	r30, r26
    3bf2:	e7 57       	subi	r30, 0x77	; 119
    3bf4:	ff 4f       	sbci	r31, 0xFF	; 255
    3bf6:	82 17       	cp	r24, r18
    3bf8:	93 07       	cpc	r25, r19
    3bfa:	18 f4       	brcc	.+6      	; 0x3c02 <generate_part_of_file+0x32>
    s->len = uip_mss();
    3bfc:	91 83       	std	Z+1, r25	; 0x01
    3bfe:	80 83       	st	Z, r24
    3c00:	02 c0       	rjmp	.+4      	; 0x3c06 <generate_part_of_file+0x36>
  } else {
    s->len = s->file.len;
    3c02:	31 83       	std	Z+1, r19	; 0x01
    3c04:	20 83       	st	Z, r18
  }
  memcpy_P(uip_appdata, s->file.data, s->len);
    3c06:	8d 01       	movw	r16, r26
    3c08:	07 57       	subi	r16, 0x77	; 119
    3c0a:	1f 4f       	sbci	r17, 0xFF	; 255
    3c0c:	f8 01       	movw	r30, r16
    3c0e:	40 81       	ld	r20, Z
    3c10:	51 81       	ldd	r21, Z+1	; 0x01
    3c12:	ab 57       	subi	r26, 0x7B	; 123
    3c14:	bf 4f       	sbci	r27, 0xFF	; 255
    3c16:	6d 91       	ld	r22, X+
    3c18:	7c 91       	ld	r23, X
    3c1a:	80 91 66 04 	lds	r24, 0x0466
    3c1e:	90 91 67 04 	lds	r25, 0x0467
    3c22:	0e 94 52 32 	call	0x64a4	; 0x64a4 <memcpy_P>
			//uart_putc( ((unsigned char *)uip_appdata)[t]);
			uart_putc(((char*)uip_appdata)[t]);
	uart_puts_P(PSTR("<<<\r\n"));*/
  
  return s->len;
}
    3c26:	f8 01       	movw	r30, r16
    3c28:	80 81       	ld	r24, Z
    3c2a:	91 81       	ldd	r25, Z+1	; 0x01
    3c2c:	1f 91       	pop	r17
    3c2e:	0f 91       	pop	r16
    3c30:	08 95       	ret

00003c32 <nullfunction>:
static const struct httpd_cgi_call *calls[] = { &file, &tcp, &net, NULL };

/*---------------------------------------------------------------------------*/
static
PT_THREAD(nullfunction(struct httpd_state *s, char *ptr))
{
    3c32:	fc 01       	movw	r30, r24
    3c34:	17 8a       	std	Z+23, r1	; 0x17
    3c36:	16 8a       	std	Z+22, r1	; 0x16
  PSOCK_BEGIN(&s->sout);
  PSOCK_END(&s->sout);
}
    3c38:	82 e0       	ldi	r24, 0x02	; 2
    3c3a:	08 95       	ret

00003c3c <httpd_cgi>:
/*---------------------------------------------------------------------------*/
httpd_cgifunction
httpd_cgi(char *name)
{
    3c3c:	ef 92       	push	r14
    3c3e:	ff 92       	push	r15
    3c40:	0f 93       	push	r16
    3c42:	1f 93       	push	r17
    3c44:	cf 93       	push	r28
    3c46:	df 93       	push	r29
    3c48:	7c 01       	movw	r14, r24
    3c4a:	01 e8       	ldi	r16, 0x81	; 129
    3c4c:	11 e0       	ldi	r17, 0x01	; 1
    3c4e:	15 c0       	rjmp	.+42     	; 0x3c7a <httpd_cgi+0x3e>
  const struct httpd_cgi_call **f;


  /* Find the matching name in the table, return the function. */
  for(f = calls; *f != NULL; ++f) {
    if(strncmp_P((*f)->name, name, strlen((*f)->name)) == 0) {
    3c50:	88 81       	ld	r24, Y
    3c52:	99 81       	ldd	r25, Y+1	; 0x01
    3c54:	dc 01       	movw	r26, r24
    3c56:	fd 01       	movw	r30, r26
    3c58:	01 90       	ld	r0, Z+
    3c5a:	00 20       	and	r0, r0
    3c5c:	e9 f7       	brne	.-6      	; 0x3c58 <httpd_cgi+0x1c>
    3c5e:	31 97       	sbiw	r30, 0x01	; 1
    3c60:	ea 1b       	sub	r30, r26
    3c62:	fb 0b       	sbc	r31, r27
    3c64:	af 01       	movw	r20, r30
    3c66:	b7 01       	movw	r22, r14
    3c68:	0e 94 7f 32 	call	0x64fe	; 0x64fe <strncmp_P>
    3c6c:	89 2b       	or	r24, r25
    3c6e:	19 f4       	brne	.+6      	; 0x3c76 <httpd_cgi+0x3a>
      return (*f)->function;
    3c70:	2a 81       	ldd	r18, Y+2	; 0x02
    3c72:	3b 81       	ldd	r19, Y+3	; 0x03
    3c74:	09 c0       	rjmp	.+18     	; 0x3c88 <httpd_cgi+0x4c>
{
  const struct httpd_cgi_call **f;


  /* Find the matching name in the table, return the function. */
  for(f = calls; *f != NULL; ++f) {
    3c76:	0e 5f       	subi	r16, 0xFE	; 254
    3c78:	1f 4f       	sbci	r17, 0xFF	; 255
    3c7a:	f8 01       	movw	r30, r16
    3c7c:	c0 81       	ld	r28, Z
    3c7e:	d1 81       	ldd	r29, Z+1	; 0x01
    3c80:	20 97       	sbiw	r28, 0x00	; 0
    3c82:	31 f7       	brne	.-52     	; 0x3c50 <httpd_cgi+0x14>
    3c84:	29 e1       	ldi	r18, 0x19	; 25
    3c86:	3e e1       	ldi	r19, 0x1E	; 30
    if(strncmp_P((*f)->name, name, strlen((*f)->name)) == 0) {
      return (*f)->function;
    }
  }
  return nullfunction;
}
    3c88:	c9 01       	movw	r24, r18
    3c8a:	df 91       	pop	r29
    3c8c:	cf 91       	pop	r28
    3c8e:	1f 91       	pop	r17
    3c90:	0f 91       	pop	r16
    3c92:	ff 90       	pop	r15
    3c94:	ef 90       	pop	r14
    3c96:	08 95       	ret

00003c98 <net_stats>:
		  "%5u\n", ((uip_stats_t *)&uip_stat)[s->count]);
}

static
PT_THREAD(net_stats(struct httpd_state *s, char *ptr))
{
    3c98:	cf 93       	push	r28
    3c9a:	df 93       	push	r29
    3c9c:	ec 01       	movw	r28, r24
  PSOCK_BEGIN(&s->sout);
    3c9e:	8e 89       	ldd	r24, Y+22	; 0x16
    3ca0:	9f 89       	ldd	r25, Y+23	; 0x17
    3ca2:	00 97       	sbiw	r24, 0x00	; 0
    3ca4:	21 f0       	breq	.+8      	; 0x3cae <net_stats+0x16>
    3ca6:	84 3c       	cpi	r24, 0xC4	; 196
    3ca8:	91 05       	cpc	r25, r1
    3caa:	29 f5       	brne	.+74     	; 0x3cf6 <net_stats+0x5e>
    3cac:	0b c0       	rjmp	.+22     	; 0x3cc4 <net_stats+0x2c>

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
    3cae:	c1 57       	subi	r28, 0x71	; 113
    3cb0:	df 4f       	sbci	r29, 0xFF	; 255
    3cb2:	19 82       	std	Y+1, r1	; 0x01
    3cb4:	18 82       	st	Y, r1
    3cb6:	cf 58       	subi	r28, 0x8F	; 143
    3cb8:	d0 40       	sbci	r29, 0x00	; 0
    3cba:	15 c0       	rjmp	.+42     	; 0x3ce6 <net_stats+0x4e>
      ++s->count) {
    PSOCK_GENERATOR_SEND(&s->sout, generate_net_stats, s);
    3cbc:	84 ec       	ldi	r24, 0xC4	; 196
    3cbe:	90 e0       	ldi	r25, 0x00	; 0
    3cc0:	9f 8b       	std	Y+23, r25	; 0x17
    3cc2:	8e 8b       	std	Y+22, r24	; 0x16
    3cc4:	ae 01       	movw	r20, r28
    3cc6:	68 ec       	ldi	r22, 0xC8	; 200
    3cc8:	7e e1       	ldi	r23, 0x1E	; 30
    3cca:	ce 01       	movw	r24, r28
    3ccc:	46 96       	adiw	r24, 0x16	; 22
    3cce:	0e 94 ab 22 	call	0x4556	; 0x4556 <psock_generator_send>
    3cd2:	88 23       	and	r24, r24
    3cd4:	99 f0       	breq	.+38     	; 0x3cfc <net_stats+0x64>
  PSOCK_BEGIN(&s->sout);

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
      ++s->count) {
    3cd6:	fe 01       	movw	r30, r28
    3cd8:	e1 57       	subi	r30, 0x71	; 113
    3cda:	ff 4f       	sbci	r31, 0xFF	; 255
    3cdc:	80 81       	ld	r24, Z
    3cde:	91 81       	ldd	r25, Z+1	; 0x01
    3ce0:	01 96       	adiw	r24, 0x01	; 1
    3ce2:	91 83       	std	Z+1, r25	; 0x01
    3ce4:	80 83       	st	Z, r24
{
  PSOCK_BEGIN(&s->sout);

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
    3ce6:	c1 57       	subi	r28, 0x71	; 113
    3ce8:	df 4f       	sbci	r29, 0xFF	; 255
    3cea:	88 81       	ld	r24, Y
    3cec:	99 81       	ldd	r25, Y+1	; 0x01
    3cee:	cf 58       	subi	r28, 0x8F	; 143
    3cf0:	d0 40       	sbci	r29, 0x00	; 0
    3cf2:	46 97       	sbiw	r24, 0x16	; 22
    3cf4:	18 f3       	brcs	.-58     	; 0x3cbc <net_stats+0x24>
    PSOCK_GENERATOR_SEND(&s->sout, generate_net_stats, s);
  }
  
#endif /* UIP_STATISTICS */
  
  PSOCK_END(&s->sout);
    3cf6:	1f 8a       	std	Y+23, r1	; 0x17
    3cf8:	1e 8a       	std	Y+22, r1	; 0x16
    3cfa:	82 e0       	ldi	r24, 0x02	; 2
}
    3cfc:	df 91       	pop	r29
    3cfe:	cf 91       	pop	r28
    3d00:	08 95       	ret

00003d02 <tcp_stats>:
		 (uip_stopped(conn))? '!':' ');
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(tcp_stats(struct httpd_state *s, char *ptr))
{
    3d02:	cf 93       	push	r28
    3d04:	df 93       	push	r29
    3d06:	ec 01       	movw	r28, r24
  
  PSOCK_BEGIN(&s->sout);
    3d08:	8e 89       	ldd	r24, Y+22	; 0x16
    3d0a:	9f 89       	ldd	r25, Y+23	; 0x17
    3d0c:	00 97       	sbiw	r24, 0x00	; 0
    3d0e:	21 f0       	breq	.+8      	; 0x3d18 <tcp_stats+0x16>
    3d10:	8c 3a       	cpi	r24, 0xAC	; 172
    3d12:	91 05       	cpc	r25, r1
    3d14:	b9 f5       	brne	.+110    	; 0x3d84 <tcp_stats+0x82>
    3d16:	1c c0       	rjmp	.+56     	; 0x3d50 <tcp_stats+0x4e>

  for(s->count = 0; s->count < UIP_CONNS; ++s->count) {
    3d18:	c1 57       	subi	r28, 0x71	; 113
    3d1a:	df 4f       	sbci	r29, 0xFF	; 255
    3d1c:	19 82       	std	Y+1, r1	; 0x01
    3d1e:	18 82       	st	Y, r1
    3d20:	cf 58       	subi	r28, 0x8F	; 143
    3d22:	d0 40       	sbci	r29, 0x00	; 0
    3d24:	26 c0       	rjmp	.+76     	; 0x3d72 <tcp_stats+0x70>
    if((uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED) {
    3d26:	8d ea       	ldi	r24, 0xAD	; 173
    3d28:	90 e0       	ldi	r25, 0x00	; 0
    3d2a:	28 9f       	mul	r18, r24
    3d2c:	f0 01       	movw	r30, r0
    3d2e:	29 9f       	mul	r18, r25
    3d30:	f0 0d       	add	r31, r0
    3d32:	38 9f       	mul	r19, r24
    3d34:	f0 0d       	add	r31, r0
    3d36:	11 24       	eor	r1, r1
    3d38:	e6 59       	subi	r30, 0x96	; 150
    3d3a:	fb 4f       	sbci	r31, 0xFB	; 251
    3d3c:	81 8d       	ldd	r24, Z+25	; 0x19
    3d3e:	90 e0       	ldi	r25, 0x00	; 0
    3d40:	8f 70       	andi	r24, 0x0F	; 15
    3d42:	90 70       	andi	r25, 0x00	; 0
    3d44:	89 2b       	or	r24, r25
    3d46:	69 f0       	breq	.+26     	; 0x3d62 <tcp_stats+0x60>
      PSOCK_GENERATOR_SEND(&s->sout, generate_tcp_stats, s);
    3d48:	8c ea       	ldi	r24, 0xAC	; 172
    3d4a:	90 e0       	ldi	r25, 0x00	; 0
    3d4c:	9f 8b       	std	Y+23, r25	; 0x17
    3d4e:	8e 8b       	std	Y+22, r24	; 0x16
    3d50:	ae 01       	movw	r20, r28
    3d52:	60 ef       	ldi	r22, 0xF0	; 240
    3d54:	7e e1       	ldi	r23, 0x1E	; 30
    3d56:	ce 01       	movw	r24, r28
    3d58:	46 96       	adiw	r24, 0x16	; 22
    3d5a:	0e 94 ab 22 	call	0x4556	; 0x4556 <psock_generator_send>
    3d5e:	88 23       	and	r24, r24
    3d60:	a1 f0       	breq	.+40     	; 0x3d8a <tcp_stats+0x88>
PT_THREAD(tcp_stats(struct httpd_state *s, char *ptr))
{
  
  PSOCK_BEGIN(&s->sout);

  for(s->count = 0; s->count < UIP_CONNS; ++s->count) {
    3d62:	fe 01       	movw	r30, r28
    3d64:	e1 57       	subi	r30, 0x71	; 113
    3d66:	ff 4f       	sbci	r31, 0xFF	; 255
    3d68:	80 81       	ld	r24, Z
    3d6a:	91 81       	ldd	r25, Z+1	; 0x01
    3d6c:	01 96       	adiw	r24, 0x01	; 1
    3d6e:	91 83       	std	Z+1, r25	; 0x01
    3d70:	80 83       	st	Z, r24
    3d72:	c1 57       	subi	r28, 0x71	; 113
    3d74:	df 4f       	sbci	r29, 0xFF	; 255
    3d76:	28 81       	ld	r18, Y
    3d78:	39 81       	ldd	r19, Y+1	; 0x01
    3d7a:	cf 58       	subi	r28, 0x8F	; 143
    3d7c:	d0 40       	sbci	r29, 0x00	; 0
    3d7e:	22 30       	cpi	r18, 0x02	; 2
    3d80:	31 05       	cpc	r19, r1
    3d82:	88 f2       	brcs	.-94     	; 0x3d26 <tcp_stats+0x24>
    if((uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED) {
      PSOCK_GENERATOR_SEND(&s->sout, generate_tcp_stats, s);
    }
  }

  PSOCK_END(&s->sout);
    3d84:	1f 8a       	std	Y+23, r1	; 0x17
    3d86:	1e 8a       	std	Y+22, r1	; 0x16
    3d88:	82 e0       	ldi	r24, 0x02	; 2
}
    3d8a:	df 91       	pop	r29
    3d8c:	cf 91       	pop	r28
    3d8e:	08 95       	ret

00003d90 <generate_net_stats>:
/*---------------------------------------------------------------------------*/
static unsigned short
generate_net_stats(void *arg)
{
    3d90:	fc 01       	movw	r30, r24
    3d92:	e1 57       	subi	r30, 0x71	; 113
    3d94:	ff 4f       	sbci	r31, 0xFF	; 255
    3d96:	01 90       	ld	r0, Z+
    3d98:	f0 81       	ld	r31, Z
    3d9a:	e0 2d       	mov	r30, r0
    3d9c:	ee 0f       	add	r30, r30
    3d9e:	ff 1f       	adc	r31, r31
    3da0:	e4 53       	subi	r30, 0x34	; 52
    3da2:	fa 4f       	sbci	r31, 0xFA	; 250
    3da4:	80 81       	ld	r24, Z
    3da6:	91 81       	ldd	r25, Z+1	; 0x01
    3da8:	9f 93       	push	r25
    3daa:	8f 93       	push	r24
    3dac:	8b e1       	ldi	r24, 0x1B	; 27
    3dae:	91 e0       	ldi	r25, 0x01	; 1
    3db0:	9f 93       	push	r25
    3db2:	8f 93       	push	r24
    3db4:	86 ea       	ldi	r24, 0xA6	; 166
    3db6:	95 e0       	ldi	r25, 0x05	; 5
    3db8:	9f 93       	push	r25
    3dba:	8f 93       	push	r24
    3dbc:	80 91 66 04 	lds	r24, 0x0466
    3dc0:	90 91 67 04 	lds	r25, 0x0467
    3dc4:	9f 93       	push	r25
    3dc6:	8f 93       	push	r24
    3dc8:	0e 94 12 33 	call	0x6624	; 0x6624 <snprintf>
    3dcc:	2d b7       	in	r18, 0x3d	; 61
    3dce:	3e b7       	in	r19, 0x3e	; 62
    3dd0:	28 5f       	subi	r18, 0xF8	; 248
    3dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd4:	0f b6       	in	r0, 0x3f	; 63
    3dd6:	f8 94       	cli
    3dd8:	3e bf       	out	0x3e, r19	; 62
    3dda:	0f be       	out	0x3f, r0	; 63
    3ddc:	2d bf       	out	0x3d, r18	; 61
  struct httpd_state *s = (struct httpd_state *)arg;
  return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE,
		  "%5u\n", ((uip_stats_t *)&uip_stat)[s->count]);
}
    3dde:	08 95       	ret

00003de0 <generate_tcp_stats>:
  last_ack};
  

static unsigned short
generate_tcp_stats(void *arg)
{
    3de0:	2f 92       	push	r2
    3de2:	3f 92       	push	r3
    3de4:	4f 92       	push	r4
    3de6:	5f 92       	push	r5
    3de8:	6f 92       	push	r6
    3dea:	7f 92       	push	r7
    3dec:	8f 92       	push	r8
    3dee:	9f 92       	push	r9
    3df0:	af 92       	push	r10
    3df2:	bf 92       	push	r11
    3df4:	cf 92       	push	r12
    3df6:	df 92       	push	r13
    3df8:	ef 92       	push	r14
    3dfa:	ff 92       	push	r15
    3dfc:	0f 93       	push	r16
    3dfe:	1f 93       	push	r17
    3e00:	df 93       	push	r29
    3e02:	cf 93       	push	r28
    3e04:	00 d0       	rcall	.+0      	; 0x3e06 <generate_tcp_stats+0x26>
    3e06:	00 d0       	rcall	.+0      	; 0x3e08 <generate_tcp_stats+0x28>
    3e08:	cd b7       	in	r28, 0x3d	; 61
    3e0a:	de b7       	in	r29, 0x3e	; 62
  struct uip_conn *conn;
  struct httpd_state *s = (struct httpd_state *)arg;
  conn = &uip_conns[s->count]; 
    3e0c:	fc 01       	movw	r30, r24
    3e0e:	e1 57       	subi	r30, 0x71	; 113
    3e10:	ff 4f       	sbci	r31, 0xFF	; 255
    3e12:	20 81       	ld	r18, Z
    3e14:	31 81       	ldd	r19, Z+1	; 0x01
    3e16:	8d ea       	ldi	r24, 0xAD	; 173
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	28 9f       	mul	r18, r24
    3e1c:	a0 01       	movw	r20, r0
    3e1e:	29 9f       	mul	r18, r25
    3e20:	50 0d       	add	r21, r0
    3e22:	38 9f       	mul	r19, r24
    3e24:	50 0d       	add	r21, r0
    3e26:	11 24       	eor	r1, r1
    3e28:	46 59       	subi	r20, 0x96	; 150
    3e2a:	5b 4f       	sbci	r21, 0xFB	; 251
    3e2c:	5c 83       	std	Y+4, r21	; 0x04
    3e2e:	4b 83       	std	Y+3, r20	; 0x03
  return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE,
    3e30:	da 01       	movw	r26, r20
    3e32:	59 96       	adiw	r26, 0x19	; 25
    3e34:	8c 91       	ld	r24, X
    3e36:	e8 2f       	mov	r30, r24
    3e38:	f0 e0       	ldi	r31, 0x00	; 0
    3e3a:	84 fd       	sbrc	r24, 4
    3e3c:	05 c0       	rjmp	.+10     	; 0x3e48 <generate_tcp_stats+0x68>
    3e3e:	20 e2       	ldi	r18, 0x20	; 32
    3e40:	30 e0       	ldi	r19, 0x00	; 0
    3e42:	3a 83       	std	Y+2, r19	; 0x02
    3e44:	29 83       	std	Y+1, r18	; 0x01
    3e46:	04 c0       	rjmp	.+8      	; 0x3e50 <generate_tcp_stats+0x70>
    3e48:	41 e2       	ldi	r20, 0x21	; 33
    3e4a:	50 e0       	ldi	r21, 0x00	; 0
    3e4c:	5a 83       	std	Y+2, r21	; 0x02
    3e4e:	49 83       	std	Y+1, r20	; 0x01
    3e50:	ab 81       	ldd	r26, Y+3	; 0x03
    3e52:	bc 81       	ldd	r27, Y+4	; 0x04
    3e54:	50 96       	adiw	r26, 0x10	; 16
    3e56:	8d 91       	ld	r24, X+
    3e58:	9c 91       	ld	r25, X
    3e5a:	51 97       	sbiw	r26, 0x11	; 17
    3e5c:	89 2b       	or	r24, r25
    3e5e:	21 f4       	brne	.+8      	; 0x3e68 <generate_tcp_stats+0x88>
    3e60:	30 e2       	ldi	r19, 0x20	; 32
    3e62:	23 2e       	mov	r2, r19
    3e64:	31 2c       	mov	r3, r1
    3e66:	03 c0       	rjmp	.+6      	; 0x3e6e <generate_tcp_stats+0x8e>
    3e68:	2a e2       	ldi	r18, 0x2A	; 42
    3e6a:	22 2e       	mov	r2, r18
    3e6c:	31 2c       	mov	r3, r1
    3e6e:	ab 81       	ldd	r26, Y+3	; 0x03
    3e70:	bc 81       	ldd	r27, Y+4	; 0x04
    3e72:	5a 96       	adiw	r26, 0x1a	; 26
    3e74:	ac 90       	ld	r10, X
    3e76:	5a 97       	sbiw	r26, 0x1a	; 26
    3e78:	bb 24       	eor	r11, r11
    3e7a:	5b 96       	adiw	r26, 0x1b	; 27
    3e7c:	cc 90       	ld	r12, X
    3e7e:	5b 97       	sbiw	r26, 0x1b	; 27
    3e80:	dd 24       	eor	r13, r13
    3e82:	ef 70       	andi	r30, 0x0F	; 15
    3e84:	f0 70       	andi	r31, 0x00	; 0
    3e86:	ee 0f       	add	r30, r30
    3e88:	ff 1f       	adc	r31, r31
    3e8a:	e7 57       	subi	r30, 0x77	; 119
    3e8c:	fe 4f       	sbci	r31, 0xFE	; 254
    3e8e:	60 80       	ld	r6, Z
    3e90:	71 80       	ldd	r7, Z+1	; 0x01
    3e92:	16 96       	adiw	r26, 0x06	; 6
    3e94:	8d 91       	ld	r24, X+
    3e96:	9c 91       	ld	r25, X
    3e98:	17 97       	sbiw	r26, 0x07	; 7
    3e9a:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    3e9e:	4c 01       	movw	r8, r24
    3ea0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ea2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ea4:	82 81       	ldd	r24, Z+2	; 0x02
    3ea6:	93 81       	ldd	r25, Z+3	; 0x03
    3ea8:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    3eac:	8c 01       	movw	r16, r24
    3eae:	ab 81       	ldd	r26, Y+3	; 0x03
    3eb0:	bc 81       	ldd	r27, Y+4	; 0x04
    3eb2:	12 96       	adiw	r26, 0x02	; 2
    3eb4:	8d 91       	ld	r24, X+
    3eb6:	9c 91       	ld	r25, X
    3eb8:	13 97       	sbiw	r26, 0x03	; 3
    3eba:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    3ebe:	59 2e       	mov	r5, r25
    3ec0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec4:	80 81       	ld	r24, Z
    3ec6:	91 81       	ldd	r25, Z+1	; 0x01
    3ec8:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    3ecc:	7c 01       	movw	r14, r24
    3ece:	ab 81       	ldd	r26, Y+3	; 0x03
    3ed0:	bc 81       	ldd	r27, Y+4	; 0x04
    3ed2:	8d 91       	ld	r24, X+
    3ed4:	9c 91       	ld	r25, X
    3ed6:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    3eda:	49 2e       	mov	r4, r25
    3edc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ede:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee0:	84 81       	ldd	r24, Z+4	; 0x04
    3ee2:	95 81       	ldd	r25, Z+5	; 0x05
    3ee4:	0e 94 18 26 	call	0x4c30	; 0x4c30 <htons>
    3ee8:	29 81       	ldd	r18, Y+1	; 0x01
    3eea:	3a 81       	ldd	r19, Y+2	; 0x02
    3eec:	3f 93       	push	r19
    3eee:	2f 93       	push	r18
    3ef0:	3f 92       	push	r3
    3ef2:	2f 92       	push	r2
    3ef4:	bf 92       	push	r11
    3ef6:	af 92       	push	r10
    3ef8:	df 92       	push	r13
    3efa:	cf 92       	push	r12
    3efc:	7f 92       	push	r7
    3efe:	6f 92       	push	r6
    3f00:	9f 92       	push	r9
    3f02:	8f 92       	push	r8
    3f04:	10 70       	andi	r17, 0x00	; 0
    3f06:	1f 93       	push	r17
    3f08:	0f 93       	push	r16
    3f0a:	25 2d       	mov	r18, r5
    3f0c:	30 e0       	ldi	r19, 0x00	; 0
    3f0e:	3f 93       	push	r19
    3f10:	2f 93       	push	r18
    3f12:	3f ef       	ldi	r19, 0xFF	; 255
    3f14:	e3 22       	and	r14, r19
    3f16:	ff 24       	eor	r15, r15
    3f18:	ff 92       	push	r15
    3f1a:	ef 92       	push	r14
    3f1c:	24 2d       	mov	r18, r4
    3f1e:	30 e0       	ldi	r19, 0x00	; 0
    3f20:	3f 93       	push	r19
    3f22:	2f 93       	push	r18
    3f24:	9f 93       	push	r25
    3f26:	8f 93       	push	r24
    3f28:	80 e2       	ldi	r24, 0x20	; 32
    3f2a:	91 e0       	ldi	r25, 0x01	; 1
    3f2c:	9f 93       	push	r25
    3f2e:	8f 93       	push	r24
    3f30:	86 ea       	ldi	r24, 0xA6	; 166
    3f32:	95 e0       	ldi	r25, 0x05	; 5
    3f34:	9f 93       	push	r25
    3f36:	8f 93       	push	r24
    3f38:	80 91 66 04 	lds	r24, 0x0466
    3f3c:	90 91 67 04 	lds	r25, 0x0467
    3f40:	9f 93       	push	r25
    3f42:	8f 93       	push	r24
    3f44:	0e 94 12 33 	call	0x6624	; 0x6624 <snprintf>
    3f48:	4d b7       	in	r20, 0x3d	; 61
    3f4a:	5e b7       	in	r21, 0x3e	; 62
    3f4c:	44 5e       	subi	r20, 0xE4	; 228
    3f4e:	5f 4f       	sbci	r21, 0xFF	; 255
    3f50:	0f b6       	in	r0, 0x3f	; 63
    3f52:	f8 94       	cli
    3f54:	5e bf       	out	0x3e, r21	; 62
    3f56:	0f be       	out	0x3f, r0	; 63
    3f58:	4d bf       	out	0x3d, r20	; 61
		 states[conn->tcpstateflags & UIP_TS_MASK],
		 conn->nrtx,
		 conn->timer,
		 (uip_outstanding(conn))? '*':' ',
		 (uip_stopped(conn))? '!':' ');
}
    3f5a:	0f 90       	pop	r0
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	0f 90       	pop	r0
    3f62:	cf 91       	pop	r28
    3f64:	df 91       	pop	r29
    3f66:	1f 91       	pop	r17
    3f68:	0f 91       	pop	r16
    3f6a:	ff 90       	pop	r15
    3f6c:	ef 90       	pop	r14
    3f6e:	df 90       	pop	r13
    3f70:	cf 90       	pop	r12
    3f72:	bf 90       	pop	r11
    3f74:	af 90       	pop	r10
    3f76:	9f 90       	pop	r9
    3f78:	8f 90       	pop	r8
    3f7a:	7f 90       	pop	r7
    3f7c:	6f 90       	pop	r6
    3f7e:	5f 90       	pop	r5
    3f80:	4f 90       	pop	r4
    3f82:	3f 90       	pop	r3
    3f84:	2f 90       	pop	r2
    3f86:	08 95       	ret

00003f88 <file_stats>:
	return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE, "%5u", httpd_fs_count(f));
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(file_stats(struct httpd_state *s, char *ptr))
{
    3f88:	cf 93       	push	r28
    3f8a:	df 93       	push	r29
    3f8c:	ec 01       	movw	r28, r24
    3f8e:	9b 01       	movw	r18, r22
  PSOCK_BEGIN(&s->sout);
    3f90:	8e 89       	ldd	r24, Y+22	; 0x16
    3f92:	9f 89       	ldd	r25, Y+23	; 0x17
    3f94:	00 97       	sbiw	r24, 0x00	; 0
    3f96:	21 f0       	breq	.+8      	; 0x3fa0 <file_stats+0x18>
    3f98:	83 36       	cpi	r24, 0x63	; 99
    3f9a:	91 05       	cpc	r25, r1
    3f9c:	a9 f4       	brne	.+42     	; 0x3fc8 <file_stats+0x40>
    3f9e:	04 c0       	rjmp	.+8      	; 0x3fa8 <file_stats+0x20>

  PSOCK_GENERATOR_SEND(&s->sout, generate_file_stats, strchr(ptr, ' ') + 1);
    3fa0:	83 e6       	ldi	r24, 0x63	; 99
    3fa2:	90 e0       	ldi	r25, 0x00	; 0
    3fa4:	9f 8b       	std	Y+23, r25	; 0x17
    3fa6:	8e 8b       	std	Y+22, r24	; 0x16
    3fa8:	60 e2       	ldi	r22, 0x20	; 32
    3faa:	70 e0       	ldi	r23, 0x00	; 0
    3fac:	c9 01       	movw	r24, r18
    3fae:	0e 94 ac 32 	call	0x6558	; 0x6558 <strchr>
    3fb2:	ac 01       	movw	r20, r24
    3fb4:	4f 5f       	subi	r20, 0xFF	; 255
    3fb6:	5f 4f       	sbci	r21, 0xFF	; 255
    3fb8:	6a ee       	ldi	r22, 0xEA	; 234
    3fba:	7f e1       	ldi	r23, 0x1F	; 31
    3fbc:	ce 01       	movw	r24, r28
    3fbe:	46 96       	adiw	r24, 0x16	; 22
    3fc0:	0e 94 ab 22 	call	0x4556	; 0x4556 <psock_generator_send>
    3fc4:	88 23       	and	r24, r24
    3fc6:	19 f0       	breq	.+6      	; 0x3fce <file_stats+0x46>
  
  PSOCK_END(&s->sout);
    3fc8:	1f 8a       	std	Y+23, r1	; 0x17
    3fca:	1e 8a       	std	Y+22, r1	; 0x16
    3fcc:	82 e0       	ldi	r24, 0x02	; 2
}
    3fce:	df 91       	pop	r29
    3fd0:	cf 91       	pop	r28
    3fd2:	08 95       	ret

00003fd4 <generate_file_stats>:
  return nullfunction;
}
/*---------------------------------------------------------------------------*/
static unsigned short
generate_file_stats(void *arg)
{
    3fd4:	0e 94 ac 20 	call	0x4158	; 0x4158 <httpd_fs_count>
    3fd8:	9f 93       	push	r25
    3fda:	8f 93       	push	r24
    3fdc:	8d e7       	ldi	r24, 0x7D	; 125
    3fde:	91 e0       	ldi	r25, 0x01	; 1
    3fe0:	9f 93       	push	r25
    3fe2:	8f 93       	push	r24
    3fe4:	86 ea       	ldi	r24, 0xA6	; 166
    3fe6:	95 e0       	ldi	r25, 0x05	; 5
    3fe8:	9f 93       	push	r25
    3fea:	8f 93       	push	r24
    3fec:	80 91 66 04 	lds	r24, 0x0466
    3ff0:	90 91 67 04 	lds	r25, 0x0467
    3ff4:	9f 93       	push	r25
    3ff6:	8f 93       	push	r24
    3ff8:	0e 94 12 33 	call	0x6624	; 0x6624 <snprintf>
    3ffc:	2d b7       	in	r18, 0x3d	; 61
    3ffe:	3e b7       	in	r19, 0x3e	; 62
    4000:	28 5f       	subi	r18, 0xF8	; 248
    4002:	3f 4f       	sbci	r19, 0xFF	; 255
    4004:	0f b6       	in	r0, 0x3f	; 63
    4006:	f8 94       	cli
    4008:	3e bf       	out	0x3e, r19	; 62
    400a:	0f be       	out	0x3f, r0	; 63
    400c:	2d bf       	out	0x3d, r18	; 61
	char *f = (char *)arg;
	return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE, "%5u", httpd_fs_count(f));
}
    400e:	08 95       	ret

00004010 <httpd_fs_open>:
  goto loop;
}
/*-----------------------------------------------------------------------------------*/
int
httpd_fs_open(const char *name, struct httpd_fs_file *file)
{
    4010:	ef 92       	push	r14
    4012:	ff 92       	push	r15
    4014:	0f 93       	push	r16
    4016:	1f 93       	push	r17
    4018:	cf 93       	push	r28
    401a:	df 93       	push	r29
    401c:	7c 01       	movw	r14, r24
    401e:	8b 01       	movw	r16, r22
#if HTTPD_FS_STATISTICS
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    4020:	c6 e8       	ldi	r28, 0x86	; 134
    4022:	d2 e0       	ldi	r29, 0x02	; 2
    4024:	40 e0       	ldi	r20, 0x00	; 0
    4026:	50 e0       	ldi	r21, 0x00	; 0
    4028:	2c c0       	rjmp	.+88     	; 0x4082 <httpd_fs_open+0x72>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
    402a:	6a 81       	ldd	r22, Y+2	; 0x02
    402c:	7b 81       	ldd	r23, Y+3	; 0x03
    402e:	90 e0       	ldi	r25, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    4030:	a9 2f       	mov	r26, r25
    4032:	b0 e0       	ldi	r27, 0x00	; 0
    4034:	fb 01       	movw	r30, r22
    4036:	ea 0f       	add	r30, r26
    4038:	fb 1f       	adc	r31, r27
    403a:	24 91       	lpm	r18, Z+
    403c:	22 23       	and	r18, r18
    403e:	59 f0       	breq	.+22     	; 0x4056 <httpd_fs_open+0x46>
    4040:	ae 0d       	add	r26, r14
    4042:	bf 1d       	adc	r27, r15
    4044:	8c 91       	ld	r24, X
    4046:	8d 30       	cpi	r24, 0x0D	; 13
    4048:	31 f0       	breq	.+12     	; 0x4056 <httpd_fs_open+0x46>
    404a:	8a 30       	cpi	r24, 0x0A	; 10
    404c:	21 f0       	breq	.+8      	; 0x4056 <httpd_fs_open+0x46>
     str1[i] == '\r' ||
     str1[i] == '\n') {
    return 0;
  }

  if(str1[i] != pgm_read_byte(&str2[i])) {
    404e:	82 17       	cp	r24, r18
    4050:	21 f5       	brne	.+72     	; 0x409a <httpd_fs_open+0x8a>
    return 1;
  }


  ++i;
    4052:	9f 5f       	subi	r25, 0xFF	; 255
    4054:	ed cf       	rjmp	.-38     	; 0x4030 <httpd_fs_open+0x20>
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
      file->data = f->data;  // f = progmem !
    4056:	8c 81       	ldd	r24, Y+4	; 0x04
    4058:	9d 81       	ldd	r25, Y+5	; 0x05
    405a:	f8 01       	movw	r30, r16
    405c:	91 83       	std	Z+1, r25	; 0x01
    405e:	80 83       	st	Z, r24
      file->len = f->len;    // f = progmem !
    4060:	8e 81       	ldd	r24, Y+6	; 0x06
    4062:	9f 81       	ldd	r25, Y+7	; 0x07
    4064:	93 83       	std	Z+3, r25	; 0x03
    4066:	82 83       	std	Z+2, r24	; 0x02
#if HTTPD_FS_STATISTICS
      ++count[i];
    4068:	fa 01       	movw	r30, r20
    406a:	ee 0f       	add	r30, r30
    406c:	ff 1f       	adc	r31, r31
    406e:	e9 55       	subi	r30, 0x59	; 89
    4070:	fc 4f       	sbci	r31, 0xFC	; 252
    4072:	80 81       	ld	r24, Z
    4074:	91 81       	ldd	r25, Z+1	; 0x01
    4076:	01 96       	adiw	r24, 0x01	; 1
    4078:	91 83       	std	Z+1, r25	; 0x01
    407a:	80 83       	st	Z, r24
    407c:	21 e0       	ldi	r18, 0x01	; 1
    407e:	30 e0       	ldi	r19, 0x00	; 0
    4080:	04 c0       	rjmp	.+8      	; 0x408a <httpd_fs_open+0x7a>
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    4082:	20 97       	sbiw	r28, 0x00	; 0
    4084:	91 f6       	brne	.-92     	; 0x402a <httpd_fs_open+0x1a>
    4086:	20 e0       	ldi	r18, 0x00	; 0
    4088:	30 e0       	ldi	r19, 0x00	; 0
    ++i;
#endif /* HTTPD_FS_STATISTICS */

  }
  return 0;
}
    408a:	c9 01       	movw	r24, r18
    408c:	df 91       	pop	r29
    408e:	cf 91       	pop	r28
    4090:	1f 91       	pop	r17
    4092:	0f 91       	pop	r16
    4094:	ff 90       	pop	r15
    4096:	ef 90       	pop	r14
    4098:	08 95       	ret
      ++count[i];
#endif /* HTTPD_FS_STATISTICS */
      return 1;
    }
#if HTTPD_FS_STATISTICS
    ++i;
    409a:	4f 5f       	subi	r20, 0xFF	; 255
    409c:	5f 4f       	sbci	r21, 0xFF	; 255
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    409e:	88 81       	ld	r24, Y
    40a0:	99 81       	ldd	r25, Y+1	; 0x01
    40a2:	9c 01       	movw	r18, r24
    40a4:	e9 01       	movw	r28, r18
    40a6:	ed cf       	rjmp	.-38     	; 0x4082 <httpd_fs_open+0x72>

000040a8 <httpd_fs_open_P>:
  return 0;
}
/*-----------------------------------------------------------------------------------*/
int
httpd_fs_open_P(const char *name, struct httpd_fs_file *file)
{
    40a8:	0f 93       	push	r16
    40aa:	1f 93       	push	r17
    40ac:	cf 93       	push	r28
    40ae:	df 93       	push	r29
    40b0:	8c 01       	movw	r16, r24
    40b2:	eb 01       	movw	r28, r22
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    40b4:	a6 e8       	ldi	r26, 0x86	; 134
    40b6:	b2 e0       	ldi	r27, 0x02	; 2
    40b8:	40 e0       	ldi	r20, 0x00	; 0
    40ba:	50 e0       	ldi	r21, 0x00	; 0
    40bc:	32 c0       	rjmp	.+100    	; 0x4122 <httpd_fs_open_P+0x7a>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp_P(name, f->name) == 0) {
    40be:	12 96       	adiw	r26, 0x02	; 2
    40c0:	6d 91       	ld	r22, X+
    40c2:	7c 91       	ld	r23, X
    40c4:	13 97       	sbiw	r26, 0x03	; 3
    40c6:	20 e0       	ldi	r18, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    40c8:	82 2f       	mov	r24, r18
    40ca:	90 e0       	ldi	r25, 0x00	; 0
    40cc:	fb 01       	movw	r30, r22
    40ce:	e8 0f       	add	r30, r24
    40d0:	f9 1f       	adc	r31, r25
    40d2:	34 91       	lpm	r19, Z+
    40d4:	33 23       	and	r19, r19
    40d6:	61 f0       	breq	.+24     	; 0x40f0 <httpd_fs_open_P+0x48>
     pgm_read_byte(&str1[i]) == '\r' ||
    40d8:	80 0f       	add	r24, r16
    40da:	91 1f       	adc	r25, r17
    40dc:	fc 01       	movw	r30, r24
    40de:	84 91       	lpm	r24, Z+
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    40e0:	8d 30       	cpi	r24, 0x0D	; 13
    40e2:	31 f0       	breq	.+12     	; 0x40f0 <httpd_fs_open_P+0x48>
    40e4:	8a 30       	cpi	r24, 0x0A	; 10
    40e6:	21 f0       	breq	.+8      	; 0x40f0 <httpd_fs_open_P+0x48>
     pgm_read_byte(&str1[i]) == '\r' ||
     pgm_read_byte(&str1[i]) == '\n') {
    return 0;
  }

  if(pgm_read_byte(&str1[i]) != pgm_read_byte(&str2[i])) {
    40e8:	83 17       	cp	r24, r19
    40ea:	29 f5       	brne	.+74     	; 0x4136 <httpd_fs_open_P+0x8e>
    return 1;
  }


  ++i;
    40ec:	2f 5f       	subi	r18, 0xFF	; 255
    40ee:	ec cf       	rjmp	.-40     	; 0x40c8 <httpd_fs_open_P+0x20>
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp_P(name, f->name) == 0) {
      file->data = f->data;  // f->data = zeiger auf progmem 
    40f0:	14 96       	adiw	r26, 0x04	; 4
    40f2:	8d 91       	ld	r24, X+
    40f4:	9c 91       	ld	r25, X
    40f6:	15 97       	sbiw	r26, 0x05	; 5
    40f8:	99 83       	std	Y+1, r25	; 0x01
    40fa:	88 83       	st	Y, r24
      file->len = f->len;    // f->len = zeiger auf progmem 
    40fc:	16 96       	adiw	r26, 0x06	; 6
    40fe:	8d 91       	ld	r24, X+
    4100:	9c 91       	ld	r25, X
    4102:	17 97       	sbiw	r26, 0x07	; 7
    4104:	9b 83       	std	Y+3, r25	; 0x03
    4106:	8a 83       	std	Y+2, r24	; 0x02
#if HTTPD_FS_STATISTICS
      ++count[i];
    4108:	fa 01       	movw	r30, r20
    410a:	ee 0f       	add	r30, r30
    410c:	ff 1f       	adc	r31, r31
    410e:	e9 55       	subi	r30, 0x59	; 89
    4110:	fc 4f       	sbci	r31, 0xFC	; 252
    4112:	80 81       	ld	r24, Z
    4114:	91 81       	ldd	r25, Z+1	; 0x01
    4116:	01 96       	adiw	r24, 0x01	; 1
    4118:	91 83       	std	Z+1, r25	; 0x01
    411a:	80 83       	st	Z, r24
    411c:	21 e0       	ldi	r18, 0x01	; 1
    411e:	30 e0       	ldi	r19, 0x00	; 0
    4120:	04 c0       	rjmp	.+8      	; 0x412a <httpd_fs_open_P+0x82>
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    4122:	10 97       	sbiw	r26, 0x00	; 0
    4124:	61 f6       	brne	.-104    	; 0x40be <httpd_fs_open_P+0x16>
    4126:	20 e0       	ldi	r18, 0x00	; 0
    4128:	30 e0       	ldi	r19, 0x00	; 0
    ++i;
#endif /* HTTPD_FS_STATISTICS */

  }
  return 0;
}
    412a:	c9 01       	movw	r24, r18
    412c:	df 91       	pop	r29
    412e:	cf 91       	pop	r28
    4130:	1f 91       	pop	r17
    4132:	0f 91       	pop	r16
    4134:	08 95       	ret
      ++count[i];
#endif /* HTTPD_FS_STATISTICS */
      return 1;
    }
#if HTTPD_FS_STATISTICS
    ++i;
    4136:	4f 5f       	subi	r20, 0xFF	; 255
    4138:	5f 4f       	sbci	r21, 0xFF	; 255
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    413a:	8c 91       	ld	r24, X
    413c:	11 96       	adiw	r26, 0x01	; 1
    413e:	9c 91       	ld	r25, X
    4140:	9c 01       	movw	r18, r24
    4142:	d9 01       	movw	r26, r18
    4144:	ee cf       	rjmp	.-36     	; 0x4122 <httpd_fs_open_P+0x7a>

00004146 <httpd_fs_init>:
}
/*-----------------------------------------------------------------------------------*/

void
httpd_fs_init(void)
{
    4146:	e7 ea       	ldi	r30, 0xA7	; 167
    4148:	f3 e0       	ldi	r31, 0x03	; 3
#if HTTPD_FS_STATISTICS
  u16_t i;
  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {
    count[i] = 0;
    414a:	11 92       	st	Z+, r1
    414c:	11 92       	st	Z+, r1
void
httpd_fs_init(void)
{
#if HTTPD_FS_STATISTICS
  u16_t i;
  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {
    414e:	83 e0       	ldi	r24, 0x03	; 3
    4150:	ed 3b       	cpi	r30, 0xBD	; 189
    4152:	f8 07       	cpc	r31, r24
    4154:	d1 f7       	brne	.-12     	; 0x414a <httpd_fs_init+0x4>
    count[i] = 0;
  }
#endif /* HTTPD_FS_STATISTICS */
}
    4156:	08 95       	ret

00004158 <httpd_fs_count>:
/*-----------------------------------------------------------------------------------*/
#if HTTPD_FS_STATISTICS
u16_t httpd_fs_count
(char *name)
{
    4158:	0f 93       	push	r16
    415a:	1f 93       	push	r17
    415c:	cf 93       	push	r28
    415e:	df 93       	push	r29
    4160:	8c 01       	movw	r16, r24
  struct httpd_fsdata_file_noconst *f; 
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    4162:	26 e8       	ldi	r18, 0x86	; 134
    4164:	32 e0       	ldi	r19, 0x02	; 2
    4166:	c0 e0       	ldi	r28, 0x00	; 0
    4168:	d0 e0       	ldi	r29, 0x00	; 0
    416a:	1e c0       	rjmp	.+60     	; 0x41a8 <httpd_fs_count+0x50>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
    416c:	f9 01       	movw	r30, r18
    416e:	62 81       	ldd	r22, Z+2	; 0x02
    4170:	73 81       	ldd	r23, Z+3	; 0x03
    4172:	90 e0       	ldi	r25, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    4174:	a9 2f       	mov	r26, r25
    4176:	b0 e0       	ldi	r27, 0x00	; 0
    4178:	fb 01       	movw	r30, r22
    417a:	ea 0f       	add	r30, r26
    417c:	fb 1f       	adc	r31, r27
    417e:	44 91       	lpm	r20, Z+
    4180:	44 23       	and	r20, r20
    4182:	59 f0       	breq	.+22     	; 0x419a <httpd_fs_count+0x42>
    4184:	a0 0f       	add	r26, r16
    4186:	b1 1f       	adc	r27, r17
    4188:	8c 91       	ld	r24, X
    418a:	8d 30       	cpi	r24, 0x0D	; 13
    418c:	31 f0       	breq	.+12     	; 0x419a <httpd_fs_count+0x42>
    418e:	8a 30       	cpi	r24, 0x0A	; 10
    4190:	21 f0       	breq	.+8      	; 0x419a <httpd_fs_count+0x42>
     str1[i] == '\r' ||
     str1[i] == '\n') {
    return 0;
  }

  if(str1[i] != pgm_read_byte(&str2[i])) {
    4192:	84 17       	cp	r24, r20
    4194:	a1 f4       	brne	.+40     	; 0x41be <httpd_fs_count+0x66>
    return 1;
  }


  ++i;
    4196:	9f 5f       	subi	r25, 0xFF	; 255
    4198:	ed cf       	rjmp	.-38     	; 0x4174 <httpd_fs_count+0x1c>
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
      return count[i];
    419a:	cc 0f       	add	r28, r28
    419c:	dd 1f       	adc	r29, r29
    419e:	c9 55       	subi	r28, 0x59	; 89
    41a0:	dc 4f       	sbci	r29, 0xFC	; 252
    41a2:	28 81       	ld	r18, Y
    41a4:	39 81       	ldd	r19, Y+1	; 0x01
    41a6:	05 c0       	rjmp	.+10     	; 0x41b2 <httpd_fs_count+0x5a>
  struct httpd_fsdata_file_noconst *f; 
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    41a8:	21 15       	cp	r18, r1
    41aa:	31 05       	cpc	r19, r1
    41ac:	f9 f6       	brne	.-66     	; 0x416c <httpd_fs_count+0x14>
    41ae:	20 e0       	ldi	r18, 0x00	; 0
    41b0:	30 e0       	ldi	r19, 0x00	; 0
      return count[i];
    }
    ++i;
  }
  return 0;
}
    41b2:	c9 01       	movw	r24, r18
    41b4:	df 91       	pop	r29
    41b6:	cf 91       	pop	r28
    41b8:	1f 91       	pop	r17
    41ba:	0f 91       	pop	r16
    41bc:	08 95       	ret
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
      return count[i];
    }
    ++i;
    41be:	21 96       	adiw	r28, 0x01	; 1
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    41c0:	f9 01       	movw	r30, r18
    41c2:	80 81       	ld	r24, Z
    41c4:	91 81       	ldd	r25, Z+1	; 0x01
    41c6:	9c 01       	movw	r18, r24
    41c8:	ef cf       	rjmp	.-34     	; 0x41a8 <httpd_fs_count+0x50>

000041ca <psock_datalen>:
  PT_END(&s->psockpt);
}
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    41ca:	fc 01       	movw	r30, r24
    41cc:	22 89       	ldd	r18, Z+18	; 0x12
    41ce:	33 89       	ldd	r19, Z+19	; 0x13
    41d0:	80 89       	ldd	r24, Z+16	; 0x10
    41d2:	91 89       	ldd	r25, Z+17	; 0x11
    41d4:	28 1b       	sub	r18, r24
    41d6:	39 0b       	sbc	r19, r25
  return psock->bufsize - psock->buf.left;
}
    41d8:	c9 01       	movw	r24, r18
    41da:	08 95       	ret

000041dc <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    41dc:	fc 01       	movw	r30, r24
  if(s->readlen > 0) {
    41de:	84 85       	ldd	r24, Z+12	; 0x0c
    41e0:	95 85       	ldd	r25, Z+13	; 0x0d
    41e2:	89 2b       	or	r24, r25
    41e4:	11 f0       	breq	.+4      	; 0x41ea <psock_newdata+0xe>
    41e6:	81 e0       	ldi	r24, 0x01	; 1
    41e8:	08 95       	ret
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
  } else if(s->state == STATE_READ) {
    41ea:	84 89       	ldd	r24, Z+20	; 0x14
    41ec:	82 30       	cpi	r24, 0x02	; 2
    41ee:	21 f4       	brne	.+8      	; 0x41f8 <psock_newdata+0x1c>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    41f0:	83 e0       	ldi	r24, 0x03	; 3
    41f2:	84 8b       	std	Z+20, r24	; 0x14
    41f4:	80 e0       	ldi	r24, 0x00	; 0
    41f6:	08 95       	ret
    return 0;
    41f8:	80 91 65 04 	lds	r24, 0x0465
    41fc:	90 e0       	ldi	r25, 0x00	; 0
    41fe:	96 95       	lsr	r25
    4200:	87 95       	ror	r24
    4202:	81 70       	andi	r24, 0x01	; 1
    return 1;
  } else {
    /* There is no new data. */
    return 0;
  }
}
    4204:	08 95       	ret

00004206 <psock_readto>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    4206:	dc 01       	movw	r26, r24
  PT_BEGIN(&psock->psockpt);
    4208:	12 96       	adiw	r26, 0x02	; 2
    420a:	8d 91       	ld	r24, X+
    420c:	9c 91       	ld	r25, X
    420e:	13 97       	sbiw	r26, 0x03	; 3
    4210:	00 97       	sbiw	r24, 0x00	; 0
    4212:	29 f0       	breq	.+10     	; 0x421e <psock_readto+0x18>
    4214:	87 55       	subi	r24, 0x57	; 87
    4216:	91 40       	sbci	r25, 0x01	; 1
    4218:	09 f0       	breq	.+2      	; 0x421c <psock_readto+0x16>
    421a:	bd c0       	rjmp	.+378    	; 0x4396 <psock_readto+0x190>
    421c:	1d c0       	rjmp	.+58     	; 0x4258 <psock_readto+0x52>

  buf_setup(&psock->buf, (u8_t *)psock->bufptr, psock->bufsize);
    421e:	52 96       	adiw	r26, 0x12	; 18
    4220:	2d 91       	ld	r18, X+
    4222:	3c 91       	ld	r19, X
    4224:	53 97       	sbiw	r26, 0x13	; 19
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    4226:	18 96       	adiw	r26, 0x08	; 8
    4228:	8d 91       	ld	r24, X+
    422a:	9c 91       	ld	r25, X
    422c:	19 97       	sbiw	r26, 0x09	; 9
    422e:	1f 96       	adiw	r26, 0x0f	; 15
    4230:	9c 93       	st	X, r25
    4232:	8e 93       	st	-X, r24
    4234:	1e 97       	sbiw	r26, 0x0e	; 14
  buf->left = bufsize;
    4236:	51 96       	adiw	r26, 0x11	; 17
    4238:	3c 93       	st	X, r19
    423a:	2e 93       	st	-X, r18
    423c:	50 97       	sbiw	r26, 0x10	; 16
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    423e:	1c 96       	adiw	r26, 0x0c	; 12
    4240:	8d 91       	ld	r24, X+
    4242:	9c 91       	ld	r25, X
    4244:	1d 97       	sbiw	r26, 0x0d	; 13
    4246:	89 2b       	or	r24, r25
    4248:	09 f0       	breq	.+2      	; 0x424c <psock_readto+0x46>
    424a:	60 c0       	rjmp	.+192    	; 0x430c <psock_readto+0x106>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    424c:	87 e5       	ldi	r24, 0x57	; 87
    424e:	91 e0       	ldi	r25, 0x01	; 1
    4250:	13 96       	adiw	r26, 0x03	; 3
    4252:	9c 93       	st	X, r25
    4254:	8e 93       	st	-X, r24
    4256:	12 97       	sbiw	r26, 0x02	; 2
}
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
  if(s->readlen > 0) {
    4258:	1c 96       	adiw	r26, 0x0c	; 12
    425a:	8d 91       	ld	r24, X+
    425c:	9c 91       	ld	r25, X
    425e:	1d 97       	sbiw	r26, 0x0d	; 13
    4260:	89 2b       	or	r24, r25
    4262:	69 f4       	brne	.+26     	; 0x427e <psock_readto+0x78>
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
  } else if(s->state == STATE_READ) {
    4264:	54 96       	adiw	r26, 0x14	; 20
    4266:	8c 91       	ld	r24, X
    4268:	54 97       	sbiw	r26, 0x14	; 20
    426a:	82 30       	cpi	r24, 0x02	; 2
    426c:	21 f4       	brne	.+8      	; 0x4276 <psock_readto+0x70>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    426e:	83 e0       	ldi	r24, 0x03	; 3
    4270:	54 96       	adiw	r26, 0x14	; 20
    4272:	8c 93       	st	X, r24
    4274:	8e c0       	rjmp	.+284    	; 0x4392 <psock_readto+0x18c>
    return 0;
  } else if(uip_newdata()) {
    4276:	80 91 65 04 	lds	r24, 0x0465
    427a:	81 ff       	sbrs	r24, 1
    427c:	8a c0       	rjmp	.+276    	; 0x4392 <psock_readto+0x18c>
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
      psock->state = STATE_READ;
    427e:	82 e0       	ldi	r24, 0x02	; 2
    4280:	54 96       	adiw	r26, 0x14	; 20
    4282:	8c 93       	st	X, r24
    4284:	54 97       	sbiw	r26, 0x14	; 20
      psock->readptr = (u8_t *)uip_appdata;
    4286:	80 91 66 04 	lds	r24, 0x0466
    428a:	90 91 67 04 	lds	r25, 0x0467
    428e:	17 96       	adiw	r26, 0x07	; 7
    4290:	9c 93       	st	X, r25
    4292:	8e 93       	st	-X, r24
    4294:	16 97       	sbiw	r26, 0x06	; 6
      psock->readlen = uip_datalen();
    4296:	80 91 5d 04 	lds	r24, 0x045D
    429a:	90 91 5e 04 	lds	r25, 0x045E
    429e:	1d 96       	adiw	r26, 0x0d	; 13
    42a0:	9c 93       	st	X, r25
    42a2:	8e 93       	st	-X, r24
    42a4:	1c 97       	sbiw	r26, 0x0c	; 12
    42a6:	32 c0       	rjmp	.+100    	; 0x430c <psock_readto+0x106>
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    c = *buf->ptr = **dataptr;
    42a8:	16 96       	adiw	r26, 0x06	; 6
    42aa:	ed 91       	ld	r30, X+
    42ac:	fc 91       	ld	r31, X
    42ae:	17 97       	sbiw	r26, 0x07	; 7
    42b0:	20 81       	ld	r18, Z
    42b2:	1e 96       	adiw	r26, 0x0e	; 14
    42b4:	ed 91       	ld	r30, X+
    42b6:	fc 91       	ld	r31, X
    42b8:	1f 97       	sbiw	r26, 0x0f	; 15
    42ba:	20 83       	st	Z, r18
    ++*dataptr;
    42bc:	16 96       	adiw	r26, 0x06	; 6
    42be:	8d 91       	ld	r24, X+
    42c0:	9c 91       	ld	r25, X
    42c2:	17 97       	sbiw	r26, 0x07	; 7
    42c4:	01 96       	adiw	r24, 0x01	; 1
    42c6:	17 96       	adiw	r26, 0x07	; 7
    42c8:	9c 93       	st	X, r25
    42ca:	8e 93       	st	-X, r24
    42cc:	16 97       	sbiw	r26, 0x06	; 6
    ++buf->ptr;
    42ce:	1e 96       	adiw	r26, 0x0e	; 14
    42d0:	8d 91       	ld	r24, X+
    42d2:	9c 91       	ld	r25, X
    42d4:	1f 97       	sbiw	r26, 0x0f	; 15
    42d6:	01 96       	adiw	r24, 0x01	; 1
    42d8:	1f 96       	adiw	r26, 0x0f	; 15
    42da:	9c 93       	st	X, r25
    42dc:	8e 93       	st	-X, r24
    42de:	1e 97       	sbiw	r26, 0x0e	; 14
    --*datalen;
    42e0:	1c 96       	adiw	r26, 0x0c	; 12
    42e2:	8d 91       	ld	r24, X+
    42e4:	9c 91       	ld	r25, X
    42e6:	1d 97       	sbiw	r26, 0x0d	; 13
    42e8:	01 97       	sbiw	r24, 0x01	; 1
    42ea:	1d 96       	adiw	r26, 0x0d	; 13
    42ec:	9c 93       	st	X, r25
    42ee:	8e 93       	st	-X, r24
    42f0:	1c 97       	sbiw	r26, 0x0c	; 12
    --buf->left;
    42f2:	50 96       	adiw	r26, 0x10	; 16
    42f4:	8d 91       	ld	r24, X+
    42f6:	9c 91       	ld	r25, X
    42f8:	51 97       	sbiw	r26, 0x11	; 17
    42fa:	01 97       	sbiw	r24, 0x01	; 1
    42fc:	51 96       	adiw	r26, 0x11	; 17
    42fe:	9c 93       	st	X, r25
    4300:	8e 93       	st	-X, r24
    4302:	50 97       	sbiw	r26, 0x10	; 16
    
    if(c == endmarker) {
    4304:	26 17       	cp	r18, r22
    4306:	11 f4       	brne	.+4      	; 0x430c <psock_readto+0x106>
    4308:	82 e0       	ldi	r24, 0x02	; 2
    430a:	2f c0       	rjmp	.+94     	; 0x436a <psock_readto+0x164>
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    430c:	50 96       	adiw	r26, 0x10	; 16
    430e:	8d 91       	ld	r24, X+
    4310:	9c 91       	ld	r25, X
    4312:	51 97       	sbiw	r26, 0x11	; 17
    4314:	89 2b       	or	r24, r25
    4316:	31 f0       	breq	.+12     	; 0x4324 <psock_readto+0x11e>
    4318:	1c 96       	adiw	r26, 0x0c	; 12
    431a:	8d 91       	ld	r24, X+
    431c:	9c 91       	ld	r25, X
    431e:	1d 97       	sbiw	r26, 0x0d	; 13
    4320:	89 2b       	or	r24, r25
    4322:	11 f6       	brne	.-124    	; 0x42a8 <psock_readto+0xa2>
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    4324:	1c 96       	adiw	r26, 0x0c	; 12
    4326:	8d 91       	ld	r24, X+
    4328:	9c 91       	ld	r25, X
    432a:	1d 97       	sbiw	r26, 0x0d	; 13
    432c:	89 2b       	or	r24, r25
    432e:	a9 f4       	brne	.+42     	; 0x435a <psock_readto+0x154>
    4330:	80 e0       	ldi	r24, 0x00	; 0
    4332:	1b c0       	rjmp	.+54     	; 0x436a <psock_readto+0x164>
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    c = **dataptr;
    4334:	16 96       	adiw	r26, 0x06	; 6
    4336:	ed 91       	ld	r30, X+
    4338:	fc 91       	ld	r31, X
    433a:	17 97       	sbiw	r26, 0x07	; 7
    433c:	81 91       	ld	r24, Z+
    --*datalen;
    433e:	21 50       	subi	r18, 0x01	; 1
    4340:	30 40       	sbci	r19, 0x00	; 0
    4342:	1d 96       	adiw	r26, 0x0d	; 13
    4344:	3c 93       	st	X, r19
    4346:	2e 93       	st	-X, r18
    4348:	1c 97       	sbiw	r26, 0x0c	; 12
    ++*dataptr;
    434a:	17 96       	adiw	r26, 0x07	; 7
    434c:	fc 93       	st	X, r31
    434e:	ee 93       	st	-X, r30
    4350:	16 97       	sbiw	r26, 0x06	; 6
    
    if(c == endmarker) {
    4352:	86 17       	cp	r24, r22
    4354:	11 f4       	brne	.+4      	; 0x435a <psock_readto+0x154>
    4356:	83 e0       	ldi	r24, 0x03	; 3
    4358:	08 c0       	rjmp	.+16     	; 0x436a <psock_readto+0x164>

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    435a:	1c 96       	adiw	r26, 0x0c	; 12
    435c:	2d 91       	ld	r18, X+
    435e:	3c 91       	ld	r19, X
    4360:	1d 97       	sbiw	r26, 0x0d	; 13
    4362:	21 15       	cp	r18, r1
    4364:	31 05       	cpc	r19, r1
    4366:	31 f7       	brne	.-52     	; 0x4334 <psock_readto+0x12e>
    4368:	81 e0       	ldi	r24, 0x01	; 1
      psock->readptr = (u8_t *)uip_appdata;
      psock->readlen = uip_datalen();
    }
  } while((buf_bufto(&psock->buf, c,
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
    436a:	81 ff       	sbrs	r24, 1
    436c:	68 cf       	rjmp	.-304    	; 0x423e <psock_readto+0x38>
  
  if(psock_datalen(psock) == 0) {
    436e:	52 96       	adiw	r26, 0x12	; 18
    4370:	2d 91       	ld	r18, X+
    4372:	3c 91       	ld	r19, X
    4374:	53 97       	sbiw	r26, 0x13	; 19
    4376:	50 96       	adiw	r26, 0x10	; 16
    4378:	8d 91       	ld	r24, X+
    437a:	9c 91       	ld	r25, X
    437c:	51 97       	sbiw	r26, 0x11	; 17
    437e:	28 17       	cp	r18, r24
    4380:	39 07       	cpc	r19, r25
    4382:	49 f4       	brne	.+18     	; 0x4396 <psock_readto+0x190>
    psock->state = STATE_NONE;
    4384:	54 96       	adiw	r26, 0x14	; 20
    4386:	1c 92       	st	X, r1
    4388:	54 97       	sbiw	r26, 0x14	; 20
    PT_RESTART(&psock->psockpt);
    438a:	13 96       	adiw	r26, 0x03	; 3
    438c:	1c 92       	st	X, r1
    438e:	1e 92       	st	-X, r1
    4390:	12 97       	sbiw	r26, 0x02	; 2
    4392:	80 e0       	ldi	r24, 0x00	; 0
    4394:	08 95       	ret
  }
  PT_END(&psock->psockpt);
    4396:	13 96       	adiw	r26, 0x03	; 3
    4398:	1c 92       	st	X, r1
    439a:	1e 92       	st	-X, r1
    439c:	12 97       	sbiw	r26, 0x02	; 2
    439e:	82 e0       	ldi	r24, 0x02	; 2
}
    43a0:	08 95       	ret

000043a2 <psock_init>:
  PT_END(&psock->psockpt);
}
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    43a2:	fc 01       	movw	r30, r24
  psock->state = STATE_NONE;
    43a4:	14 8a       	std	Z+20, r1	; 0x14
  psock->readlen = 0;
    43a6:	15 86       	std	Z+13, r1	; 0x0d
    43a8:	14 86       	std	Z+12, r1	; 0x0c
  psock->bufptr = buffer;
    43aa:	71 87       	std	Z+9, r23	; 0x09
    43ac:	60 87       	std	Z+8, r22	; 0x08
  psock->bufsize = buffersize;
    43ae:	53 8b       	std	Z+19, r21	; 0x13
    43b0:	42 8b       	std	Z+18, r20	; 0x12
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    43b2:	77 87       	std	Z+15, r23	; 0x0f
    43b4:	66 87       	std	Z+14, r22	; 0x0e
  buf->left = bufsize;
    43b6:	51 8b       	std	Z+17, r21	; 0x11
    43b8:	40 8b       	std	Z+16, r20	; 0x10
  psock->state = STATE_NONE;
  psock->readlen = 0;
  psock->bufptr = buffer;
  psock->bufsize = buffersize;
  buf_setup(&psock->buf, (u8_t *) buffer, buffersize);
  PT_INIT(&psock->pt);
    43ba:	11 82       	std	Z+1, r1	; 0x01
    43bc:	10 82       	st	Z, r1
  PT_INIT(&psock->psockpt);
    43be:	13 82       	std	Z+3, r1	; 0x03
    43c0:	12 82       	std	Z+2, r1	; 0x02
}
    43c2:	08 95       	ret

000043c4 <psock_readbuf>:
  }
  PT_END(&psock->psockpt);
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    43c4:	cf 93       	push	r28
    43c6:	df 93       	push	r29
    43c8:	ec 01       	movw	r28, r24
  PT_BEGIN(&psock->psockpt);
    43ca:	8a 81       	ldd	r24, Y+2	; 0x02
    43cc:	9b 81       	ldd	r25, Y+3	; 0x03
    43ce:	00 97       	sbiw	r24, 0x00	; 0
    43d0:	29 f0       	breq	.+10     	; 0x43dc <psock_readbuf+0x18>
    43d2:	82 57       	subi	r24, 0x72	; 114
    43d4:	91 40       	sbci	r25, 0x01	; 1
    43d6:	09 f0       	breq	.+2      	; 0x43da <psock_readbuf+0x16>
    43d8:	8e c0       	rjmp	.+284    	; 0x44f6 <psock_readbuf+0x132>
    43da:	10 c0       	rjmp	.+32     	; 0x43fc <psock_readbuf+0x38>

  buf_setup(&psock->buf, (u8_t *)psock->bufptr, psock->bufsize);
    43dc:	2a 89       	ldd	r18, Y+18	; 0x12
    43de:	3b 89       	ldd	r19, Y+19	; 0x13
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    43e0:	88 85       	ldd	r24, Y+8	; 0x08
    43e2:	99 85       	ldd	r25, Y+9	; 0x09
    43e4:	9f 87       	std	Y+15, r25	; 0x0f
    43e6:	8e 87       	std	Y+14, r24	; 0x0e
  buf->left = bufsize;
    43e8:	39 8b       	std	Y+17, r19	; 0x11
    43ea:	28 8b       	std	Y+16, r18	; 0x10
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    43ec:	8c 85       	ldd	r24, Y+12	; 0x0c
    43ee:	9d 85       	ldd	r25, Y+13	; 0x0d
    43f0:	89 2b       	or	r24, r25
    43f2:	01 f5       	brne	.+64     	; 0x4434 <psock_readbuf+0x70>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    43f4:	82 e7       	ldi	r24, 0x72	; 114
    43f6:	91 e0       	ldi	r25, 0x01	; 1
    43f8:	9b 83       	std	Y+3, r25	; 0x03
    43fa:	8a 83       	std	Y+2, r24	; 0x02
}
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
  if(s->readlen > 0) {
    43fc:	8c 85       	ldd	r24, Y+12	; 0x0c
    43fe:	9d 85       	ldd	r25, Y+13	; 0x0d
    4400:	89 2b       	or	r24, r25
    4402:	51 f4       	brne	.+20     	; 0x4418 <psock_readbuf+0x54>
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
  } else if(s->state == STATE_READ) {
    4404:	8c 89       	ldd	r24, Y+20	; 0x14
    4406:	82 30       	cpi	r24, 0x02	; 2
    4408:	19 f4       	brne	.+6      	; 0x4410 <psock_readbuf+0x4c>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    440a:	83 e0       	ldi	r24, 0x03	; 3
    440c:	8c 8b       	std	Y+20, r24	; 0x14
    440e:	71 c0       	rjmp	.+226    	; 0x44f2 <psock_readbuf+0x12e>
    return 0;
  } else if(uip_newdata()) {
    4410:	80 91 65 04 	lds	r24, 0x0465
    4414:	81 ff       	sbrs	r24, 1
    4416:	6d c0       	rjmp	.+218    	; 0x44f2 <psock_readbuf+0x12e>

  do {
    if(psock->readlen == 0) {
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
      //printf("Waited for newdata\n");
      psock->state = STATE_READ;
    4418:	82 e0       	ldi	r24, 0x02	; 2
    441a:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    441c:	80 91 66 04 	lds	r24, 0x0466
    4420:	90 91 67 04 	lds	r25, 0x0467
    4424:	9f 83       	std	Y+7, r25	; 0x07
    4426:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    4428:	80 91 5d 04 	lds	r24, 0x045D
    442c:	90 91 5e 04 	lds	r25, 0x045E
    4430:	9d 87       	std	Y+13, r25	; 0x0d
    4432:	8c 87       	std	Y+12, r24	; 0x0c
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
  if(*datalen < buf->left) {
    4434:	ec 85       	ldd	r30, Y+12	; 0x0c
    4436:	fd 85       	ldd	r31, Y+13	; 0x0d
    4438:	28 89       	ldd	r18, Y+16	; 0x10
    443a:	39 89       	ldd	r19, Y+17	; 0x11
    443c:	e2 17       	cp	r30, r18
    443e:	f3 07       	cpc	r31, r19
    4440:	f0 f4       	brcc	.+60     	; 0x447e <psock_readbuf+0xba>
    memcpy(buf->ptr, *dataptr, *datalen);
    4442:	6e 81       	ldd	r22, Y+6	; 0x06
    4444:	7f 81       	ldd	r23, Y+7	; 0x07
    4446:	af 01       	movw	r20, r30
    4448:	8e 85       	ldd	r24, Y+14	; 0x0e
    444a:	9f 85       	ldd	r25, Y+15	; 0x0f
    444c:	0e 94 9c 32 	call	0x6538	; 0x6538 <memcpy>
    buf->ptr += *datalen;
    4450:	8e 85       	ldd	r24, Y+14	; 0x0e
    4452:	9f 85       	ldd	r25, Y+15	; 0x0f
    4454:	2c 85       	ldd	r18, Y+12	; 0x0c
    4456:	3d 85       	ldd	r19, Y+13	; 0x0d
    4458:	82 0f       	add	r24, r18
    445a:	93 1f       	adc	r25, r19
    445c:	9f 87       	std	Y+15, r25	; 0x0f
    445e:	8e 87       	std	Y+14, r24	; 0x0e
    buf->left -= *datalen;
    4460:	88 89       	ldd	r24, Y+16	; 0x10
    4462:	99 89       	ldd	r25, Y+17	; 0x11
    4464:	82 1b       	sub	r24, r18
    4466:	93 0b       	sbc	r25, r19
    4468:	99 8b       	std	Y+17, r25	; 0x11
    446a:	88 8b       	std	Y+16, r24	; 0x10
    *dataptr += *datalen;
    446c:	8e 81       	ldd	r24, Y+6	; 0x06
    446e:	9f 81       	ldd	r25, Y+7	; 0x07
    4470:	82 0f       	add	r24, r18
    4472:	93 1f       	adc	r25, r19
    4474:	9f 83       	std	Y+7, r25	; 0x07
    4476:	8e 83       	std	Y+6, r24	; 0x06
    *datalen = 0;
    4478:	1d 86       	std	Y+13, r1	; 0x0d
    447a:	1c 86       	std	Y+12, r1	; 0x0c
    447c:	b7 cf       	rjmp	.-146    	; 0x43ec <psock_readbuf+0x28>
    447e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4480:	9f 85       	ldd	r25, Y+15	; 0x0f
    4482:	6e 81       	ldd	r22, Y+6	; 0x06
    4484:	7f 81       	ldd	r23, Y+7	; 0x07
    return BUF_NOT_FULL;
  } else if(*datalen == buf->left) {
    4486:	e2 17       	cp	r30, r18
    4488:	f3 07       	cpc	r31, r19
    448a:	b1 f4       	brne	.+44     	; 0x44b8 <psock_readbuf+0xf4>
    memcpy(buf->ptr, *dataptr, *datalen);
    448c:	af 01       	movw	r20, r30
    448e:	0e 94 9c 32 	call	0x6538	; 0x6538 <memcpy>
    buf->ptr += *datalen;
    4492:	8e 85       	ldd	r24, Y+14	; 0x0e
    4494:	9f 85       	ldd	r25, Y+15	; 0x0f
    4496:	2c 85       	ldd	r18, Y+12	; 0x0c
    4498:	3d 85       	ldd	r19, Y+13	; 0x0d
    449a:	82 0f       	add	r24, r18
    449c:	93 1f       	adc	r25, r19
    449e:	9f 87       	std	Y+15, r25	; 0x0f
    44a0:	8e 87       	std	Y+14, r24	; 0x0e
    buf->left = 0;
    44a2:	19 8a       	std	Y+17, r1	; 0x11
    44a4:	18 8a       	std	Y+16, r1	; 0x10
    *dataptr += *datalen;
    44a6:	8e 81       	ldd	r24, Y+6	; 0x06
    44a8:	9f 81       	ldd	r25, Y+7	; 0x07
    44aa:	82 0f       	add	r24, r18
    44ac:	93 1f       	adc	r25, r19
    44ae:	9f 83       	std	Y+7, r25	; 0x07
    44b0:	8e 83       	std	Y+6, r24	; 0x06
    *datalen = 0;
    44b2:	1d 86       	std	Y+13, r1	; 0x0d
    44b4:	1c 86       	std	Y+12, r1	; 0x0c
    44b6:	25 c0       	rjmp	.+74     	; 0x4502 <psock_readbuf+0x13e>
    return BUF_FULL;
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    44b8:	a9 01       	movw	r20, r18
    44ba:	0e 94 9c 32 	call	0x6538	; 0x6538 <memcpy>
    buf->ptr += buf->left;
    44be:	8e 85       	ldd	r24, Y+14	; 0x0e
    44c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    44c2:	28 89       	ldd	r18, Y+16	; 0x10
    44c4:	39 89       	ldd	r19, Y+17	; 0x11
    44c6:	82 0f       	add	r24, r18
    44c8:	93 1f       	adc	r25, r19
    44ca:	9f 87       	std	Y+15, r25	; 0x0f
    44cc:	8e 87       	std	Y+14, r24	; 0x0e
    *datalen -= buf->left;
    44ce:	8c 85       	ldd	r24, Y+12	; 0x0c
    44d0:	9d 85       	ldd	r25, Y+13	; 0x0d
    44d2:	82 1b       	sub	r24, r18
    44d4:	93 0b       	sbc	r25, r19
    44d6:	9d 87       	std	Y+13, r25	; 0x0d
    44d8:	8c 87       	std	Y+12, r24	; 0x0c
    *dataptr += buf->left;
    44da:	8e 81       	ldd	r24, Y+6	; 0x06
    44dc:	9f 81       	ldd	r25, Y+7	; 0x07
    44de:	82 0f       	add	r24, r18
    44e0:	93 1f       	adc	r25, r19
    44e2:	9f 83       	std	Y+7, r25	; 0x07
    44e4:	8e 83       	std	Y+6, r24	; 0x06
    buf->left = 0;
    44e6:	19 8a       	std	Y+17, r1	; 0x11
    44e8:	18 8a       	std	Y+16, r1	; 0x10
    44ea:	0b c0       	rjmp	.+22     	; 0x4502 <psock_readbuf+0x13e>
  } while(buf_bufdata(&psock->buf, psock->bufsize,
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);

  if(psock_datalen(psock) == 0) {
    psock->state = STATE_NONE;
    44ec:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    44ee:	1b 82       	std	Y+3, r1	; 0x03
    44f0:	1a 82       	std	Y+2, r1	; 0x02
    44f2:	80 e0       	ldi	r24, 0x00	; 0
    44f4:	03 c0       	rjmp	.+6      	; 0x44fc <psock_readbuf+0x138>
  }
  PT_END(&psock->psockpt);
    44f6:	1b 82       	std	Y+3, r1	; 0x03
    44f8:	1a 82       	std	Y+2, r1	; 0x02
    44fa:	82 e0       	ldi	r24, 0x02	; 2
}
    44fc:	df 91       	pop	r29
    44fe:	cf 91       	pop	r28
    4500:	08 95       	ret
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);

  if(psock_datalen(psock) == 0) {
    4502:	2a 89       	ldd	r18, Y+18	; 0x12
    4504:	3b 89       	ldd	r19, Y+19	; 0x13
    4506:	88 89       	ldd	r24, Y+16	; 0x10
    4508:	99 89       	ldd	r25, Y+17	; 0x11
    450a:	28 17       	cp	r18, r24
    450c:	39 07       	cpc	r19, r25
    450e:	99 f7       	brne	.-26     	; 0x44f6 <psock_readbuf+0x132>
    4510:	ed cf       	rjmp	.-38     	; 0x44ec <psock_readbuf+0x128>

00004512 <send_data>:
  return BUF_FULL;
}
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    4512:	cf 93       	push	r28
    4514:	df 93       	push	r29
    4516:	ec 01       	movw	r28, r24
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    4518:	8c 89       	ldd	r24, Y+20	; 0x14
    451a:	86 30       	cpi	r24, 0x06	; 6
    451c:	31 f4       	brne	.+12     	; 0x452a <send_data+0x18>
    451e:	80 91 65 04 	lds	r24, 0x0465
    4522:	82 fd       	sbrc	r24, 2
    4524:	02 c0       	rjmp	.+4      	; 0x452a <send_data+0x18>
    4526:	80 e0       	ldi	r24, 0x00	; 0
    4528:	13 c0       	rjmp	.+38     	; 0x4550 <send_data+0x3e>
    if(s->sendlen > uip_mss()) {
    452a:	2a 85       	ldd	r18, Y+10	; 0x0a
    452c:	3b 85       	ldd	r19, Y+11	; 0x0b
    452e:	e0 91 68 04 	lds	r30, 0x0468
    4532:	f0 91 69 04 	lds	r31, 0x0469
    4536:	62 89       	ldd	r22, Z+18	; 0x12
    4538:	73 89       	ldd	r23, Z+19	; 0x13
    453a:	8c 81       	ldd	r24, Y+4	; 0x04
    453c:	9d 81       	ldd	r25, Y+5	; 0x05
    453e:	62 17       	cp	r22, r18
    4540:	73 07       	cpc	r23, r19
    4542:	08 f0       	brcs	.+2      	; 0x4546 <send_data+0x34>
      uip_send(s->sendptr, uip_mss());
    } else {
      uip_send(s->sendptr, s->sendlen);
    4544:	b9 01       	movw	r22, r18
    4546:	0e 94 1c 26 	call	0x4c38	; 0x4c38 <uip_send>
    }
    s->state = STATE_DATA_SENT;
    454a:	86 e0       	ldi	r24, 0x06	; 6
    454c:	8c 8b       	std	Y+20, r24	; 0x14
    454e:	81 e0       	ldi	r24, 0x01	; 1
    return 1;
  }
  return 0;
}
    4550:	df 91       	pop	r29
    4552:	cf 91       	pop	r28
    4554:	08 95       	ret

00004556 <psock_generator_send>:
  PT_END(&s->psockpt);
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    4556:	cf 92       	push	r12
    4558:	df 92       	push	r13
    455a:	ef 92       	push	r14
    455c:	ff 92       	push	r15
    455e:	1f 93       	push	r17
    4560:	cf 93       	push	r28
    4562:	df 93       	push	r29
    4564:	ec 01       	movw	r28, r24
    4566:	7b 01       	movw	r14, r22
    4568:	6a 01       	movw	r12, r20
  PT_BEGIN(&s->psockpt);
    456a:	8a 81       	ldd	r24, Y+2	; 0x02
    456c:	9b 81       	ldd	r25, Y+3	; 0x03
    456e:	00 97       	sbiw	r24, 0x00	; 0
    4570:	29 f0       	breq	.+10     	; 0x457c <psock_generator_send+0x26>
    4572:	8a 52       	subi	r24, 0x2A	; 42
    4574:	91 40       	sbci	r25, 0x01	; 1
    4576:	09 f0       	breq	.+2      	; 0x457a <psock_generator_send+0x24>
    4578:	56 c0       	rjmp	.+172    	; 0x4626 <psock_generator_send+0xd0>
    457a:	1e c0       	rjmp	.+60     	; 0x45b8 <psock_generator_send+0x62>

  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    457c:	61 15       	cp	r22, r1
    457e:	71 05       	cpc	r23, r1
    4580:	21 f4       	brne	.+8      	; 0x458a <psock_generator_send+0x34>
    PT_EXIT(&s->psockpt);
    4582:	1b 82       	std	Y+3, r1	; 0x03
    4584:	1a 82       	std	Y+2, r1	; 0x02
    4586:	81 e0       	ldi	r24, 0x01	; 1
    4588:	51 c0       	rjmp	.+162    	; 0x462c <psock_generator_send+0xd6>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
    458a:	ca 01       	movw	r24, r20
    458c:	fb 01       	movw	r30, r22
    458e:	09 95       	icall
    4590:	9b 87       	std	Y+11, r25	; 0x0b
    4592:	8a 87       	std	Y+10, r24	; 0x0a
  s->sendptr = uip_appdata;
    4594:	80 91 66 04 	lds	r24, 0x0466
    4598:	90 91 67 04 	lds	r25, 0x0467
    459c:	9d 83       	std	Y+5, r25	; 0x05
    459e:	8c 83       	std	Y+4, r24	; 0x04

  s->state = STATE_NONE;  
    45a0:	1c 8a       	std	Y+20, r1	; 0x14
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
    45a2:	80 91 65 04 	lds	r24, 0x0465
    45a6:	82 ff       	sbrs	r24, 2
    45a8:	03 c0       	rjmp	.+6      	; 0x45b0 <psock_generator_send+0x5a>
      generate(arg);
    45aa:	c6 01       	movw	r24, r12
    45ac:	f7 01       	movw	r30, r14
    45ae:	09 95       	icall
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    45b0:	8a e2       	ldi	r24, 0x2A	; 42
    45b2:	91 e0       	ldi	r25, 0x01	; 1
    45b4:	9b 83       	std	Y+3, r25	; 0x03
    45b6:	8a 83       	std	Y+2, r24	; 0x02

/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    45b8:	8c 89       	ldd	r24, Y+20	; 0x14
    45ba:	86 30       	cpi	r24, 0x06	; 6
    45bc:	31 f5       	brne	.+76     	; 0x460a <psock_generator_send+0xb4>
    45be:	80 91 65 04 	lds	r24, 0x0465
    45c2:	80 ff       	sbrs	r24, 0
    45c4:	22 c0       	rjmp	.+68     	; 0x460a <psock_generator_send+0xb4>
    if(s->sendlen > uip_mss()) {
    45c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    45c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    45ca:	e0 91 68 04 	lds	r30, 0x0468
    45ce:	f0 91 69 04 	lds	r31, 0x0469
    45d2:	42 89       	ldd	r20, Z+18	; 0x12
    45d4:	53 89       	ldd	r21, Z+19	; 0x13
    45d6:	2c 81       	ldd	r18, Y+4	; 0x04
    45d8:	3d 81       	ldd	r19, Y+5	; 0x05
    45da:	48 17       	cp	r20, r24
    45dc:	59 07       	cpc	r21, r25
    45de:	58 f4       	brcc	.+22     	; 0x45f6 <psock_generator_send+0xa0>
      s->sendlen -= uip_mss();
    45e0:	84 1b       	sub	r24, r20
    45e2:	95 0b       	sbc	r25, r21
    45e4:	9b 87       	std	Y+11, r25	; 0x0b
    45e6:	8a 87       	std	Y+10, r24	; 0x0a
      s->sendptr += uip_mss();
    45e8:	82 89       	ldd	r24, Z+18	; 0x12
    45ea:	93 89       	ldd	r25, Z+19	; 0x13
    45ec:	28 0f       	add	r18, r24
    45ee:	39 1f       	adc	r19, r25
    45f0:	3d 83       	std	Y+5, r19	; 0x05
    45f2:	2c 83       	std	Y+4, r18	; 0x04
    45f4:	06 c0       	rjmp	.+12     	; 0x4602 <psock_generator_send+0xac>
    } else {
      s->sendptr += s->sendlen;
    45f6:	28 0f       	add	r18, r24
    45f8:	39 1f       	adc	r19, r25
    45fa:	3d 83       	std	Y+5, r19	; 0x05
    45fc:	2c 83       	std	Y+4, r18	; 0x04
      s->sendlen = 0;
    45fe:	1b 86       	std	Y+11, r1	; 0x0b
    4600:	1a 86       	std	Y+10, r1	; 0x0a
    }
    s->state = STATE_ACKED;
    4602:	81 e0       	ldi	r24, 0x01	; 1
    4604:	8c 8b       	std	Y+20, r24	; 0x14
    4606:	11 e0       	ldi	r17, 0x01	; 1
    4608:	01 c0       	rjmp	.+2      	; 0x460c <psock_generator_send+0xb6>
    460a:	10 e0       	ldi	r17, 0x00	; 0
       retransmission. */
    if(uip_rexmit()) {
      generate(arg);
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    460c:	ce 01       	movw	r24, r28
    460e:	0e 94 89 22 	call	0x4512	; 0x4512 <send_data>
    4612:	18 23       	and	r17, r24
    4614:	11 f4       	brne	.+4      	; 0x461a <psock_generator_send+0xc4>
    4616:	80 e0       	ldi	r24, 0x00	; 0
    4618:	09 c0       	rjmp	.+18     	; 0x462c <psock_generator_send+0xd6>
  } while(s->sendlen > 0);
    461a:	8a 85       	ldd	r24, Y+10	; 0x0a
    461c:	9b 85       	ldd	r25, Y+11	; 0x0b
    461e:	89 2b       	or	r24, r25
    4620:	09 f0       	breq	.+2      	; 0x4624 <psock_generator_send+0xce>
    4622:	bf cf       	rjmp	.-130    	; 0x45a2 <psock_generator_send+0x4c>
  
  s->state = STATE_NONE;
    4624:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    4626:	1b 82       	std	Y+3, r1	; 0x03
    4628:	1a 82       	std	Y+2, r1	; 0x02
    462a:	82 e0       	ldi	r24, 0x02	; 2
}
    462c:	df 91       	pop	r29
    462e:	cf 91       	pop	r28
    4630:	1f 91       	pop	r17
    4632:	ff 90       	pop	r15
    4634:	ef 90       	pop	r14
    4636:	df 90       	pop	r13
    4638:	cf 90       	pop	r12
    463a:	08 95       	ret

0000463c <psock_send>:
  return 0;
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s,  const char *buf,
		     unsigned int len))
{
    463c:	1f 93       	push	r17
    463e:	cf 93       	push	r28
    4640:	df 93       	push	r29
    4642:	ec 01       	movw	r28, r24
	PT_BEGIN(&s->psockpt);
    4644:	8a 81       	ldd	r24, Y+2	; 0x02
    4646:	9b 81       	ldd	r25, Y+3	; 0x03
    4648:	00 97       	sbiw	r24, 0x00	; 0
    464a:	29 f0       	breq	.+10     	; 0x4656 <psock_send+0x1a>
    464c:	82 3e       	cpi	r24, 0xE2	; 226
    464e:	91 05       	cpc	r25, r1
    4650:	09 f0       	breq	.+2      	; 0x4654 <psock_send+0x18>
    4652:	48 c0       	rjmp	.+144    	; 0x46e4 <psock_send+0xa8>
    4654:	11 c0       	rjmp	.+34     	; 0x4678 <psock_send+0x3c>
	
	/* If there is no data to send, we exit immediately. */
  if(len == 0) {
    4656:	41 15       	cp	r20, r1
    4658:	51 05       	cpc	r21, r1
    465a:	21 f4       	brne	.+8      	; 0x4664 <psock_send+0x28>
    PT_EXIT(&s->psockpt);
    465c:	1b 82       	std	Y+3, r1	; 0x03
    465e:	1a 82       	std	Y+2, r1	; 0x02
    4660:	81 e0       	ldi	r24, 0x01	; 1
    4662:	43 c0       	rjmp	.+134    	; 0x46ea <psock_send+0xae>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (u8_t *) buf;
    4664:	7d 83       	std	Y+5, r23	; 0x05
    4666:	6c 83       	std	Y+4, r22	; 0x04
  s->sendlen = len;
    4668:	5b 87       	std	Y+11, r21	; 0x0b
    466a:	4a 87       	std	Y+10, r20	; 0x0a
	
  s->state = STATE_NONE;
    466c:	1c 8a       	std	Y+20, r1	; 0x14
    466e:	35 c0       	rjmp	.+106    	; 0x46da <psock_send+0x9e>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    4670:	82 ee       	ldi	r24, 0xE2	; 226
    4672:	90 e0       	ldi	r25, 0x00	; 0
    4674:	9b 83       	std	Y+3, r25	; 0x03
    4676:	8a 83       	std	Y+2, r24	; 0x02

/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    4678:	8c 89       	ldd	r24, Y+20	; 0x14
    467a:	86 30       	cpi	r24, 0x06	; 6
    467c:	31 f5       	brne	.+76     	; 0x46ca <psock_send+0x8e>
    467e:	80 91 65 04 	lds	r24, 0x0465
    4682:	80 ff       	sbrs	r24, 0
    4684:	22 c0       	rjmp	.+68     	; 0x46ca <psock_send+0x8e>
    if(s->sendlen > uip_mss()) {
    4686:	8a 85       	ldd	r24, Y+10	; 0x0a
    4688:	9b 85       	ldd	r25, Y+11	; 0x0b
    468a:	e0 91 68 04 	lds	r30, 0x0468
    468e:	f0 91 69 04 	lds	r31, 0x0469
    4692:	42 89       	ldd	r20, Z+18	; 0x12
    4694:	53 89       	ldd	r21, Z+19	; 0x13
    4696:	2c 81       	ldd	r18, Y+4	; 0x04
    4698:	3d 81       	ldd	r19, Y+5	; 0x05
    469a:	48 17       	cp	r20, r24
    469c:	59 07       	cpc	r21, r25
    469e:	58 f4       	brcc	.+22     	; 0x46b6 <psock_send+0x7a>
      s->sendlen -= uip_mss();
    46a0:	84 1b       	sub	r24, r20
    46a2:	95 0b       	sbc	r25, r21
    46a4:	9b 87       	std	Y+11, r25	; 0x0b
    46a6:	8a 87       	std	Y+10, r24	; 0x0a
      s->sendptr += uip_mss();
    46a8:	82 89       	ldd	r24, Z+18	; 0x12
    46aa:	93 89       	ldd	r25, Z+19	; 0x13
    46ac:	28 0f       	add	r18, r24
    46ae:	39 1f       	adc	r19, r25
    46b0:	3d 83       	std	Y+5, r19	; 0x05
    46b2:	2c 83       	std	Y+4, r18	; 0x04
    46b4:	06 c0       	rjmp	.+12     	; 0x46c2 <psock_send+0x86>
    } else {
      s->sendptr += s->sendlen;
    46b6:	28 0f       	add	r18, r24
    46b8:	39 1f       	adc	r19, r25
    46ba:	3d 83       	std	Y+5, r19	; 0x05
    46bc:	2c 83       	std	Y+4, r18	; 0x04
      s->sendlen = 0;
    46be:	1b 86       	std	Y+11, r1	; 0x0b
    46c0:	1a 86       	std	Y+10, r1	; 0x0a
    }
    s->state = STATE_ACKED;
    46c2:	81 e0       	ldi	r24, 0x01	; 1
    46c4:	8c 8b       	std	Y+20, r24	; 0x14
    46c6:	11 e0       	ldi	r17, 0x01	; 1
    46c8:	01 c0       	rjmp	.+2      	; 0x46cc <psock_send+0x90>
    46ca:	10 e0       	ldi	r17, 0x00	; 0
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    46cc:	ce 01       	movw	r24, r28
    46ce:	0e 94 89 22 	call	0x4512	; 0x4512 <send_data>
    46d2:	18 23       	and	r17, r24
    46d4:	11 f4       	brne	.+4      	; 0x46da <psock_send+0x9e>
    46d6:	80 e0       	ldi	r24, 0x00	; 0
    46d8:	08 c0       	rjmp	.+16     	; 0x46ea <psock_send+0xae>
	
  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    46da:	8a 85       	ldd	r24, Y+10	; 0x0a
    46dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    46de:	89 2b       	or	r24, r25
    46e0:	39 f6       	brne	.-114    	; 0x4670 <psock_send+0x34>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
  }

  s->state = STATE_NONE;
    46e2:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    46e4:	1b 82       	std	Y+3, r1	; 0x03
    46e6:	1a 82       	std	Y+2, r1	; 0x02
    46e8:	82 e0       	ldi	r24, 0x02	; 2
}
    46ea:	df 91       	pop	r29
    46ec:	cf 91       	pop	r28
    46ee:	1f 91       	pop	r17
    46f0:	08 95       	ret

000046f2 <psock_send_P>:

/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send_P(register struct psock *s, const char *buf,
		     unsigned int len))
{
    46f2:	1f 93       	push	r17
    46f4:	cf 93       	push	r28
    46f6:	df 93       	push	r29
    46f8:	ec 01       	movw	r28, r24
	PT_BEGIN(&s->psockpt);
    46fa:	8a 81       	ldd	r24, Y+2	; 0x02
    46fc:	9b 81       	ldd	r25, Y+3	; 0x03
    46fe:	00 97       	sbiw	r24, 0x00	; 0
    4700:	29 f0       	breq	.+10     	; 0x470c <psock_send_P+0x1a>
    4702:	8b 50       	subi	r24, 0x0B	; 11
    4704:	91 40       	sbci	r25, 0x01	; 1
    4706:	09 f0       	breq	.+2      	; 0x470a <psock_send_P+0x18>
    4708:	61 c0       	rjmp	.+194    	; 0x47cc <psock_send_P+0xda>
    470a:	11 c0       	rjmp	.+34     	; 0x472e <psock_send_P+0x3c>
	
	/* If there is no data to send, we exit immediately. */
  if(len == 0) {
    470c:	41 15       	cp	r20, r1
    470e:	51 05       	cpc	r21, r1
    4710:	21 f4       	brne	.+8      	; 0x471a <psock_send_P+0x28>
    PT_EXIT(&s->psockpt);
    4712:	1b 82       	std	Y+3, r1	; 0x03
    4714:	1a 82       	std	Y+2, r1	; 0x02
    4716:	81 e0       	ldi	r24, 0x01	; 1
    4718:	5c c0       	rjmp	.+184    	; 0x47d2 <psock_send_P+0xe0>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = (u8_t *) buf;
    471a:	7d 83       	std	Y+5, r23	; 0x05
    471c:	6c 83       	std	Y+4, r22	; 0x04
  s->sendlen = len;
    471e:	5b 87       	std	Y+11, r21	; 0x0b
    4720:	4a 87       	std	Y+10, r20	; 0x0a
	
	
  s->state = STATE_NONE;
    4722:	1c 8a       	std	Y+20, r1	; 0x14
    4724:	4d c0       	rjmp	.+154    	; 0x47c0 <psock_send_P+0xce>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
    4726:	8b e0       	ldi	r24, 0x0B	; 11
    4728:	91 e0       	ldi	r25, 0x01	; 1
    472a:	9b 83       	std	Y+3, r25	; 0x03
    472c:	8a 83       	std	Y+2, r24	; 0x02

/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    472e:	8c 89       	ldd	r24, Y+20	; 0x14
    4730:	86 30       	cpi	r24, 0x06	; 6
    4732:	31 f5       	brne	.+76     	; 0x4780 <psock_send_P+0x8e>
    4734:	80 91 65 04 	lds	r24, 0x0465
    4738:	80 ff       	sbrs	r24, 0
    473a:	22 c0       	rjmp	.+68     	; 0x4780 <psock_send_P+0x8e>
    if(s->sendlen > uip_mss()) {
    473c:	8a 85       	ldd	r24, Y+10	; 0x0a
    473e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4740:	e0 91 68 04 	lds	r30, 0x0468
    4744:	f0 91 69 04 	lds	r31, 0x0469
    4748:	42 89       	ldd	r20, Z+18	; 0x12
    474a:	53 89       	ldd	r21, Z+19	; 0x13
    474c:	2c 81       	ldd	r18, Y+4	; 0x04
    474e:	3d 81       	ldd	r19, Y+5	; 0x05
    4750:	48 17       	cp	r20, r24
    4752:	59 07       	cpc	r21, r25
    4754:	58 f4       	brcc	.+22     	; 0x476c <psock_send_P+0x7a>
      s->sendlen -= uip_mss();
    4756:	84 1b       	sub	r24, r20
    4758:	95 0b       	sbc	r25, r21
    475a:	9b 87       	std	Y+11, r25	; 0x0b
    475c:	8a 87       	std	Y+10, r24	; 0x0a
      s->sendptr += uip_mss();
    475e:	82 89       	ldd	r24, Z+18	; 0x12
    4760:	93 89       	ldd	r25, Z+19	; 0x13
    4762:	28 0f       	add	r18, r24
    4764:	39 1f       	adc	r19, r25
    4766:	3d 83       	std	Y+5, r19	; 0x05
    4768:	2c 83       	std	Y+4, r18	; 0x04
    476a:	06 c0       	rjmp	.+12     	; 0x4778 <psock_send_P+0x86>
    } else {
      s->sendptr += s->sendlen;
    476c:	28 0f       	add	r18, r24
    476e:	39 1f       	adc	r19, r25
    4770:	3d 83       	std	Y+5, r19	; 0x05
    4772:	2c 83       	std	Y+4, r18	; 0x04
      s->sendlen = 0;
    4774:	1b 86       	std	Y+11, r1	; 0x0b
    4776:	1a 86       	std	Y+10, r1	; 0x0a
    }
    s->state = STATE_ACKED;
    4778:	81 e0       	ldi	r24, 0x01	; 1
    477a:	8c 8b       	std	Y+20, r24	; 0x14
    477c:	11 e0       	ldi	r17, 0x01	; 1
    477e:	01 c0       	rjmp	.+2      	; 0x4782 <psock_send_P+0x90>
    4780:	10 e0       	ldi	r17, 0x00	; 0
}
/*---------------------------------------------------------------------------*/
static char
send_data_P(register struct psock *s)
{
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    4782:	8c 89       	ldd	r24, Y+20	; 0x14
    4784:	86 30       	cpi	r24, 0x06	; 6
    4786:	31 f4       	brne	.+12     	; 0x4794 <psock_send_P+0xa2>
    4788:	80 91 65 04 	lds	r24, 0x0465
    478c:	82 fd       	sbrc	r24, 2
    478e:	02 c0       	rjmp	.+4      	; 0x4794 <psock_send_P+0xa2>
    4790:	80 e0       	ldi	r24, 0x00	; 0
    4792:	14 c0       	rjmp	.+40     	; 0x47bc <psock_send_P+0xca>
    if(s->sendlen > uip_mss()) {
    4794:	8a 85       	ldd	r24, Y+10	; 0x0a
    4796:	9b 85       	ldd	r25, Y+11	; 0x0b
    4798:	e0 91 68 04 	lds	r30, 0x0468
    479c:	f0 91 69 04 	lds	r31, 0x0469
    47a0:	62 89       	ldd	r22, Z+18	; 0x12
    47a2:	73 89       	ldd	r23, Z+19	; 0x13
    47a4:	2c 81       	ldd	r18, Y+4	; 0x04
    47a6:	3d 81       	ldd	r19, Y+5	; 0x05
    47a8:	68 17       	cp	r22, r24
    47aa:	79 07       	cpc	r23, r25
    47ac:	08 f0       	brcs	.+2      	; 0x47b0 <psock_send_P+0xbe>
      uip_send_P(s->sendptr, uip_mss());
    } else {
      uip_send_P(s->sendptr, s->sendlen);
    47ae:	bc 01       	movw	r22, r24
    47b0:	c9 01       	movw	r24, r18
    47b2:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uip_send_P>
    }
    s->state = STATE_DATA_SENT;
    47b6:	86 e0       	ldi	r24, 0x06	; 6
    47b8:	8c 8b       	std	Y+20, r24	; 0x14
    47ba:	81 e0       	ldi	r24, 0x01	; 1
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
    47bc:	81 23       	and	r24, r17
    47be:	49 f0       	breq	.+18     	; 0x47d2 <psock_send_P+0xe0>
	
  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    47c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    47c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    47c4:	89 2b       	or	r24, r25
    47c6:	09 f0       	breq	.+2      	; 0x47ca <psock_send_P+0xd8>
    47c8:	ae cf       	rjmp	.-164    	; 0x4726 <psock_send_P+0x34>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
  }

  s->state = STATE_NONE;
    47ca:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    47cc:	1b 82       	std	Y+3, r1	; 0x03
    47ce:	1a 82       	std	Y+2, r1	; 0x02
    47d0:	82 e0       	ldi	r24, 0x02	; 2
}
    47d2:	df 91       	pop	r29
    47d4:	cf 91       	pop	r28
    47d6:	1f 91       	pop	r17
    47d8:	08 95       	ret

000047da <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    47da:	fc 01       	movw	r30, r24
  t->start += t->interval;
    47dc:	80 81       	ld	r24, Z
    47de:	91 81       	ldd	r25, Z+1	; 0x01
    47e0:	22 81       	ldd	r18, Z+2	; 0x02
    47e2:	33 81       	ldd	r19, Z+3	; 0x03
    47e4:	82 0f       	add	r24, r18
    47e6:	93 1f       	adc	r25, r19
    47e8:	91 83       	std	Z+1, r25	; 0x01
    47ea:	80 83       	st	Z, r24
}
    47ec:	08 95       	ret

000047ee <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    47ee:	0f 93       	push	r16
    47f0:	1f 93       	push	r17
    47f2:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    47f4:	0e 94 c2 10 	call	0x2184	; 0x2184 <clock_time>
    47f8:	40 e0       	ldi	r20, 0x00	; 0
    47fa:	50 e0       	ldi	r21, 0x00	; 0
    47fc:	f8 01       	movw	r30, r16
    47fe:	20 81       	ld	r18, Z
    4800:	31 81       	ldd	r19, Z+1	; 0x01
    4802:	82 1b       	sub	r24, r18
    4804:	93 0b       	sbc	r25, r19
    4806:	22 81       	ldd	r18, Z+2	; 0x02
    4808:	33 81       	ldd	r19, Z+3	; 0x03
    480a:	82 17       	cp	r24, r18
    480c:	93 07       	cpc	r25, r19
    480e:	14 f0       	brlt	.+4      	; 0x4814 <timer_expired+0x26>
    4810:	41 e0       	ldi	r20, 0x01	; 1
    4812:	50 e0       	ldi	r21, 0x00	; 0
}
    4814:	ca 01       	movw	r24, r20
    4816:	1f 91       	pop	r17
    4818:	0f 91       	pop	r16
    481a:	08 95       	ret

0000481c <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    481c:	0f 93       	push	r16
    481e:	1f 93       	push	r17
    4820:	8c 01       	movw	r16, r24
  t->start = clock_time();
    4822:	0e 94 c2 10 	call	0x2184	; 0x2184 <clock_time>
    4826:	f8 01       	movw	r30, r16
    4828:	91 83       	std	Z+1, r25	; 0x01
    482a:	80 83       	st	Z, r24
}
    482c:	1f 91       	pop	r17
    482e:	0f 91       	pop	r16
    4830:	08 95       	ret

00004832 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    4832:	0f 93       	push	r16
    4834:	1f 93       	push	r17
    4836:	8c 01       	movw	r16, r24
  t->interval = interval;
    4838:	fc 01       	movw	r30, r24
    483a:	73 83       	std	Z+3, r23	; 0x03
    483c:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    483e:	0e 94 c2 10 	call	0x2184	; 0x2184 <clock_time>
    4842:	f8 01       	movw	r30, r16
    4844:	91 83       	std	Z+1, r25	; 0x01
    4846:	80 83       	st	Z, r24
}
    4848:	1f 91       	pop	r17
    484a:	0f 91       	pop	r16
    484c:	08 95       	ret

0000484e <uip_setipid>:

static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
    484e:	90 93 c4 03 	sts	0x03C4, r25
    4852:	80 93 c3 03 	sts	0x03C3, r24
    4856:	08 95       	ret

00004858 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    4858:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    485a:	53 81       	ldd	r21, Z+3	; 0x03
    485c:	56 0f       	add	r21, r22
    485e:	50 93 64 04 	sts	0x0464, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    4862:	27 2f       	mov	r18, r23
    4864:	33 27       	eor	r19, r19
    4866:	42 81       	ldd	r20, Z+2	; 0x02
    4868:	42 0f       	add	r20, r18
    486a:	40 93 63 04 	sts	0x0463, r20
  uip_acc32[1] = op32[1];
    486e:	a1 81       	ldd	r26, Z+1	; 0x01
    4870:	a0 93 62 04 	sts	0x0462, r26
  uip_acc32[0] = op32[0];
    4874:	e0 81       	ld	r30, Z
    4876:	e0 93 61 04 	sts	0x0461, r30
  
  if(uip_acc32[2] < (op16 >> 8)) {
    487a:	84 2f       	mov	r24, r20
    487c:	90 e0       	ldi	r25, 0x00	; 0
    487e:	82 17       	cp	r24, r18
    4880:	93 07       	cpc	r25, r19
    4882:	48 f4       	brcc	.+18     	; 0x4896 <uip_add32+0x3e>
    ++uip_acc32[1];
    4884:	8a 2f       	mov	r24, r26
    4886:	8f 5f       	subi	r24, 0xFF	; 255
    4888:	80 93 62 04 	sts	0x0462, r24
    if(uip_acc32[1] == 0) {
    488c:	88 23       	and	r24, r24
    488e:	19 f4       	brne	.+6      	; 0x4896 <uip_add32+0x3e>
      ++uip_acc32[0];
    4890:	ef 5f       	subi	r30, 0xFF	; 255
    4892:	e0 93 61 04 	sts	0x0461, r30
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
    4896:	85 2f       	mov	r24, r21
    4898:	90 e0       	ldi	r25, 0x00	; 0
    489a:	70 70       	andi	r23, 0x00	; 0
    489c:	86 17       	cp	r24, r22
    489e:	97 07       	cpc	r25, r23
    48a0:	90 f4       	brcc	.+36     	; 0x48c6 <uip_add32+0x6e>
    ++uip_acc32[2];
    48a2:	84 2f       	mov	r24, r20
    48a4:	8f 5f       	subi	r24, 0xFF	; 255
    48a6:	80 93 63 04 	sts	0x0463, r24
    if(uip_acc32[2] == 0) {
    48aa:	88 23       	and	r24, r24
    48ac:	61 f4       	brne	.+24     	; 0x48c6 <uip_add32+0x6e>
      ++uip_acc32[1];
    48ae:	80 91 62 04 	lds	r24, 0x0462
    48b2:	8f 5f       	subi	r24, 0xFF	; 255
    48b4:	80 93 62 04 	sts	0x0462, r24
      if(uip_acc32[1] == 0) {
    48b8:	88 23       	and	r24, r24
    48ba:	29 f4       	brne	.+10     	; 0x48c6 <uip_add32+0x6e>
	++uip_acc32[0];
    48bc:	80 91 61 04 	lds	r24, 0x0461
    48c0:	8f 5f       	subi	r24, 0xFF	; 255
    48c2:	80 93 61 04 	sts	0x0461, r24
    48c6:	08 95       	ret

000048c8 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    48c8:	fc 01       	movw	r30, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    48ca:	61 50       	subi	r22, 0x01	; 1
    48cc:	70 40       	sbci	r23, 0x00	; 0
    48ce:	68 0f       	add	r22, r24
    48d0:	79 1f       	adc	r23, r25
    48d2:	20 e0       	ldi	r18, 0x00	; 0
    48d4:	30 e0       	ldi	r19, 0x00	; 0
    48d6:	0e c0       	rjmp	.+28     	; 0x48f4 <uip_chksum+0x2c>
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    48d8:	50 81       	ld	r21, Z
    48da:	40 e0       	ldi	r20, 0x00	; 0
    48dc:	81 81       	ldd	r24, Z+1	; 0x01
    48de:	da 01       	movw	r26, r20
    48e0:	a8 0f       	add	r26, r24
    48e2:	b1 1d       	adc	r27, r1
    sum += t;
    48e4:	2a 0f       	add	r18, r26
    48e6:	3b 1f       	adc	r19, r27
    if(sum < t) {
    48e8:	2a 17       	cp	r18, r26
    48ea:	3b 07       	cpc	r19, r27
    48ec:	10 f4       	brcc	.+4      	; 0x48f2 <uip_chksum+0x2a>
      sum++;		/* carry */
    48ee:	2f 5f       	subi	r18, 0xFF	; 255
    48f0:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    48f2:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    48f4:	e6 17       	cp	r30, r22
    48f6:	f7 07       	cpc	r31, r23
    48f8:	78 f3       	brcs	.-34     	; 0x48d8 <uip_chksum+0x10>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    48fa:	e6 17       	cp	r30, r22
    48fc:	f7 07       	cpc	r31, r23
    48fe:	49 f4       	brne	.+18     	; 0x4912 <uip_chksum+0x4a>
    t = (dataptr[0] << 8) + 0;
    4900:	90 81       	ld	r25, Z
    4902:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    4904:	28 0f       	add	r18, r24
    4906:	39 1f       	adc	r19, r25
    if(sum < t) {
    4908:	28 17       	cp	r18, r24
    490a:	39 07       	cpc	r19, r25
    490c:	10 f4       	brcc	.+4      	; 0x4912 <uip_chksum+0x4a>
      sum++;		/* carry */
    490e:	2f 5f       	subi	r18, 0xFF	; 255
    4910:	3f 4f       	sbci	r19, 0xFF	; 255
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
  return htons(chksum(0, (u8_t *)data, len));
}
    4912:	83 2f       	mov	r24, r19
    4914:	92 2f       	mov	r25, r18
    4916:	08 95       	ret

00004918 <uip_ipchksum>:
/*---------------------------------------------------------------------------*/
#ifndef UIP_ARCH_IPCHKSUM
u16_t
uip_ipchksum(void)
{
    4918:	ee e0       	ldi	r30, 0x0E	; 14
    491a:	f6 e0       	ldi	r31, 0x06	; 6
    491c:	40 e0       	ldi	r20, 0x00	; 0
    491e:	50 e0       	ldi	r21, 0x00	; 0

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    4920:	30 81       	ld	r19, Z
    4922:	20 e0       	ldi	r18, 0x00	; 0
    4924:	81 81       	ldd	r24, Z+1	; 0x01
    4926:	b9 01       	movw	r22, r18
    4928:	68 0f       	add	r22, r24
    492a:	71 1d       	adc	r23, r1
    sum += t;
    492c:	46 0f       	add	r20, r22
    492e:	57 1f       	adc	r21, r23
    if(sum < t) {
    4930:	46 17       	cp	r20, r22
    4932:	57 07       	cpc	r21, r23
    4934:	10 f4       	brcc	.+4      	; 0x493a <uip_ipchksum+0x22>
      sum++;		/* carry */
    4936:	4f 5f       	subi	r20, 0xFF	; 255
    4938:	5f 4f       	sbci	r21, 0xFF	; 255
    }
    dataptr += 2;
    493a:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    493c:	76 e0       	ldi	r23, 0x06	; 6
    493e:	e1 32       	cpi	r30, 0x21	; 33
    4940:	f7 07       	cpc	r31, r23
    4942:	70 f3       	brcs	.-36     	; 0x4920 <uip_ipchksum+0x8>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    4944:	86 e0       	ldi	r24, 0x06	; 6
    4946:	e1 32       	cpi	r30, 0x21	; 33
    4948:	f8 07       	cpc	r31, r24
    494a:	51 f4       	brne	.+20     	; 0x4960 <uip_ipchksum+0x48>
    t = (dataptr[0] << 8) + 0;
    494c:	90 81       	ld	r25, Z
    494e:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    4950:	48 0f       	add	r20, r24
    4952:	59 1f       	adc	r21, r25
    if(sum < t) {
    4954:	48 17       	cp	r20, r24
    4956:	59 07       	cpc	r21, r25
    4958:	18 f4       	brcc	.+6      	; 0x4960 <uip_ipchksum+0x48>
      sum++;		/* carry */
    495a:	4f 5f       	subi	r20, 0xFF	; 255
    495c:	5f 4f       	sbci	r21, 0xFF	; 255
    495e:	06 c0       	rjmp	.+12     	; 0x496c <uip_ipchksum+0x54>
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    4960:	41 15       	cp	r20, r1
    4962:	51 05       	cpc	r21, r1
    4964:	19 f4       	brne	.+6      	; 0x496c <uip_ipchksum+0x54>
    4966:	2f ef       	ldi	r18, 0xFF	; 255
    4968:	3f ef       	ldi	r19, 0xFF	; 255
    496a:	02 c0       	rjmp	.+4      	; 0x4970 <uip_ipchksum+0x58>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    496c:	34 2f       	mov	r19, r20
    496e:	25 2f       	mov	r18, r21
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
}
    4970:	c9 01       	movw	r24, r18
    4972:	08 95       	ret

00004974 <upper_layer_chksum>:
#endif
/*---------------------------------------------------------------------------*/
static u16_t
upper_layer_chksum(u8_t proto)
{
    4974:	90 91 11 06 	lds	r25, 0x0611
    4978:	69 2f       	mov	r22, r25
    497a:	70 e0       	ldi	r23, 0x00	; 0
    497c:	64 51       	subi	r22, 0x14	; 20
    497e:	70 40       	sbci	r23, 0x00	; 0
    4980:	30 91 10 06 	lds	r19, 0x0610
    4984:	20 e0       	ldi	r18, 0x00	; 0
    4986:	62 0f       	add	r22, r18
    4988:	73 1f       	adc	r23, r19
#endif /* UIP_CONF_IPV6 */
  
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
    498a:	ab 01       	movw	r20, r22
    498c:	48 0f       	add	r20, r24
    498e:	51 1d       	adc	r21, r1
    4990:	ea e1       	ldi	r30, 0x1A	; 26
    4992:	f6 e0       	ldi	r31, 0x06	; 6

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    4994:	30 81       	ld	r19, Z
    4996:	20 e0       	ldi	r18, 0x00	; 0
    4998:	81 81       	ldd	r24, Z+1	; 0x01
    499a:	d9 01       	movw	r26, r18
    499c:	a8 0f       	add	r26, r24
    499e:	b1 1d       	adc	r27, r1
    sum += t;
    49a0:	4a 0f       	add	r20, r26
    49a2:	5b 1f       	adc	r21, r27
    if(sum < t) {
    49a4:	4a 17       	cp	r20, r26
    49a6:	5b 07       	cpc	r21, r27
    49a8:	10 f4       	brcc	.+4      	; 0x49ae <upper_layer_chksum+0x3a>
      sum++;		/* carry */
    49aa:	4f 5f       	subi	r20, 0xFF	; 255
    49ac:	5f 4f       	sbci	r21, 0xFF	; 255
    }
    dataptr += 2;
    49ae:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    49b0:	b6 e0       	ldi	r27, 0x06	; 6
    49b2:	e1 32       	cpi	r30, 0x21	; 33
    49b4:	fb 07       	cpc	r31, r27
    49b6:	70 f3       	brcs	.-36     	; 0x4994 <upper_layer_chksum+0x20>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    49b8:	86 e0       	ldi	r24, 0x06	; 6
    49ba:	e1 32       	cpi	r30, 0x21	; 33
    49bc:	f8 07       	cpc	r31, r24
    49be:	49 f4       	brne	.+18     	; 0x49d2 <upper_layer_chksum+0x5e>
    t = (dataptr[0] << 8) + 0;
    49c0:	90 81       	ld	r25, Z
    49c2:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    49c4:	48 0f       	add	r20, r24
    49c6:	59 1f       	adc	r21, r25
    if(sum < t) {
    49c8:	48 17       	cp	r20, r24
    49ca:	59 07       	cpc	r21, r25
    49cc:	10 f4       	brcc	.+4      	; 0x49d2 <upper_layer_chksum+0x5e>
      sum++;		/* carry */
    49ce:	4f 5f       	subi	r20, 0xFF	; 255
    49d0:	5f 4f       	sbci	r21, 0xFF	; 255
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    49d2:	6f 5d       	subi	r22, 0xDF	; 223
    49d4:	79 4f       	sbci	r23, 0xF9	; 249
    49d6:	e2 e2       	ldi	r30, 0x22	; 34
    49d8:	f6 e0       	ldi	r31, 0x06	; 6
    49da:	0e c0       	rjmp	.+28     	; 0x49f8 <upper_layer_chksum+0x84>
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    49dc:	30 81       	ld	r19, Z
    49de:	20 e0       	ldi	r18, 0x00	; 0
    49e0:	81 81       	ldd	r24, Z+1	; 0x01
    49e2:	d9 01       	movw	r26, r18
    49e4:	a8 0f       	add	r26, r24
    49e6:	b1 1d       	adc	r27, r1
    sum += t;
    49e8:	4a 0f       	add	r20, r26
    49ea:	5b 1f       	adc	r21, r27
    if(sum < t) {
    49ec:	4a 17       	cp	r20, r26
    49ee:	5b 07       	cpc	r21, r27
    49f0:	10 f4       	brcc	.+4      	; 0x49f6 <upper_layer_chksum+0x82>
      sum++;		/* carry */
    49f2:	4f 5f       	subi	r20, 0xFF	; 255
    49f4:	5f 4f       	sbci	r21, 0xFF	; 255
    }
    dataptr += 2;
    49f6:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    49f8:	e6 17       	cp	r30, r22
    49fa:	f7 07       	cpc	r31, r23
    49fc:	78 f3       	brcs	.-34     	; 0x49dc <upper_layer_chksum+0x68>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    49fe:	e6 17       	cp	r30, r22
    4a00:	f7 07       	cpc	r31, r23
    4a02:	51 f4       	brne	.+20     	; 0x4a18 <upper_layer_chksum+0xa4>
    t = (dataptr[0] << 8) + 0;
    4a04:	90 81       	ld	r25, Z
    4a06:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    4a08:	48 0f       	add	r20, r24
    4a0a:	59 1f       	adc	r21, r25
    if(sum < t) {
    4a0c:	48 17       	cp	r20, r24
    4a0e:	59 07       	cpc	r21, r25
    4a10:	18 f4       	brcc	.+6      	; 0x4a18 <upper_layer_chksum+0xa4>
      sum++;		/* carry */
    4a12:	4f 5f       	subi	r20, 0xFF	; 255
    4a14:	5f 4f       	sbci	r21, 0xFF	; 255
    4a16:	06 c0       	rjmp	.+12     	; 0x4a24 <upper_layer_chksum+0xb0>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
    4a18:	41 15       	cp	r20, r1
    4a1a:	51 05       	cpc	r21, r1
    4a1c:	19 f4       	brne	.+6      	; 0x4a24 <upper_layer_chksum+0xb0>
    4a1e:	2f ef       	ldi	r18, 0xFF	; 255
    4a20:	3f ef       	ldi	r19, 0xFF	; 255
    4a22:	02 c0       	rjmp	.+4      	; 0x4a28 <upper_layer_chksum+0xb4>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    4a24:	34 2f       	mov	r19, r20
    4a26:	25 2f       	mov	r18, r21
  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
}
    4a28:	c9 01       	movw	r24, r18
    4a2a:	08 95       	ret

00004a2c <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    4a2c:	86 e0       	ldi	r24, 0x06	; 6
    4a2e:	0e 94 ba 24 	call	0x4974	; 0x4974 <upper_layer_chksum>
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    4a32:	08 95       	ret

00004a34 <uip_udpchksum>:
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
u16_t
uip_udpchksum(void)
{
    4a34:	81 e1       	ldi	r24, 0x11	; 17
    4a36:	0e 94 ba 24 	call	0x4974	; 0x4974 <upper_layer_chksum>
  return upper_layer_chksum(UIP_PROTO_UDP);
}
    4a3a:	08 95       	ret

00004a3c <uip_init>:
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
    4a3c:	80 e0       	ldi	r24, 0x00	; 0
    4a3e:	09 c0       	rjmp	.+18     	; 0x4a52 <uip_init+0x16>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    4a40:	e8 2f       	mov	r30, r24
    4a42:	f0 e0       	ldi	r31, 0x00	; 0
    4a44:	ee 0f       	add	r30, r30
    4a46:	ff 1f       	adc	r31, r31
    4a48:	ec 53       	subi	r30, 0x3C	; 60
    4a4a:	fa 4f       	sbci	r31, 0xFA	; 250
    4a4c:	11 82       	std	Z+1, r1	; 0x01
    4a4e:	10 82       	st	Z, r1
    4a50:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    4a52:	82 30       	cpi	r24, 0x02	; 2
    4a54:	a8 f3       	brcs	.-22     	; 0x4a40 <uip_init+0x4>
    4a56:	20 e0       	ldi	r18, 0x00	; 0
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    4a58:	4d ea       	ldi	r20, 0xAD	; 173
    4a5a:	50 e0       	ldi	r21, 0x00	; 0
    4a5c:	0d c0       	rjmp	.+26     	; 0x4a78 <uip_init+0x3c>
    4a5e:	82 2f       	mov	r24, r18
    4a60:	90 e0       	ldi	r25, 0x00	; 0
    4a62:	84 9f       	mul	r24, r20
    4a64:	f0 01       	movw	r30, r0
    4a66:	85 9f       	mul	r24, r21
    4a68:	f0 0d       	add	r31, r0
    4a6a:	94 9f       	mul	r25, r20
    4a6c:	f0 0d       	add	r31, r0
    4a6e:	11 24       	eor	r1, r1
    4a70:	e6 59       	subi	r30, 0x96	; 150
    4a72:	fb 4f       	sbci	r31, 0xFB	; 251
    4a74:	11 8e       	std	Z+25, r1	; 0x19
    4a76:	2f 5f       	subi	r18, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    4a78:	22 30       	cpi	r18, 0x02	; 2
    4a7a:	88 f3       	brcs	.-30     	; 0x4a5e <uip_init+0x22>
    4a7c:	20 93 cb 03 	sts	0x03CB, r18
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    4a80:	80 e0       	ldi	r24, 0x00	; 0
    4a82:	94 e0       	ldi	r25, 0x04	; 4
    4a84:	90 93 ca 03 	sts	0x03CA, r25
    4a88:	80 93 c9 03 	sts	0x03C9, r24
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    4a8c:	08 95       	ret

00004a8e <uip_connect>:
/*---------------------------------------------------------------------------*/
#if UIP_ACTIVE_OPEN
struct uip_conn *
uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
{
    4a8e:	cf 93       	push	r28
    4a90:	df 93       	push	r29
    4a92:	ec 01       	movw	r28, r24
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
    4a94:	40 91 c9 03 	lds	r20, 0x03C9
    4a98:	50 91 ca 03 	lds	r21, 0x03CA
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    4a9c:	bd ea       	ldi	r27, 0xAD	; 173
{
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    4a9e:	4f 5f       	subi	r20, 0xFF	; 255
    4aa0:	5f 4f       	sbci	r21, 0xFF	; 255

  if(lastport >= 32000) {
    4aa2:	8d e7       	ldi	r24, 0x7D	; 125
    4aa4:	40 30       	cpi	r20, 0x00	; 0
    4aa6:	58 07       	cpc	r21, r24
    4aa8:	10 f0       	brcs	.+4      	; 0x4aae <uip_connect+0x20>
    4aaa:	40 e0       	ldi	r20, 0x00	; 0
    4aac:	50 e1       	ldi	r21, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    4aae:	34 2f       	mov	r19, r20
    4ab0:	25 2f       	mov	r18, r21
    4ab2:	a0 e0       	ldi	r26, 0x00	; 0
    4ab4:	0e c0       	rjmp	.+28     	; 0x4ad2 <uip_connect+0x44>
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    4ab6:	ab 9f       	mul	r26, r27
    4ab8:	f0 01       	movw	r30, r0
    4aba:	11 24       	eor	r1, r1
    4abc:	e6 59       	subi	r30, 0x96	; 150
    4abe:	fb 4f       	sbci	r31, 0xFB	; 251
    if(conn->tcpstateflags != UIP_CLOSED &&
    4ac0:	81 8d       	ldd	r24, Z+25	; 0x19
    4ac2:	88 23       	and	r24, r24
    4ac4:	29 f0       	breq	.+10     	; 0x4ad0 <uip_connect+0x42>
    4ac6:	84 81       	ldd	r24, Z+4	; 0x04
    4ac8:	95 81       	ldd	r25, Z+5	; 0x05
    4aca:	82 17       	cp	r24, r18
    4acc:	93 07       	cpc	r25, r19
    4ace:	39 f3       	breq	.-50     	; 0x4a9e <uip_connect+0x10>
       conn->lport == htons(lastport)) {
      goto again;
    4ad0:	af 5f       	subi	r26, 0xFF	; 255
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    4ad2:	a2 30       	cpi	r26, 0x02	; 2
    4ad4:	81 f7       	brne	.-32     	; 0x4ab6 <uip_connect+0x28>
    4ad6:	40 93 c9 03 	sts	0x03C9, r20
    4ada:	50 93 ca 03 	sts	0x03CA, r21
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    4ade:	10 92 cb 03 	sts	0x03CB, r1
    4ae2:	e0 e0       	ldi	r30, 0x00	; 0
    4ae4:	f0 e0       	ldi	r31, 0x00	; 0
    4ae6:	20 e0       	ldi	r18, 0x00	; 0
    cconn = &uip_conns[c];
    4ae8:	3d ea       	ldi	r19, 0xAD	; 173
    4aea:	1a c0       	rjmp	.+52     	; 0x4b20 <uip_connect+0x92>
    4aec:	23 9f       	mul	r18, r19
    4aee:	d0 01       	movw	r26, r0
    4af0:	11 24       	eor	r1, r1
    4af2:	a6 59       	subi	r26, 0x96	; 150
    4af4:	bb 4f       	sbci	r27, 0xFB	; 251
    if(cconn->tcpstateflags == UIP_CLOSED) {
    4af6:	59 96       	adiw	r26, 0x19	; 25
    4af8:	8c 91       	ld	r24, X
    4afa:	59 97       	sbiw	r26, 0x19	; 25
    4afc:	88 23       	and	r24, r24
    4afe:	21 f4       	brne	.+8      	; 0x4b08 <uip_connect+0x7a>
    4b00:	20 93 cb 03 	sts	0x03CB, r18
    4b04:	fd 01       	movw	r30, r26
    4b06:	10 c0       	rjmp	.+32     	; 0x4b28 <uip_connect+0x9a>
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    4b08:	87 30       	cpi	r24, 0x07	; 7
    4b0a:	49 f4       	brne	.+18     	; 0x4b1e <uip_connect+0x90>
      if(conn == 0 ||
    4b0c:	30 97       	sbiw	r30, 0x00	; 0
    4b0e:	31 f0       	breq	.+12     	; 0x4b1c <uip_connect+0x8e>
    4b10:	5a 96       	adiw	r26, 0x1a	; 26
    4b12:	9c 91       	ld	r25, X
    4b14:	5a 97       	sbiw	r26, 0x1a	; 26
    4b16:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b18:	89 17       	cp	r24, r25
    4b1a:	08 f4       	brcc	.+2      	; 0x4b1e <uip_connect+0x90>
    4b1c:	fd 01       	movw	r30, r26
    4b1e:	2f 5f       	subi	r18, 0xFF	; 255
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    4b20:	22 30       	cpi	r18, 0x02	; 2
    4b22:	20 f3       	brcs	.-56     	; 0x4aec <uip_connect+0x5e>
    4b24:	20 93 cb 03 	sts	0x03CB, r18
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    4b28:	30 97       	sbiw	r30, 0x00	; 0
    4b2a:	61 f1       	breq	.+88     	; 0x4b84 <uip_connect+0xf6>
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;
    4b2c:	82 e0       	ldi	r24, 0x02	; 2
    4b2e:	81 8f       	std	Z+25, r24	; 0x19

  conn->snd_nxt[0] = iss[0];
    4b30:	80 91 c5 03 	lds	r24, 0x03C5
    4b34:	84 87       	std	Z+12, r24	; 0x0c
  conn->snd_nxt[1] = iss[1];
    4b36:	80 91 c6 03 	lds	r24, 0x03C6
    4b3a:	85 87       	std	Z+13, r24	; 0x0d
  conn->snd_nxt[2] = iss[2];
    4b3c:	80 91 c7 03 	lds	r24, 0x03C7
    4b40:	86 87       	std	Z+14, r24	; 0x0e
  conn->snd_nxt[3] = iss[3];
    4b42:	80 91 c8 03 	lds	r24, 0x03C8
    4b46:	87 87       	std	Z+15, r24	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    4b48:	86 ea       	ldi	r24, 0xA6	; 166
    4b4a:	95 e0       	ldi	r25, 0x05	; 5
    4b4c:	93 8b       	std	Z+19, r25	; 0x13
    4b4e:	82 8b       	std	Z+18, r24	; 0x12
    4b50:	95 8b       	std	Z+21, r25	; 0x15
    4b52:	84 8b       	std	Z+20, r24	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    4b54:	81 e0       	ldi	r24, 0x01	; 1
    4b56:	90 e0       	ldi	r25, 0x00	; 0
    4b58:	91 8b       	std	Z+17, r25	; 0x11
    4b5a:	80 8b       	std	Z+16, r24	; 0x10
  conn->nrtx = 0;
    4b5c:	13 8e       	std	Z+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    4b5e:	81 e0       	ldi	r24, 0x01	; 1
    4b60:	82 8f       	std	Z+26, r24	; 0x1a
  conn->rto = UIP_RTO;
    4b62:	83 e0       	ldi	r24, 0x03	; 3
    4b64:	80 8f       	std	Z+24, r24	; 0x18
  conn->sa = 0;
    4b66:	16 8a       	std	Z+22, r1	; 0x16
  conn->sv = 16;   /* Initial value of the RTT variance. */
    4b68:	80 e1       	ldi	r24, 0x10	; 16
    4b6a:	87 8b       	std	Z+23, r24	; 0x17
  conn->lport = htons(lastport);
    4b6c:	54 83       	std	Z+4, r21	; 0x04
    4b6e:	45 83       	std	Z+5, r20	; 0x05
  conn->rport = rport;
    4b70:	77 83       	std	Z+7, r23	; 0x07
    4b72:	66 83       	std	Z+6, r22	; 0x06
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    4b74:	88 81       	ld	r24, Y
    4b76:	99 81       	ldd	r25, Y+1	; 0x01
    4b78:	91 83       	std	Z+1, r25	; 0x01
    4b7a:	80 83       	st	Z, r24
    4b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4b80:	93 83       	std	Z+3, r25	; 0x03
    4b82:	82 83       	std	Z+2, r24	; 0x02
  
  return conn;
}
    4b84:	cf 01       	movw	r24, r30
    4b86:	df 91       	pop	r29
    4b88:	cf 91       	pop	r28
    4b8a:	08 95       	ret

00004b8c <uip_unlisten>:
}
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
    4b8c:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    4b8e:	10 92 cb 03 	sts	0x03CB, r1
    4b92:	20 e0       	ldi	r18, 0x00	; 0
    4b94:	13 c0       	rjmp	.+38     	; 0x4bbc <uip_unlisten+0x30>
    if(uip_listenports[c] == port) {
    4b96:	e2 2f       	mov	r30, r18
    4b98:	f0 e0       	ldi	r31, 0x00	; 0
    4b9a:	32 2f       	mov	r19, r18
    4b9c:	3f 5f       	subi	r19, 0xFF	; 255
    4b9e:	ee 0f       	add	r30, r30
    4ba0:	ff 1f       	adc	r31, r31
    4ba2:	ec 53       	subi	r30, 0x3C	; 60
    4ba4:	fa 4f       	sbci	r31, 0xFA	; 250
    4ba6:	80 81       	ld	r24, Z
    4ba8:	91 81       	ldd	r25, Z+1	; 0x01
    4baa:	84 17       	cp	r24, r20
    4bac:	95 07       	cpc	r25, r21
    4bae:	29 f4       	brne	.+10     	; 0x4bba <uip_unlisten+0x2e>
    4bb0:	20 93 cb 03 	sts	0x03CB, r18
      uip_listenports[c] = 0;
    4bb4:	11 82       	std	Z+1, r1	; 0x01
    4bb6:	10 82       	st	Z, r1
    4bb8:	08 95       	ret
      return;
    4bba:	23 2f       	mov	r18, r19
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    4bbc:	22 30       	cpi	r18, 0x02	; 2
    4bbe:	58 f3       	brcs	.-42     	; 0x4b96 <uip_unlisten+0xa>
    4bc0:	20 93 cb 03 	sts	0x03CB, r18
    4bc4:	08 95       	ret

00004bc6 <uip_listen>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
    4bc6:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    4bc8:	10 92 cb 03 	sts	0x03CB, r1
    4bcc:	20 e0       	ldi	r18, 0x00	; 0
    4bce:	12 c0       	rjmp	.+36     	; 0x4bf4 <uip_listen+0x2e>
    if(uip_listenports[c] == 0) {
    4bd0:	e2 2f       	mov	r30, r18
    4bd2:	f0 e0       	ldi	r31, 0x00	; 0
    4bd4:	32 2f       	mov	r19, r18
    4bd6:	3f 5f       	subi	r19, 0xFF	; 255
    4bd8:	ee 0f       	add	r30, r30
    4bda:	ff 1f       	adc	r31, r31
    4bdc:	ec 53       	subi	r30, 0x3C	; 60
    4bde:	fa 4f       	sbci	r31, 0xFA	; 250
    4be0:	80 81       	ld	r24, Z
    4be2:	91 81       	ldd	r25, Z+1	; 0x01
    4be4:	89 2b       	or	r24, r25
    4be6:	29 f4       	brne	.+10     	; 0x4bf2 <uip_listen+0x2c>
    4be8:	20 93 cb 03 	sts	0x03CB, r18
      uip_listenports[c] = port;
    4bec:	51 83       	std	Z+1, r21	; 0x01
    4bee:	40 83       	st	Z, r20
    4bf0:	08 95       	ret
      return;
    4bf2:	23 2f       	mov	r18, r19
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    4bf4:	22 30       	cpi	r18, 0x02	; 2
    4bf6:	60 f3       	brcs	.-40     	; 0x4bd0 <uip_listen+0xa>
    4bf8:	20 93 cb 03 	sts	0x03CB, r18
    4bfc:	08 95       	ret

00004bfe <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    4bfe:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    4c00:	80 91 68 04 	lds	r24, 0x0468
    4c04:	90 91 69 04 	lds	r25, 0x0469
    4c08:	08 96       	adiw	r24, 0x08	; 8
    4c0a:	0e 94 2c 24 	call	0x4858	; 0x4858 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    4c0e:	e0 91 68 04 	lds	r30, 0x0468
    4c12:	f0 91 69 04 	lds	r31, 0x0469
    4c16:	80 91 61 04 	lds	r24, 0x0461
    4c1a:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    4c1c:	80 91 62 04 	lds	r24, 0x0462
    4c20:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    4c22:	80 91 63 04 	lds	r24, 0x0463
    4c26:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    4c28:	80 91 64 04 	lds	r24, 0x0464
    4c2c:	83 87       	std	Z+11, r24	; 0x0b
}
    4c2e:	08 95       	ret

00004c30 <htons>:
  return;
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
    4c30:	28 2f       	mov	r18, r24
  return HTONS(val);
}
    4c32:	89 2f       	mov	r24, r25
    4c34:	92 2f       	mov	r25, r18
    4c36:	08 95       	ret

00004c38 <uip_send>:
}

/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    4c38:	16 16       	cp	r1, r22
    4c3a:	17 06       	cpc	r1, r23
    4c3c:	84 f4       	brge	.+32     	; 0x4c5e <uip_send+0x26>
  if(len > 0) {
    uip_slen = len;
    4c3e:	60 93 de 0b 	sts	0x0BDE, r22
    4c42:	70 93 df 0b 	sts	0x0BDF, r23
    if(data != uip_sappdata) {
    4c46:	20 91 5f 04 	lds	r18, 0x045F
    4c4a:	30 91 60 04 	lds	r19, 0x0460
    4c4e:	82 17       	cp	r24, r18
    4c50:	93 07       	cpc	r25, r19
    4c52:	29 f0       	breq	.+10     	; 0x4c5e <uip_send+0x26>
      memcpy(uip_sappdata, (data), uip_slen);
    4c54:	ab 01       	movw	r20, r22
    4c56:	bc 01       	movw	r22, r24
    4c58:	c9 01       	movw	r24, r18
    4c5a:	0e 94 9c 32 	call	0x6538	; 0x6538 <memcpy>
    4c5e:	08 95       	ret

00004c60 <uip_send_P>:
  return HTONS(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send_P(const void *data, int len)
{
    4c60:	16 16       	cp	r1, r22
    4c62:	17 06       	cpc	r1, r23
    4c64:	64 f4       	brge	.+24     	; 0x4c7e <uip_send_P+0x1e>
  if(len > 0) {
    uip_slen = len;
    4c66:	60 93 de 0b 	sts	0x0BDE, r22
    4c6a:	70 93 df 0b 	sts	0x0BDF, r23
    //if(data != uip_sappdata) {
      memcpy_P(uip_sappdata, (data), uip_slen);
    4c6e:	ab 01       	movw	r20, r22
    4c70:	bc 01       	movw	r22, r24
    4c72:	80 91 5f 04 	lds	r24, 0x045F
    4c76:	90 91 60 04 	lds	r25, 0x0460
    4c7a:	0e 94 52 32 	call	0x64a4	; 0x64a4 <memcpy_P>
    4c7e:	08 95       	ret

00004c80 <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    4c80:	0f 93       	push	r16
    4c82:	1f 93       	push	r17
    4c84:	cf 93       	push	r28
    4c86:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    4c88:	c0 91 68 04 	lds	r28, 0x0468
    4c8c:	d0 91 69 04 	lds	r29, 0x0469
  if(flag == UIP_UDP_SEND_CONN) {
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    4c90:	26 e3       	ldi	r18, 0x36	; 54
    4c92:	36 e0       	ldi	r19, 0x06	; 6
    4c94:	30 93 67 04 	sts	0x0467, r19
    4c98:	20 93 66 04 	sts	0x0466, r18
    4c9c:	30 93 60 04 	sts	0x0460, r19
    4ca0:	20 93 5f 04 	sts	0x045F, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    4ca4:	83 30       	cpi	r24, 0x03	; 3
    4ca6:	59 f4       	brne	.+22     	; 0x4cbe <uip_process+0x3e>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    4ca8:	89 8d       	ldd	r24, Y+25	; 0x19
    4caa:	8f 70       	andi	r24, 0x0F	; 15
    4cac:	83 30       	cpi	r24, 0x03	; 3
    4cae:	09 f0       	breq	.+2      	; 0x4cb2 <uip_process+0x32>
    4cb0:	fd c6       	rjmp	.+3578   	; 0x5aac <uip_process+0xe2c>
    4cb2:	88 89       	ldd	r24, Y+16	; 0x10
    4cb4:	99 89       	ldd	r25, Y+17	; 0x11
    4cb6:	89 2b       	or	r24, r25
    4cb8:	09 f0       	breq	.+2      	; 0x4cbc <uip_process+0x3c>
    4cba:	f8 c6       	rjmp	.+3568   	; 0x5aac <uip_process+0xe2c>
    4cbc:	92 c0       	rjmp	.+292    	; 0x4de2 <uip_process+0x162>
	goto appsend;
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
    4cbe:	82 30       	cpi	r24, 0x02	; 2
    4cc0:	09 f0       	breq	.+2      	; 0x4cc4 <uip_process+0x44>
    4cc2:	93 c0       	rjmp	.+294    	; 0x4dea <uip_process+0x16a>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    4cc4:	80 91 c8 03 	lds	r24, 0x03C8
    4cc8:	8f 5f       	subi	r24, 0xFF	; 255
    4cca:	80 93 c8 03 	sts	0x03C8, r24
    4cce:	88 23       	and	r24, r24
    4cd0:	99 f4       	brne	.+38     	; 0x4cf8 <uip_process+0x78>
      if(++iss[2] == 0) {
    4cd2:	80 91 c7 03 	lds	r24, 0x03C7
    4cd6:	8f 5f       	subi	r24, 0xFF	; 255
    4cd8:	80 93 c7 03 	sts	0x03C7, r24
    4cdc:	88 23       	and	r24, r24
    4cde:	61 f4       	brne	.+24     	; 0x4cf8 <uip_process+0x78>
	if(++iss[1] == 0) {
    4ce0:	80 91 c6 03 	lds	r24, 0x03C6
    4ce4:	8f 5f       	subi	r24, 0xFF	; 255
    4ce6:	80 93 c6 03 	sts	0x03C6, r24
    4cea:	88 23       	and	r24, r24
    4cec:	29 f4       	brne	.+10     	; 0x4cf8 <uip_process+0x78>
	  ++iss[0];
    4cee:	80 91 c5 03 	lds	r24, 0x03C5
    4cf2:	8f 5f       	subi	r24, 0xFF	; 255
    4cf4:	80 93 c5 03 	sts	0x03C5, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    4cf8:	10 92 5e 04 	sts	0x045E, r1
    4cfc:	10 92 5d 04 	sts	0x045D, r1
    uip_slen = 0;
    4d00:	10 92 df 0b 	sts	0x0BDF, r1
    4d04:	10 92 de 0b 	sts	0x0BDE, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    4d08:	29 8d       	ldd	r18, Y+25	; 0x19
    4d0a:	27 30       	cpi	r18, 0x07	; 7
    4d0c:	11 f0       	breq	.+4      	; 0x4d12 <uip_process+0x92>
    4d0e:	25 30       	cpi	r18, 0x05	; 5
    4d10:	41 f4       	brne	.+16     	; 0x4d22 <uip_process+0xa2>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    4d12:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4d14:	8f 5f       	subi	r24, 0xFF	; 255
    4d16:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    4d18:	88 37       	cpi	r24, 0x78	; 120
    4d1a:	09 f0       	breq	.+2      	; 0x4d1e <uip_process+0x9e>
    4d1c:	c7 c6       	rjmp	.+3470   	; 0x5aac <uip_process+0xe2c>
	uip_connr->tcpstateflags = UIP_CLOSED;
    4d1e:	19 8e       	std	Y+25, r1	; 0x19
    4d20:	c5 c6       	rjmp	.+3466   	; 0x5aac <uip_process+0xe2c>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    4d22:	22 23       	and	r18, r18
    4d24:	09 f4       	brne	.+2      	; 0x4d28 <uip_process+0xa8>
    4d26:	c2 c6       	rjmp	.+3460   	; 0x5aac <uip_process+0xe2c>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    4d28:	88 89       	ldd	r24, Y+16	; 0x10
    4d2a:	99 89       	ldd	r25, Y+17	; 0x11
    4d2c:	89 2b       	or	r24, r25
    4d2e:	09 f4       	brne	.+2      	; 0x4d32 <uip_process+0xb2>
    4d30:	54 c0       	rjmp	.+168    	; 0x4dda <uip_process+0x15a>
	if(uip_connr->timer-- == 0) {
    4d32:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4d34:	81 50       	subi	r24, 0x01	; 1
    4d36:	8a 8f       	std	Y+26, r24	; 0x1a
    4d38:	8f 5f       	subi	r24, 0xFF	; 255
    4d3a:	09 f0       	breq	.+2      	; 0x4d3e <uip_process+0xbe>
    4d3c:	b7 c6       	rjmp	.+3438   	; 0x5aac <uip_process+0xe2c>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    4d3e:	3b 8d       	ldd	r19, Y+27	; 0x1b
    4d40:	38 30       	cpi	r19, 0x08	; 8
    4d42:	29 f0       	breq	.+10     	; 0x4d4e <uip_process+0xce>
    4d44:	21 50       	subi	r18, 0x01	; 1
    4d46:	22 30       	cpi	r18, 0x02	; 2
    4d48:	48 f4       	brcc	.+18     	; 0x4d5c <uip_process+0xdc>
    4d4a:	35 30       	cpi	r19, 0x05	; 5
    4d4c:	39 f4       	brne	.+14     	; 0x4d5c <uip_process+0xdc>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    4d4e:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    4d50:	80 e8       	ldi	r24, 0x80	; 128
    4d52:	80 93 65 04 	sts	0x0465, r24
	    UIP_APPCALL();
    4d56:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>
    4d5a:	4c c5       	rjmp	.+2712   	; 0x57f4 <uip_process+0xb74>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    4d5c:	35 30       	cpi	r19, 0x05	; 5
    4d5e:	10 f0       	brcs	.+4      	; 0x4d64 <uip_process+0xe4>
    4d60:	80 e3       	ldi	r24, 0x30	; 48
    4d62:	07 c0       	rjmp	.+14     	; 0x4d72 <uip_process+0xf2>
    4d64:	83 e0       	ldi	r24, 0x03	; 3
    4d66:	90 e0       	ldi	r25, 0x00	; 0
    4d68:	02 c0       	rjmp	.+4      	; 0x4d6e <uip_process+0xee>
    4d6a:	88 0f       	add	r24, r24
    4d6c:	99 1f       	adc	r25, r25
    4d6e:	3a 95       	dec	r19
    4d70:	e2 f7       	brpl	.-8      	; 0x4d6a <uip_process+0xea>
    4d72:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    4d74:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4d76:	8f 5f       	subi	r24, 0xFF	; 255
    4d78:	8b 8f       	std	Y+27, r24	; 0x1b
	     depending on which state we are in. In ESTABLISHED, we
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
    4d7a:	80 91 f2 05 	lds	r24, 0x05F2
    4d7e:	90 91 f3 05 	lds	r25, 0x05F3
    4d82:	01 96       	adiw	r24, 0x01	; 1
    4d84:	90 93 f3 05 	sts	0x05F3, r25
    4d88:	80 93 f2 05 	sts	0x05F2, r24
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    4d8c:	89 8d       	ldd	r24, Y+25	; 0x19
    4d8e:	90 e0       	ldi	r25, 0x00	; 0
    4d90:	8f 70       	andi	r24, 0x0F	; 15
    4d92:	90 70       	andi	r25, 0x00	; 0
    4d94:	83 30       	cpi	r24, 0x03	; 3
    4d96:	91 05       	cpc	r25, r1
    4d98:	d1 f0       	breq	.+52     	; 0x4dce <uip_process+0x14e>
    4d9a:	84 30       	cpi	r24, 0x04	; 4
    4d9c:	91 05       	cpc	r25, r1
    4d9e:	44 f4       	brge	.+16     	; 0x4db0 <uip_process+0x130>
    4da0:	81 30       	cpi	r24, 0x01	; 1
    4da2:	91 05       	cpc	r25, r1
    4da4:	09 f4       	brne	.+2      	; 0x4da8 <uip_process+0x128>
    4da6:	08 c3       	rjmp	.+1552   	; 0x53b8 <uip_process+0x738>
    4da8:	02 97       	sbiw	r24, 0x02	; 2
    4daa:	09 f0       	breq	.+2      	; 0x4dae <uip_process+0x12e>
    4dac:	7f c6       	rjmp	.+3326   	; 0x5aac <uip_process+0xe2c>
    4dae:	0c c0       	rjmp	.+24     	; 0x4dc8 <uip_process+0x148>
    4db0:	86 30       	cpi	r24, 0x06	; 6
    4db2:	91 05       	cpc	r25, r1
    4db4:	09 f4       	brne	.+2      	; 0x4db8 <uip_process+0x138>
    4db6:	b1 c4       	rjmp	.+2402   	; 0x571a <uip_process+0xa9a>
    4db8:	88 30       	cpi	r24, 0x08	; 8
    4dba:	91 05       	cpc	r25, r1
    4dbc:	09 f4       	brne	.+2      	; 0x4dc0 <uip_process+0x140>
    4dbe:	ad c4       	rjmp	.+2394   	; 0x571a <uip_process+0xa9a>
    4dc0:	04 97       	sbiw	r24, 0x04	; 4
    4dc2:	09 f0       	breq	.+2      	; 0x4dc6 <uip_process+0x146>
    4dc4:	73 c6       	rjmp	.+3302   	; 0x5aac <uip_process+0xe2c>
    4dc6:	a9 c4       	rjmp	.+2386   	; 0x571a <uip_process+0xa9a>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    4dc8:	10 92 2f 06 	sts	0x062F, r1
    4dcc:	f8 c2       	rjmp	.+1520   	; 0x53be <uip_process+0x73e>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    4dce:	84 e0       	ldi	r24, 0x04	; 4
    4dd0:	80 93 65 04 	sts	0x0465, r24
	    UIP_APPCALL();
    4dd4:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>
    4dd8:	42 c5       	rjmp	.+2692   	; 0x585e <uip_process+0xbde>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    4dda:	2f 70       	andi	r18, 0x0F	; 15
    4ddc:	23 30       	cpi	r18, 0x03	; 3
    4dde:	09 f0       	breq	.+2      	; 0x4de2 <uip_process+0x162>
    4de0:	65 c6       	rjmp	.+3274   	; 0x5aac <uip_process+0xe2c>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
    4de2:	88 e0       	ldi	r24, 0x08	; 8
    4de4:	80 93 65 04 	sts	0x0465, r24
    4de8:	f9 c4       	rjmp	.+2546   	; 0x57dc <uip_process+0xb5c>
    }
  }
#endif

  /* This is where the input processing starts. */
  UIP_STAT(++uip_stat.ip.recv);
    4dea:	80 91 ce 05 	lds	r24, 0x05CE
    4dee:	90 91 cf 05 	lds	r25, 0x05CF
    4df2:	01 96       	adiw	r24, 0x01	; 1
    4df4:	90 93 cf 05 	sts	0x05CF, r25
    4df8:	80 93 ce 05 	sts	0x05CE, r24
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    4dfc:	89 01       	movw	r16, r18
    4dfe:	08 52       	subi	r16, 0x28	; 40
    4e00:	10 40       	sbci	r17, 0x00	; 0
    4e02:	80 91 0e 06 	lds	r24, 0x060E
    4e06:	85 34       	cpi	r24, 0x45	; 69
    4e08:	a9 f0       	breq	.+42     	; 0x4e34 <uip_process+0x1b4>
    UIP_STAT(++uip_stat.ip.drop);
    4e0a:	80 91 cc 05 	lds	r24, 0x05CC
    4e0e:	90 91 cd 05 	lds	r25, 0x05CD
    4e12:	01 96       	adiw	r24, 0x01	; 1
    4e14:	90 93 cd 05 	sts	0x05CD, r25
    4e18:	80 93 cc 05 	sts	0x05CC, r24
    UIP_STAT(++uip_stat.ip.vhlerr);
    4e1c:	80 91 d2 05 	lds	r24, 0x05D2
    4e20:	90 91 d3 05 	lds	r25, 0x05D3
    4e24:	01 96       	adiw	r24, 0x01	; 1
    4e26:	90 93 d3 05 	sts	0x05D3, r25
    4e2a:	80 93 d2 05 	sts	0x05D2, r24
    UIP_LOG("ip: invalid version or header length.");
    4e2e:	80 e9       	ldi	r24, 0x90	; 144
    4e30:	92 e0       	ldi	r25, 0x02	; 2
    4e32:	1d c0       	rjmp	.+58     	; 0x4e6e <uip_process+0x1ee>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    4e34:	90 91 10 06 	lds	r25, 0x0610
    4e38:	80 e0       	ldi	r24, 0x00	; 0
    4e3a:	20 91 11 06 	lds	r18, 0x0611
    4e3e:	ac 01       	movw	r20, r24
    4e40:	42 0f       	add	r20, r18
    4e42:	51 1d       	adc	r21, r1
    4e44:	80 91 5d 04 	lds	r24, 0x045D
    4e48:	90 91 5e 04 	lds	r25, 0x045E
    4e4c:	84 17       	cp	r24, r20
    4e4e:	95 07       	cpc	r25, r21
    4e50:	60 f0       	brcs	.+24     	; 0x4e6a <uip_process+0x1ea>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    4e52:	50 93 5e 04 	sts	0x045E, r21
    4e56:	40 93 5d 04 	sts	0x045D, r20
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    4e5a:	80 91 14 06 	lds	r24, 0x0614
    4e5e:	90 e0       	ldi	r25, 0x00	; 0
    4e60:	8f 73       	andi	r24, 0x3F	; 63
    4e62:	90 70       	andi	r25, 0x00	; 0
    4e64:	89 2b       	or	r24, r25
    4e66:	31 f0       	breq	.+12     	; 0x4e74 <uip_process+0x1f4>
    4e68:	09 c0       	rjmp	.+18     	; 0x4e7c <uip_process+0x1fc>
		      contains the length of the entire packet. But
		      for IPv6 we need to add the size of the IPv6
		      header (40 bytes). */
#endif /* UIP_CONF_IPV6 */
  } else {
    UIP_LOG("ip: packet shorter than reported in IP header.");
    4e6a:	86 eb       	ldi	r24, 0xB6	; 182
    4e6c:	92 e0       	ldi	r25, 0x02	; 2
    4e6e:	0e 94 c7 10 	call	0x218e	; 0x218e <uip_log>
    4e72:	1c c6       	rjmp	.+3128   	; 0x5aac <uip_process+0xe2c>
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    4e74:	80 91 15 06 	lds	r24, 0x0615
    4e78:	88 23       	and	r24, r24
    4e7a:	a9 f0       	breq	.+42     	; 0x4ea6 <uip_process+0x226>
    uip_len = uip_reass();
    if(uip_len == 0) {
      goto drop;
    }
#else /* UIP_REASSEMBLY */
    UIP_STAT(++uip_stat.ip.drop);
    4e7c:	80 91 cc 05 	lds	r24, 0x05CC
    4e80:	90 91 cd 05 	lds	r25, 0x05CD
    4e84:	01 96       	adiw	r24, 0x01	; 1
    4e86:	90 93 cd 05 	sts	0x05CD, r25
    4e8a:	80 93 cc 05 	sts	0x05CC, r24
    UIP_STAT(++uip_stat.ip.fragerr);
    4e8e:	80 91 d8 05 	lds	r24, 0x05D8
    4e92:	90 91 d9 05 	lds	r25, 0x05D9
    4e96:	01 96       	adiw	r24, 0x01	; 1
    4e98:	90 93 d9 05 	sts	0x05D9, r25
    4e9c:	80 93 d8 05 	sts	0x05D8, r24
    UIP_LOG("ip: fragment dropped.");
    4ea0:	85 ee       	ldi	r24, 0xE5	; 229
    4ea2:	92 e0       	ldi	r25, 0x02	; 2
    4ea4:	e4 cf       	rjmp	.-56     	; 0x4e6e <uip_process+0x1ee>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
    4ea6:	20 91 fc 05 	lds	r18, 0x05FC
    4eaa:	30 91 fd 05 	lds	r19, 0x05FD
    4eae:	21 15       	cp	r18, r1
    4eb0:	31 05       	cpc	r19, r1
    4eb2:	31 f4       	brne	.+12     	; 0x4ec0 <uip_process+0x240>
    4eb4:	80 91 fe 05 	lds	r24, 0x05FE
    4eb8:	90 91 ff 05 	lds	r25, 0x05FF
    4ebc:	89 2b       	or	r24, r25
    4ebe:	e1 f0       	breq	.+56     	; 0x4ef8 <uip_process+0x278>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
    4ec0:	80 91 1e 06 	lds	r24, 0x061E
    4ec4:	90 91 1f 06 	lds	r25, 0x061F
    4ec8:	82 17       	cp	r24, r18
    4eca:	93 07       	cpc	r25, r19
    4ecc:	59 f4       	brne	.+22     	; 0x4ee4 <uip_process+0x264>
    4ece:	20 91 20 06 	lds	r18, 0x0620
    4ed2:	30 91 21 06 	lds	r19, 0x0621
    4ed6:	80 91 fe 05 	lds	r24, 0x05FE
    4eda:	90 91 ff 05 	lds	r25, 0x05FF
    4ede:	28 17       	cp	r18, r24
    4ee0:	39 07       	cpc	r19, r25
    4ee2:	51 f0       	breq	.+20     	; 0x4ef8 <uip_process+0x278>
      UIP_STAT(++uip_stat.ip.drop);
    4ee4:	80 91 cc 05 	lds	r24, 0x05CC
    4ee8:	90 91 cd 05 	lds	r25, 0x05CD
    4eec:	01 96       	adiw	r24, 0x01	; 1
    4eee:	90 93 cd 05 	sts	0x05CD, r25
    4ef2:	80 93 cc 05 	sts	0x05CC, r24
    4ef6:	da c5       	rjmp	.+2996   	; 0x5aac <uip_process+0xe2c>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    4ef8:	0e 94 8c 24 	call	0x4918	; 0x4918 <uip_ipchksum>
    4efc:	8f 5f       	subi	r24, 0xFF	; 255
    4efe:	9f 4f       	sbci	r25, 0xFF	; 255
    4f00:	a9 f0       	breq	.+42     	; 0x4f2c <uip_process+0x2ac>
				    checksum. */
    UIP_STAT(++uip_stat.ip.drop);
    4f02:	80 91 cc 05 	lds	r24, 0x05CC
    4f06:	90 91 cd 05 	lds	r25, 0x05CD
    4f0a:	01 96       	adiw	r24, 0x01	; 1
    4f0c:	90 93 cd 05 	sts	0x05CD, r25
    4f10:	80 93 cc 05 	sts	0x05CC, r24
    UIP_STAT(++uip_stat.ip.chkerr);
    4f14:	80 91 da 05 	lds	r24, 0x05DA
    4f18:	90 91 db 05 	lds	r25, 0x05DB
    4f1c:	01 96       	adiw	r24, 0x01	; 1
    4f1e:	90 93 db 05 	sts	0x05DB, r25
    4f22:	80 93 da 05 	sts	0x05DA, r24
    UIP_LOG("ip: bad checksum.");
    4f26:	8b ef       	ldi	r24, 0xFB	; 251
    4f28:	92 e0       	ldi	r25, 0x02	; 2
    4f2a:	a1 cf       	rjmp	.-190    	; 0x4e6e <uip_process+0x1ee>
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    4f2c:	80 91 17 06 	lds	r24, 0x0617
    4f30:	86 30       	cpi	r24, 0x06	; 6
    4f32:	09 f4       	brne	.+2      	; 0x4f36 <uip_process+0x2b6>
    4f34:	74 c0       	rjmp	.+232    	; 0x501e <uip_process+0x39e>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    4f36:	81 30       	cpi	r24, 0x01	; 1
    4f38:	a9 f0       	breq	.+42     	; 0x4f64 <uip_process+0x2e4>
					here. */
    UIP_STAT(++uip_stat.ip.drop);
    4f3a:	80 91 cc 05 	lds	r24, 0x05CC
    4f3e:	90 91 cd 05 	lds	r25, 0x05CD
    4f42:	01 96       	adiw	r24, 0x01	; 1
    4f44:	90 93 cd 05 	sts	0x05CD, r25
    4f48:	80 93 cc 05 	sts	0x05CC, r24
    UIP_STAT(++uip_stat.ip.protoerr);
    4f4c:	80 91 dc 05 	lds	r24, 0x05DC
    4f50:	90 91 dd 05 	lds	r25, 0x05DD
    4f54:	01 96       	adiw	r24, 0x01	; 1
    4f56:	90 93 dd 05 	sts	0x05DD, r25
    4f5a:	80 93 dc 05 	sts	0x05DC, r24
    UIP_LOG("ip: neither tcp nor icmp.");
    4f5e:	8d e0       	ldi	r24, 0x0D	; 13
    4f60:	93 e0       	ldi	r25, 0x03	; 3
    4f62:	85 cf       	rjmp	.-246    	; 0x4e6e <uip_process+0x1ee>
  }

#if UIP_PINGADDRCONF
 icmp_input:
#endif /* UIP_PINGADDRCONF */
  UIP_STAT(++uip_stat.icmp.recv);
    4f64:	80 91 e0 05 	lds	r24, 0x05E0
    4f68:	90 91 e1 05 	lds	r25, 0x05E1
    4f6c:	01 96       	adiw	r24, 0x01	; 1
    4f6e:	90 93 e1 05 	sts	0x05E1, r25
    4f72:	80 93 e0 05 	sts	0x05E0, r24

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    4f76:	80 91 22 06 	lds	r24, 0x0622
    4f7a:	88 30       	cpi	r24, 0x08	; 8
    4f7c:	a9 f0       	breq	.+42     	; 0x4fa8 <uip_process+0x328>
    UIP_STAT(++uip_stat.icmp.drop);
    4f7e:	80 91 de 05 	lds	r24, 0x05DE
    4f82:	90 91 df 05 	lds	r25, 0x05DF
    4f86:	01 96       	adiw	r24, 0x01	; 1
    4f88:	90 93 df 05 	sts	0x05DF, r25
    4f8c:	80 93 de 05 	sts	0x05DE, r24
    UIP_STAT(++uip_stat.icmp.typeerr);
    4f90:	80 91 e4 05 	lds	r24, 0x05E4
    4f94:	90 91 e5 05 	lds	r25, 0x05E5
    4f98:	01 96       	adiw	r24, 0x01	; 1
    4f9a:	90 93 e5 05 	sts	0x05E5, r25
    4f9e:	80 93 e4 05 	sts	0x05E4, r24
    UIP_LOG("icmp: not icmp echo.");
    4fa2:	87 e2       	ldi	r24, 0x27	; 39
    4fa4:	93 e0       	ldi	r25, 0x03	; 3
    4fa6:	63 cf       	rjmp	.-314    	; 0x4e6e <uip_process+0x1ee>
    uip_hostaddr[0] = BUF->destipaddr[0];
    uip_hostaddr[1] = BUF->destipaddr[1];
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    4fa8:	10 92 22 06 	sts	0x0622, r1

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    4fac:	80 91 24 06 	lds	r24, 0x0624
    4fb0:	90 91 25 06 	lds	r25, 0x0625
    4fb4:	ef ef       	ldi	r30, 0xFF	; 255
    4fb6:	87 3f       	cpi	r24, 0xF7	; 247
    4fb8:	9e 07       	cpc	r25, r30
    4fba:	10 f0       	brcs	.+4      	; 0x4fc0 <uip_process+0x340>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    4fbc:	09 96       	adiw	r24, 0x09	; 9
    4fbe:	01 c0       	rjmp	.+2      	; 0x4fc2 <uip_process+0x342>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    4fc0:	08 96       	adiw	r24, 0x08	; 8
    4fc2:	90 93 25 06 	sts	0x0625, r25
    4fc6:	80 93 24 06 	sts	0x0624, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    4fca:	80 91 1a 06 	lds	r24, 0x061A
    4fce:	90 91 1b 06 	lds	r25, 0x061B
    4fd2:	90 93 1f 06 	sts	0x061F, r25
    4fd6:	80 93 1e 06 	sts	0x061E, r24
    4fda:	80 91 1c 06 	lds	r24, 0x061C
    4fde:	90 91 1d 06 	lds	r25, 0x061D
    4fe2:	90 93 21 06 	sts	0x0621, r25
    4fe6:	80 93 20 06 	sts	0x0620, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    4fea:	80 91 fc 05 	lds	r24, 0x05FC
    4fee:	90 91 fd 05 	lds	r25, 0x05FD
    4ff2:	90 93 1b 06 	sts	0x061B, r25
    4ff6:	80 93 1a 06 	sts	0x061A, r24
    4ffa:	80 91 fe 05 	lds	r24, 0x05FE
    4ffe:	90 91 ff 05 	lds	r25, 0x05FF
    5002:	90 93 1d 06 	sts	0x061D, r25
    5006:	80 93 1c 06 	sts	0x061C, r24

  UIP_STAT(++uip_stat.icmp.sent);
    500a:	80 91 e2 05 	lds	r24, 0x05E2
    500e:	90 91 e3 05 	lds	r25, 0x05E3
    5012:	01 96       	adiw	r24, 0x01	; 1
    5014:	90 93 e3 05 	sts	0x05E3, r25
    5018:	80 93 e2 05 	sts	0x05E2, r24
    501c:	3d c5       	rjmp	.+2682   	; 0x5a98 <uip_process+0xe18>
  goto ip_send_nolen;
#endif /* UIP_UDP */
  
  /* TCP input processing. */
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);
    501e:	80 91 e8 05 	lds	r24, 0x05E8
    5022:	90 91 e9 05 	lds	r25, 0x05E9
    5026:	01 96       	adiw	r24, 0x01	; 1
    5028:	90 93 e9 05 	sts	0x05E9, r25
    502c:	80 93 e8 05 	sts	0x05E8, r24

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    5030:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <uip_tcpchksum>
    5034:	8f 5f       	subi	r24, 0xFF	; 255
    5036:	9f 4f       	sbci	r25, 0xFF	; 255
    5038:	a9 f0       	breq	.+42     	; 0x5064 <uip_process+0x3e4>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    503a:	80 91 e6 05 	lds	r24, 0x05E6
    503e:	90 91 e7 05 	lds	r25, 0x05E7
    5042:	01 96       	adiw	r24, 0x01	; 1
    5044:	90 93 e7 05 	sts	0x05E7, r25
    5048:	80 93 e6 05 	sts	0x05E6, r24
    UIP_STAT(++uip_stat.tcp.chkerr);
    504c:	80 91 ec 05 	lds	r24, 0x05EC
    5050:	90 91 ed 05 	lds	r25, 0x05ED
    5054:	01 96       	adiw	r24, 0x01	; 1
    5056:	90 93 ed 05 	sts	0x05ED, r25
    505a:	80 93 ec 05 	sts	0x05EC, r24
    UIP_LOG("tcp: bad checksum.");
    505e:	8c e3       	ldi	r24, 0x3C	; 60
    5060:	93 e0       	ldi	r25, 0x03	; 3
    5062:	05 cf       	rjmp	.-502    	; 0x4e6e <uip_process+0x1ee>
    goto drop;
    5064:	ca e6       	ldi	r28, 0x6A	; 106
    5066:	d4 e0       	ldi	r29, 0x04	; 4
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    5068:	89 8d       	ldd	r24, Y+25	; 0x19
    506a:	88 23       	and	r24, r24
    506c:	29 f1       	breq	.+74     	; 0x50b8 <uip_process+0x438>
    506e:	20 91 24 06 	lds	r18, 0x0624
    5072:	30 91 25 06 	lds	r19, 0x0625
    5076:	8c 81       	ldd	r24, Y+4	; 0x04
    5078:	9d 81       	ldd	r25, Y+5	; 0x05
    507a:	28 17       	cp	r18, r24
    507c:	39 07       	cpc	r19, r25
    507e:	e1 f4       	brne	.+56     	; 0x50b8 <uip_process+0x438>
    5080:	20 91 22 06 	lds	r18, 0x0622
    5084:	30 91 23 06 	lds	r19, 0x0623
    5088:	8e 81       	ldd	r24, Y+6	; 0x06
    508a:	9f 81       	ldd	r25, Y+7	; 0x07
    508c:	28 17       	cp	r18, r24
    508e:	39 07       	cpc	r19, r25
    5090:	99 f4       	brne	.+38     	; 0x50b8 <uip_process+0x438>
    5092:	20 91 1a 06 	lds	r18, 0x061A
    5096:	30 91 1b 06 	lds	r19, 0x061B
    509a:	88 81       	ld	r24, Y
    509c:	99 81       	ldd	r25, Y+1	; 0x01
    509e:	28 17       	cp	r18, r24
    50a0:	39 07       	cpc	r19, r25
    50a2:	51 f4       	brne	.+20     	; 0x50b8 <uip_process+0x438>
    50a4:	20 91 1c 06 	lds	r18, 0x061C
    50a8:	30 91 1d 06 	lds	r19, 0x061D
    50ac:	8a 81       	ldd	r24, Y+2	; 0x02
    50ae:	9b 81       	ldd	r25, Y+3	; 0x03
    50b0:	28 17       	cp	r18, r24
    50b2:	39 07       	cpc	r19, r25
    50b4:	09 f4       	brne	.+2      	; 0x50b8 <uip_process+0x438>
    50b6:	9c c1       	rjmp	.+824    	; 0x53f0 <uip_process+0x770>
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    50b8:	c3 55       	subi	r28, 0x53	; 83
    50ba:	df 4f       	sbci	r29, 0xFF	; 255
  }
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    50bc:	25 e0       	ldi	r18, 0x05	; 5
    50be:	c7 31       	cpi	r28, 0x17	; 23
    50c0:	d2 07       	cpc	r29, r18
    50c2:	91 f2       	breq	.-92     	; 0x5068 <uip_process+0x3e8>
    50c4:	88 f2       	brcs	.-94     	; 0x5068 <uip_process+0x3e8>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    50c6:	80 91 2f 06 	lds	r24, 0x062F
    50ca:	8f 73       	andi	r24, 0x3F	; 63
    50cc:	82 30       	cpi	r24, 0x02	; 2
    50ce:	59 f5       	brne	.+86     	; 0x5126 <uip_process+0x4a6>
    goto reset;
  }
  
  tmp16 = BUF->destport;
    50d0:	80 91 24 06 	lds	r24, 0x0624
    50d4:	90 91 25 06 	lds	r25, 0x0625
    50d8:	90 93 ce 03 	sts	0x03CE, r25
    50dc:	80 93 cd 03 	sts	0x03CD, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    50e0:	10 92 cb 03 	sts	0x03CB, r1
    50e4:	13 c0       	rjmp	.+38     	; 0x510c <uip_process+0x48c>
    if(tmp16 == uip_listenports[c])
    50e6:	e4 2f       	mov	r30, r20
    50e8:	f0 e0       	ldi	r31, 0x00	; 0
    50ea:	ee 0f       	add	r30, r30
    50ec:	ff 1f       	adc	r31, r31
    50ee:	ec 53       	subi	r30, 0x3C	; 60
    50f0:	fa 4f       	sbci	r31, 0xFA	; 250
    50f2:	20 91 cd 03 	lds	r18, 0x03CD
    50f6:	30 91 ce 03 	lds	r19, 0x03CE
    50fa:	80 81       	ld	r24, Z
    50fc:	91 81       	ldd	r25, Z+1	; 0x01
    50fe:	28 17       	cp	r18, r24
    5100:	39 07       	cpc	r19, r25
    5102:	09 f4       	brne	.+2      	; 0x5106 <uip_process+0x486>
    5104:	83 c0       	rjmp	.+262    	; 0x520c <uip_process+0x58c>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    5106:	4f 5f       	subi	r20, 0xFF	; 255
    5108:	40 93 cb 03 	sts	0x03CB, r20
    510c:	40 91 cb 03 	lds	r20, 0x03CB
    5110:	42 30       	cpi	r20, 0x02	; 2
    5112:	48 f3       	brcs	.-46     	; 0x50e6 <uip_process+0x466>
    if(tmp16 == uip_listenports[c])
      goto found_listen;
  }
  
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);
    5114:	80 91 f6 05 	lds	r24, 0x05F6
    5118:	90 91 f7 05 	lds	r25, 0x05F7
    511c:	01 96       	adiw	r24, 0x01	; 1
    511e:	90 93 f7 05 	sts	0x05F7, r25
    5122:	80 93 f6 05 	sts	0x05F6, r24
 reset:

  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    5126:	80 91 2f 06 	lds	r24, 0x062F
    512a:	82 fd       	sbrc	r24, 2
    512c:	bf c4       	rjmp	.+2430   	; 0x5aac <uip_process+0xe2c>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
    512e:	80 91 f0 05 	lds	r24, 0x05F0
    5132:	90 91 f1 05 	lds	r25, 0x05F1
    5136:	01 96       	adiw	r24, 0x01	; 1
    5138:	90 93 f1 05 	sts	0x05F1, r25
    513c:	80 93 f0 05 	sts	0x05F0, r24
  
  BUF->flags = TCP_RST | TCP_ACK;
    5140:	84 e1       	ldi	r24, 0x14	; 20
    5142:	f8 01       	movw	r30, r16
    5144:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    5146:	88 e2       	ldi	r24, 0x28	; 40
    5148:	90 e0       	ldi	r25, 0x00	; 0
    514a:	90 93 5e 04 	sts	0x045E, r25
    514e:	80 93 5d 04 	sts	0x045D, r24
  BUF->tcpoffset = 5 << 4;
    5152:	80 e5       	ldi	r24, 0x50	; 80
    5154:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    5156:	90 91 29 06 	lds	r25, 0x0629
  BUF->seqno[3] = BUF->ackno[3];
    515a:	80 91 2d 06 	lds	r24, 0x062D
    515e:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    5160:	30 91 28 06 	lds	r19, 0x0628
  BUF->seqno[2] = BUF->ackno[2];
    5164:	80 91 2c 06 	lds	r24, 0x062C
    5168:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    516a:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    516c:	40 91 27 06 	lds	r20, 0x0627
  BUF->seqno[1] = BUF->ackno[1];
    5170:	80 91 2b 06 	lds	r24, 0x062B
    5174:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    5176:	45 8f       	std	Z+29, r20	; 0x1d
  
  c = BUF->seqno[0];
    5178:	20 91 26 06 	lds	r18, 0x0626
    517c:	20 93 cb 03 	sts	0x03CB, r18
  BUF->seqno[0] = BUF->ackno[0];
    5180:	80 91 2a 06 	lds	r24, 0x062A
    5184:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    5186:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    5188:	9f 5f       	subi	r25, 0xFF	; 255
    518a:	97 8f       	std	Z+31, r25	; 0x1f
    518c:	99 23       	and	r25, r25
    518e:	61 f4       	brne	.+24     	; 0x51a8 <uip_process+0x528>
    if(++BUF->ackno[2] == 0) {
    5190:	83 2f       	mov	r24, r19
    5192:	8f 5f       	subi	r24, 0xFF	; 255
    5194:	86 8f       	std	Z+30, r24	; 0x1e
    5196:	88 23       	and	r24, r24
    5198:	39 f4       	brne	.+14     	; 0x51a8 <uip_process+0x528>
      if(++BUF->ackno[1] == 0) {
    519a:	84 2f       	mov	r24, r20
    519c:	8f 5f       	subi	r24, 0xFF	; 255
    519e:	85 8f       	std	Z+29, r24	; 0x1d
    51a0:	88 23       	and	r24, r24
    51a2:	11 f4       	brne	.+4      	; 0x51a8 <uip_process+0x528>
	++BUF->ackno[0];
    51a4:	2f 5f       	subi	r18, 0xFF	; 255
    51a6:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    51a8:	20 91 22 06 	lds	r18, 0x0622
    51ac:	30 91 23 06 	lds	r19, 0x0623
    51b0:	30 93 ce 03 	sts	0x03CE, r19
    51b4:	20 93 cd 03 	sts	0x03CD, r18
  BUF->srcport = BUF->destport;
    51b8:	80 91 24 06 	lds	r24, 0x0624
    51bc:	90 91 25 06 	lds	r25, 0x0625
    51c0:	f8 01       	movw	r30, r16
    51c2:	95 8b       	std	Z+21, r25	; 0x15
    51c4:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    51c6:	37 8b       	std	Z+23, r19	; 0x17
    51c8:	26 8b       	std	Z+22, r18	; 0x16
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    51ca:	80 91 1a 06 	lds	r24, 0x061A
    51ce:	90 91 1b 06 	lds	r25, 0x061B
    51d2:	90 93 1f 06 	sts	0x061F, r25
    51d6:	80 93 1e 06 	sts	0x061E, r24
    51da:	80 91 1c 06 	lds	r24, 0x061C
    51de:	90 91 1d 06 	lds	r25, 0x061D
    51e2:	90 93 21 06 	sts	0x0621, r25
    51e6:	80 93 20 06 	sts	0x0620, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    51ea:	80 91 fc 05 	lds	r24, 0x05FC
    51ee:	90 91 fd 05 	lds	r25, 0x05FD
    51f2:	90 93 1b 06 	sts	0x061B, r25
    51f6:	80 93 1a 06 	sts	0x061A, r24
    51fa:	80 91 fe 05 	lds	r24, 0x05FE
    51fe:	90 91 ff 05 	lds	r25, 0x05FF
    5202:	90 93 1d 06 	sts	0x061D, r25
    5206:	80 93 1c 06 	sts	0x061C, r24
    520a:	00 c4       	rjmp	.+2048   	; 0x5a0c <uip_process+0xd8c>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    520c:	10 92 cb 03 	sts	0x03CB, r1
    5210:	c0 e0       	ldi	r28, 0x00	; 0
    5212:	d0 e0       	ldi	r29, 0x00	; 0
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    5214:	4d ea       	ldi	r20, 0xAD	; 173
    5216:	50 e0       	ldi	r21, 0x00	; 0
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    5218:	3d ea       	ldi	r19, 0xAD	; 173
    521a:	25 c0       	rjmp	.+74     	; 0x5266 <uip_process+0x5e6>
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    521c:	82 2f       	mov	r24, r18
    521e:	90 e0       	ldi	r25, 0x00	; 0
    5220:	84 9f       	mul	r24, r20
    5222:	f0 01       	movw	r30, r0
    5224:	85 9f       	mul	r24, r21
    5226:	f0 0d       	add	r31, r0
    5228:	94 9f       	mul	r25, r20
    522a:	f0 0d       	add	r31, r0
    522c:	11 24       	eor	r1, r1
    522e:	e6 59       	subi	r30, 0x96	; 150
    5230:	fb 4f       	sbci	r31, 0xFB	; 251
    5232:	81 8d       	ldd	r24, Z+25	; 0x19
    5234:	88 23       	and	r24, r24
    5236:	39 f4       	brne	.+14     	; 0x5246 <uip_process+0x5c6>
      uip_connr = &uip_conns[c];
    5238:	8d ea       	ldi	r24, 0xAD	; 173
    523a:	28 9f       	mul	r18, r24
    523c:	e0 01       	movw	r28, r0
    523e:	11 24       	eor	r1, r1
    5240:	c6 59       	subi	r28, 0x96	; 150
    5242:	db 4f       	sbci	r29, 0xFB	; 251
    5244:	14 c0       	rjmp	.+40     	; 0x526e <uip_process+0x5ee>
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    5246:	87 30       	cpi	r24, 0x07	; 7
    5248:	59 f4       	brne	.+22     	; 0x5260 <uip_process+0x5e0>
      if(uip_connr == 0 ||
    524a:	20 97       	sbiw	r28, 0x00	; 0
    524c:	21 f0       	breq	.+8      	; 0x5256 <uip_process+0x5d6>
    524e:	92 8d       	ldd	r25, Z+26	; 0x1a
    5250:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5252:	89 17       	cp	r24, r25
    5254:	28 f4       	brcc	.+10     	; 0x5260 <uip_process+0x5e0>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    5256:	23 9f       	mul	r18, r19
    5258:	e0 01       	movw	r28, r0
    525a:	11 24       	eor	r1, r1
    525c:	c6 59       	subi	r28, 0x96	; 150
    525e:	db 4f       	sbci	r29, 0xFB	; 251
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    5260:	2f 5f       	subi	r18, 0xFF	; 255
    5262:	20 93 cb 03 	sts	0x03CB, r18
    5266:	20 91 cb 03 	lds	r18, 0x03CB
    526a:	22 30       	cpi	r18, 0x02	; 2
    526c:	b8 f2       	brcs	.-82     	; 0x521c <uip_process+0x59c>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    526e:	20 97       	sbiw	r28, 0x00	; 0
    5270:	61 f4       	brne	.+24     	; 0x528a <uip_process+0x60a>
    /* All connections are used already, we drop packet and hope that
       the remote end will retransmit the packet at a time when we
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    5272:	80 91 f4 05 	lds	r24, 0x05F4
    5276:	90 91 f5 05 	lds	r25, 0x05F5
    527a:	01 96       	adiw	r24, 0x01	; 1
    527c:	90 93 f5 05 	sts	0x05F5, r25
    5280:	80 93 f4 05 	sts	0x05F4, r24
    UIP_LOG("tcp: found no unused connections.");
    5284:	8f e4       	ldi	r24, 0x4F	; 79
    5286:	93 e0       	ldi	r25, 0x03	; 3
    5288:	f2 cd       	rjmp	.-1052   	; 0x4e6e <uip_process+0x1ee>
    goto drop;
  }
  uip_conn = uip_connr;
    528a:	d0 93 69 04 	sts	0x0469, r29
    528e:	c0 93 68 04 	sts	0x0468, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    5292:	83 e0       	ldi	r24, 0x03	; 3
    5294:	8a 8f       	std	Y+26, r24	; 0x1a
    5296:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    5298:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    529a:	84 e0       	ldi	r24, 0x04	; 4
    529c:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    529e:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    52a0:	80 91 24 06 	lds	r24, 0x0624
    52a4:	90 91 25 06 	lds	r25, 0x0625
    52a8:	9d 83       	std	Y+5, r25	; 0x05
    52aa:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    52ac:	80 91 22 06 	lds	r24, 0x0622
    52b0:	90 91 23 06 	lds	r25, 0x0623
    52b4:	9f 83       	std	Y+7, r25	; 0x07
    52b6:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
    52b8:	80 91 1a 06 	lds	r24, 0x061A
    52bc:	90 91 1b 06 	lds	r25, 0x061B
    52c0:	99 83       	std	Y+1, r25	; 0x01
    52c2:	88 83       	st	Y, r24
    52c4:	80 91 1c 06 	lds	r24, 0x061C
    52c8:	90 91 1d 06 	lds	r25, 0x061D
    52cc:	9b 83       	std	Y+3, r25	; 0x03
    52ce:	8a 83       	std	Y+2, r24	; 0x02
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    52d0:	81 e0       	ldi	r24, 0x01	; 1
    52d2:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    52d4:	80 91 c5 03 	lds	r24, 0x03C5
    52d8:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    52da:	80 91 c6 03 	lds	r24, 0x03C6
    52de:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    52e0:	80 91 c7 03 	lds	r24, 0x03C7
    52e4:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    52e6:	80 91 c8 03 	lds	r24, 0x03C8
    52ea:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    52ec:	81 e0       	ldi	r24, 0x01	; 1
    52ee:	90 e0       	ldi	r25, 0x00	; 0
    52f0:	99 8b       	std	Y+17, r25	; 0x11
    52f2:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    52f4:	80 91 29 06 	lds	r24, 0x0629
    52f8:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    52fa:	80 91 28 06 	lds	r24, 0x0628
    52fe:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    5300:	80 91 27 06 	lds	r24, 0x0627
    5304:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    5306:	80 91 26 06 	lds	r24, 0x0626
    530a:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    530c:	81 e0       	ldi	r24, 0x01	; 1
    530e:	90 e0       	ldi	r25, 0x00	; 0
    5310:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    5314:	80 91 2e 06 	lds	r24, 0x062E
    5318:	90 e0       	ldi	r25, 0x00	; 0
    531a:	80 7f       	andi	r24, 0xF0	; 240
    531c:	90 70       	andi	r25, 0x00	; 0
    531e:	81 35       	cpi	r24, 0x51	; 81
    5320:	91 05       	cpc	r25, r1
    5322:	0c f4       	brge	.+2      	; 0x5326 <uip_process+0x6a6>
    5324:	49 c0       	rjmp	.+146    	; 0x53b8 <uip_process+0x738>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    5326:	10 92 cb 03 	sts	0x03CB, r1
    532a:	34 c0       	rjmp	.+104    	; 0x5394 <uip_process+0x714>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    532c:	f9 01       	movw	r30, r18
    532e:	e0 50       	subi	r30, 0x00	; 0
    5330:	fa 4f       	sbci	r31, 0xFA	; 250
    5332:	86 a9       	ldd	r24, Z+54	; 0x36
    5334:	80 93 cc 03 	sts	0x03CC, r24
      if(opt == TCP_OPT_END) {
    5338:	88 23       	and	r24, r24
    533a:	f1 f1       	breq	.+124    	; 0x53b8 <uip_process+0x738>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    533c:	81 30       	cpi	r24, 0x01	; 1
    533e:	21 f4       	brne	.+8      	; 0x5348 <uip_process+0x6c8>
	++c;
    5340:	4f 5f       	subi	r20, 0xFF	; 255
    5342:	40 93 cb 03 	sts	0x03CB, r20
    5346:	26 c0       	rjmp	.+76     	; 0x5394 <uip_process+0x714>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    5348:	82 30       	cpi	r24, 0x02	; 2
    534a:	c1 f4       	brne	.+48     	; 0x537c <uip_process+0x6fc>
    534c:	87 a9       	ldd	r24, Z+55	; 0x37
    534e:	84 30       	cpi	r24, 0x04	; 4
    5350:	a9 f4       	brne	.+42     	; 0x537c <uip_process+0x6fc>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    5352:	30 ad       	ldd	r19, Z+56	; 0x38
    5354:	20 e0       	ldi	r18, 0x00	; 0
    5356:	81 ad       	ldd	r24, Z+57	; 0x39
    5358:	90 e0       	ldi	r25, 0x00	; 0
    535a:	82 2b       	or	r24, r18
    535c:	93 2b       	or	r25, r19
    535e:	90 93 ce 03 	sts	0x03CE, r25
    5362:	80 93 cd 03 	sts	0x03CD, r24
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    5366:	f5 e0       	ldi	r31, 0x05	; 5
    5368:	87 3a       	cpi	r24, 0xA7	; 167
    536a:	9f 07       	cpc	r25, r31
    536c:	10 f0       	brcs	.+4      	; 0x5372 <uip_process+0x6f2>
    536e:	86 ea       	ldi	r24, 0xA6	; 166
    5370:	95 e0       	ldi	r25, 0x05	; 5
    5372:	9b 8b       	std	Y+19, r25	; 0x13
    5374:	8a 8b       	std	Y+18, r24	; 0x12
    5376:	9d 8b       	std	Y+21, r25	; 0x15
    5378:	8c 8b       	std	Y+20, r24	; 0x14
    537a:	1e c0       	rjmp	.+60     	; 0x53b8 <uip_process+0x738>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    537c:	90 91 cb 03 	lds	r25, 0x03CB
    5380:	e9 2f       	mov	r30, r25
    5382:	f0 e0       	ldi	r31, 0x00	; 0
    5384:	e0 50       	subi	r30, 0x00	; 0
    5386:	fa 4f       	sbci	r31, 0xFA	; 250
    5388:	87 a9       	ldd	r24, Z+55	; 0x37
    538a:	88 23       	and	r24, r24
    538c:	a9 f0       	breq	.+42     	; 0x53b8 <uip_process+0x738>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    538e:	89 0f       	add	r24, r25
    5390:	80 93 cb 03 	sts	0x03CB, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    5394:	40 91 cb 03 	lds	r20, 0x03CB
    5398:	24 2f       	mov	r18, r20
    539a:	30 e0       	ldi	r19, 0x00	; 0
    539c:	80 91 2e 06 	lds	r24, 0x062E
    53a0:	82 95       	swap	r24
    53a2:	8f 70       	andi	r24, 0x0F	; 15
    53a4:	90 e0       	ldi	r25, 0x00	; 0
    53a6:	05 97       	sbiw	r24, 0x05	; 5
    53a8:	88 0f       	add	r24, r24
    53aa:	99 1f       	adc	r25, r25
    53ac:	88 0f       	add	r24, r24
    53ae:	99 1f       	adc	r25, r25
    53b0:	28 17       	cp	r18, r24
    53b2:	39 07       	cpc	r19, r25
    53b4:	0c f4       	brge	.+2      	; 0x53b8 <uip_process+0x738>
    53b6:	ba cf       	rjmp	.-140    	; 0x532c <uip_process+0x6ac>
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    53b8:	80 e1       	ldi	r24, 0x10	; 16
    53ba:	80 93 2f 06 	sts	0x062F, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    53be:	80 91 2f 06 	lds	r24, 0x062F
    53c2:	82 60       	ori	r24, 0x02	; 2
    53c4:	80 93 2f 06 	sts	0x062F, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    53c8:	82 e0       	ldi	r24, 0x02	; 2
    53ca:	80 93 36 06 	sts	0x0636, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    53ce:	84 e0       	ldi	r24, 0x04	; 4
    53d0:	80 93 37 06 	sts	0x0637, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    53d4:	85 e0       	ldi	r24, 0x05	; 5
    53d6:	80 93 38 06 	sts	0x0638, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    53da:	86 ea       	ldi	r24, 0xA6	; 166
    53dc:	80 93 39 06 	sts	0x0639, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    53e0:	8c e2       	ldi	r24, 0x2C	; 44
    53e2:	90 e0       	ldi	r25, 0x00	; 0
    53e4:	90 93 5e 04 	sts	0x045E, r25
    53e8:	80 93 5d 04 	sts	0x045D, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    53ec:	80 e6       	ldi	r24, 0x60	; 96
    53ee:	bb c2       	rjmp	.+1398   	; 0x5966 <uip_process+0xce6>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    53f0:	d0 93 69 04 	sts	0x0469, r29
    53f4:	c0 93 68 04 	sts	0x0468, r28
  uip_flags = 0;
    53f8:	10 92 65 04 	sts	0x0465, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    53fc:	80 91 2f 06 	lds	r24, 0x062F
    5400:	48 2f       	mov	r20, r24
    5402:	50 e0       	ldi	r21, 0x00	; 0
    5404:	82 ff       	sbrs	r24, 2
    5406:	07 c0       	rjmp	.+14     	; 0x5416 <uip_process+0x796>
    uip_connr->tcpstateflags = UIP_CLOSED;
    5408:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    540a:	81 e7       	ldi	r24, 0x71	; 113
    540c:	93 e0       	ldi	r25, 0x03	; 3
    540e:	0e 94 c7 10 	call	0x218e	; 0x218e <uip_log>
    uip_flags = UIP_ABORT;
    5412:	80 e2       	ldi	r24, 0x20	; 32
    5414:	51 c2       	rjmp	.+1186   	; 0x58b8 <uip_process+0xc38>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculated the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    5416:	80 91 2e 06 	lds	r24, 0x062E
    541a:	82 95       	swap	r24
    541c:	8f 70       	andi	r24, 0x0F	; 15
    541e:	88 0f       	add	r24, r24
    5420:	88 0f       	add	r24, r24
    5422:	80 93 cb 03 	sts	0x03CB, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    5426:	20 91 5d 04 	lds	r18, 0x045D
    542a:	30 91 5e 04 	lds	r19, 0x045E
    542e:	24 51       	subi	r18, 0x14	; 20
    5430:	30 40       	sbci	r19, 0x00	; 0
    5432:	28 1b       	sub	r18, r24
    5434:	31 09       	sbc	r19, r1
    5436:	30 93 5e 04 	sts	0x045E, r19
    543a:	20 93 5d 04 	sts	0x045D, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    543e:	89 8d       	ldd	r24, Y+25	; 0x19
    5440:	8f 70       	andi	r24, 0x0F	; 15
    5442:	82 30       	cpi	r24, 0x02	; 2
    5444:	29 f4       	brne	.+10     	; 0x5450 <uip_process+0x7d0>
    5446:	4f 73       	andi	r20, 0x3F	; 63
    5448:	50 70       	andi	r21, 0x00	; 0
    544a:	42 31       	cpi	r20, 0x12	; 18
    544c:	51 05       	cpc	r21, r1
    544e:	09 f1       	breq	.+66     	; 0x5492 <uip_process+0x812>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    5450:	23 2b       	or	r18, r19
    5452:	39 f4       	brne	.+14     	; 0x5462 <uip_process+0x7e2>
    5454:	80 91 2f 06 	lds	r24, 0x062F
    5458:	90 e0       	ldi	r25, 0x00	; 0
    545a:	83 70       	andi	r24, 0x03	; 3
    545c:	90 70       	andi	r25, 0x00	; 0
    545e:	89 2b       	or	r24, r25
    5460:	c1 f0       	breq	.+48     	; 0x5492 <uip_process+0x812>
    5462:	90 91 26 06 	lds	r25, 0x0626
    5466:	88 85       	ldd	r24, Y+8	; 0x08
    5468:	98 17       	cp	r25, r24
    546a:	09 f0       	breq	.+2      	; 0x546e <uip_process+0x7ee>
    546c:	72 c2       	rjmp	.+1252   	; 0x5952 <uip_process+0xcd2>
    546e:	90 91 27 06 	lds	r25, 0x0627
    5472:	89 85       	ldd	r24, Y+9	; 0x09
    5474:	98 17       	cp	r25, r24
    5476:	09 f0       	breq	.+2      	; 0x547a <uip_process+0x7fa>
    5478:	6c c2       	rjmp	.+1240   	; 0x5952 <uip_process+0xcd2>
    547a:	90 91 28 06 	lds	r25, 0x0628
    547e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5480:	98 17       	cp	r25, r24
    5482:	09 f0       	breq	.+2      	; 0x5486 <uip_process+0x806>
    5484:	66 c2       	rjmp	.+1228   	; 0x5952 <uip_process+0xcd2>
    5486:	90 91 29 06 	lds	r25, 0x0629
    548a:	8b 85       	ldd	r24, Y+11	; 0x0b
    548c:	98 17       	cp	r25, r24
    548e:	09 f0       	breq	.+2      	; 0x5492 <uip_process+0x812>
    5490:	60 c2       	rjmp	.+1216   	; 0x5952 <uip_process+0xcd2>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    5492:	80 91 2f 06 	lds	r24, 0x062F
    5496:	84 ff       	sbrs	r24, 4
    5498:	51 c0       	rjmp	.+162    	; 0x553c <uip_process+0x8bc>
    549a:	68 89       	ldd	r22, Y+16	; 0x10
    549c:	79 89       	ldd	r23, Y+17	; 0x11
    549e:	61 15       	cp	r22, r1
    54a0:	71 05       	cpc	r23, r1
    54a2:	09 f4       	brne	.+2      	; 0x54a6 <uip_process+0x826>
    54a4:	4b c0       	rjmp	.+150    	; 0x553c <uip_process+0x8bc>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    54a6:	ce 01       	movw	r24, r28
    54a8:	0c 96       	adiw	r24, 0x0c	; 12
    54aa:	0e 94 2c 24 	call	0x4858	; 0x4858 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    54ae:	20 91 2a 06 	lds	r18, 0x062A
    54b2:	80 91 61 04 	lds	r24, 0x0461
    54b6:	28 17       	cp	r18, r24
    54b8:	09 f0       	breq	.+2      	; 0x54bc <uip_process+0x83c>
    54ba:	40 c0       	rjmp	.+128    	; 0x553c <uip_process+0x8bc>
    54bc:	90 91 2b 06 	lds	r25, 0x062B
    54c0:	80 91 62 04 	lds	r24, 0x0462
    54c4:	98 17       	cp	r25, r24
    54c6:	d1 f5       	brne	.+116    	; 0x553c <uip_process+0x8bc>
    54c8:	90 91 2c 06 	lds	r25, 0x062C
    54cc:	80 91 63 04 	lds	r24, 0x0463
    54d0:	98 17       	cp	r25, r24
    54d2:	a1 f5       	brne	.+104    	; 0x553c <uip_process+0x8bc>
    54d4:	90 91 2d 06 	lds	r25, 0x062D
    54d8:	80 91 64 04 	lds	r24, 0x0464
    54dc:	98 17       	cp	r25, r24
    54de:	71 f5       	brne	.+92     	; 0x553c <uip_process+0x8bc>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    54e0:	2c 87       	std	Y+12, r18	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    54e2:	80 91 62 04 	lds	r24, 0x0462
    54e6:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    54e8:	80 91 63 04 	lds	r24, 0x0463
    54ec:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    54ee:	80 91 64 04 	lds	r24, 0x0464
    54f2:	8f 87       	std	Y+15, r24	; 0x0f
	

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    54f4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    54f6:	88 23       	and	r24, r24
    54f8:	d1 f4       	brne	.+52     	; 0x552e <uip_process+0x8ae>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    54fa:	2e 89       	ldd	r18, Y+22	; 0x16
    54fc:	98 8d       	ldd	r25, Y+24	; 0x18
    54fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    5500:	98 1b       	sub	r25, r24
    5502:	82 2f       	mov	r24, r18
    5504:	86 95       	lsr	r24
    5506:	86 95       	lsr	r24
    5508:	86 95       	lsr	r24
    550a:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    550c:	39 2f       	mov	r19, r25
    550e:	32 0f       	add	r19, r18
    5510:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    5512:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    5514:	28 2f       	mov	r18, r24
    5516:	26 95       	lsr	r18
    5518:	26 95       	lsr	r18
    551a:	82 1b       	sub	r24, r18
    551c:	97 fd       	sbrc	r25, 7
    551e:	91 95       	neg	r25
    5520:	89 0f       	add	r24, r25
    5522:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    5524:	36 95       	lsr	r19
    5526:	36 95       	lsr	r19
    5528:	36 95       	lsr	r19
    552a:	83 0f       	add	r24, r19
    552c:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    552e:	81 e0       	ldi	r24, 0x01	; 1
    5530:	80 93 65 04 	sts	0x0465, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    5534:	88 8d       	ldd	r24, Y+24	; 0x18
    5536:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    5538:	19 8a       	std	Y+17, r1	; 0x11
    553a:	18 8a       	std	Y+16, r1	; 0x10
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    553c:	89 8d       	ldd	r24, Y+25	; 0x19
    553e:	28 2f       	mov	r18, r24
    5540:	30 e0       	ldi	r19, 0x00	; 0
    5542:	c9 01       	movw	r24, r18
    5544:	8f 70       	andi	r24, 0x0F	; 15
    5546:	90 70       	andi	r25, 0x00	; 0
    5548:	84 30       	cpi	r24, 0x04	; 4
    554a:	91 05       	cpc	r25, r1
    554c:	09 f4       	brne	.+2      	; 0x5550 <uip_process+0x8d0>
    554e:	b9 c1       	rjmp	.+882    	; 0x58c2 <uip_process+0xc42>
    5550:	85 30       	cpi	r24, 0x05	; 5
    5552:	91 05       	cpc	r25, r1
    5554:	5c f4       	brge	.+22     	; 0x556c <uip_process+0x8ec>
    5556:	82 30       	cpi	r24, 0x02	; 2
    5558:	91 05       	cpc	r25, r1
    555a:	91 f1       	breq	.+100    	; 0x55c0 <uip_process+0x940>
    555c:	83 30       	cpi	r24, 0x03	; 3
    555e:	91 05       	cpc	r25, r1
    5560:	0c f0       	brlt	.+2      	; 0x5564 <uip_process+0x8e4>
    5562:	b1 c0       	rjmp	.+354    	; 0x56c6 <uip_process+0xa46>
    5564:	01 97       	sbiw	r24, 0x01	; 1
    5566:	09 f0       	breq	.+2      	; 0x556a <uip_process+0x8ea>
    5568:	a1 c2       	rjmp	.+1346   	; 0x5aac <uip_process+0xe2c>
    556a:	10 c0       	rjmp	.+32     	; 0x558c <uip_process+0x90c>
    556c:	86 30       	cpi	r24, 0x06	; 6
    556e:	91 05       	cpc	r25, r1
    5570:	09 f4       	brne	.+2      	; 0x5574 <uip_process+0x8f4>
    5572:	e7 c1       	rjmp	.+974    	; 0x5942 <uip_process+0xcc2>
    5574:	86 30       	cpi	r24, 0x06	; 6
    5576:	91 05       	cpc	r25, r1
    5578:	0c f4       	brge	.+2      	; 0x557c <uip_process+0x8fc>
    557a:	c3 c1       	rjmp	.+902    	; 0x5902 <uip_process+0xc82>
    557c:	87 30       	cpi	r24, 0x07	; 7
    557e:	91 05       	cpc	r25, r1
    5580:	09 f4       	brne	.+2      	; 0x5584 <uip_process+0x904>
    5582:	e7 c1       	rjmp	.+974    	; 0x5952 <uip_process+0xcd2>
    5584:	08 97       	sbiw	r24, 0x08	; 8
    5586:	09 f0       	breq	.+2      	; 0x558a <uip_process+0x90a>
    5588:	91 c2       	rjmp	.+1314   	; 0x5aac <uip_process+0xe2c>
    558a:	90 c1       	rjmp	.+800    	; 0x58ac <uip_process+0xc2c>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    558c:	80 91 65 04 	lds	r24, 0x0465
    5590:	80 ff       	sbrs	r24, 0
    5592:	8c c2       	rjmp	.+1304   	; 0x5aac <uip_process+0xe2c>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    5594:	83 e0       	ldi	r24, 0x03	; 3
    5596:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    5598:	80 e4       	ldi	r24, 0x40	; 64
    559a:	80 93 65 04 	sts	0x0465, r24
      uip_connr->len = 0;
    559e:	19 8a       	std	Y+17, r1	; 0x11
    55a0:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    55a2:	20 91 5d 04 	lds	r18, 0x045D
    55a6:	30 91 5e 04 	lds	r19, 0x045E
    55aa:	21 15       	cp	r18, r1
    55ac:	31 05       	cpc	r19, r1
    55ae:	09 f4       	brne	.+2      	; 0x55b2 <uip_process+0x932>
    55b0:	11 c1       	rjmp	.+546    	; 0x57d4 <uip_process+0xb54>
        uip_flags |= UIP_NEWDATA;
    55b2:	82 e4       	ldi	r24, 0x42	; 66
    55b4:	80 93 65 04 	sts	0x0465, r24
        uip_add_rcv_nxt(uip_len);
    55b8:	c9 01       	movw	r24, r18
    55ba:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
    55be:	0a c1       	rjmp	.+532    	; 0x57d4 <uip_process+0xb54>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    55c0:	80 91 65 04 	lds	r24, 0x0465
    55c4:	80 ff       	sbrs	r24, 0
    55c6:	74 c0       	rjmp	.+232    	; 0x56b0 <uip_process+0xa30>
    55c8:	80 91 2f 06 	lds	r24, 0x062F
    55cc:	8f 73       	andi	r24, 0x3F	; 63
    55ce:	82 31       	cpi	r24, 0x12	; 18
    55d0:	09 f0       	breq	.+2      	; 0x55d4 <uip_process+0x954>
    55d2:	6e c0       	rjmp	.+220    	; 0x56b0 <uip_process+0xa30>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    55d4:	80 91 2e 06 	lds	r24, 0x062E
    55d8:	90 e0       	ldi	r25, 0x00	; 0
    55da:	80 7f       	andi	r24, 0xF0	; 240
    55dc:	90 70       	andi	r25, 0x00	; 0
    55de:	81 35       	cpi	r24, 0x51	; 81
    55e0:	91 05       	cpc	r25, r1
    55e2:	0c f4       	brge	.+2      	; 0x55e6 <uip_process+0x966>
    55e4:	49 c0       	rjmp	.+146    	; 0x5678 <uip_process+0x9f8>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    55e6:	10 92 cb 03 	sts	0x03CB, r1
    55ea:	34 c0       	rjmp	.+104    	; 0x5654 <uip_process+0x9d4>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    55ec:	f9 01       	movw	r30, r18
    55ee:	e0 50       	subi	r30, 0x00	; 0
    55f0:	fa 4f       	sbci	r31, 0xFA	; 250
    55f2:	86 a9       	ldd	r24, Z+54	; 0x36
    55f4:	80 93 cc 03 	sts	0x03CC, r24
	  if(opt == TCP_OPT_END) {
    55f8:	88 23       	and	r24, r24
    55fa:	f1 f1       	breq	.+124    	; 0x5678 <uip_process+0x9f8>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    55fc:	81 30       	cpi	r24, 0x01	; 1
    55fe:	21 f4       	brne	.+8      	; 0x5608 <uip_process+0x988>
	    ++c;
    5600:	4f 5f       	subi	r20, 0xFF	; 255
    5602:	40 93 cb 03 	sts	0x03CB, r20
    5606:	26 c0       	rjmp	.+76     	; 0x5654 <uip_process+0x9d4>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    5608:	82 30       	cpi	r24, 0x02	; 2
    560a:	c1 f4       	brne	.+48     	; 0x563c <uip_process+0x9bc>
    560c:	87 a9       	ldd	r24, Z+55	; 0x37
    560e:	84 30       	cpi	r24, 0x04	; 4
    5610:	a9 f4       	brne	.+42     	; 0x563c <uip_process+0x9bc>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    5612:	30 ad       	ldd	r19, Z+56	; 0x38
    5614:	20 e0       	ldi	r18, 0x00	; 0
    5616:	81 ad       	ldd	r24, Z+57	; 0x39
    5618:	90 e0       	ldi	r25, 0x00	; 0
    561a:	82 2b       	or	r24, r18
    561c:	93 2b       	or	r25, r19
    561e:	90 93 ce 03 	sts	0x03CE, r25
    5622:	80 93 cd 03 	sts	0x03CD, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    5626:	25 e0       	ldi	r18, 0x05	; 5
    5628:	87 3a       	cpi	r24, 0xA7	; 167
    562a:	92 07       	cpc	r25, r18
    562c:	10 f0       	brcs	.+4      	; 0x5632 <uip_process+0x9b2>
    562e:	86 ea       	ldi	r24, 0xA6	; 166
    5630:	95 e0       	ldi	r25, 0x05	; 5
    5632:	9b 8b       	std	Y+19, r25	; 0x13
    5634:	8a 8b       	std	Y+18, r24	; 0x12
    5636:	9d 8b       	std	Y+21, r25	; 0x15
    5638:	8c 8b       	std	Y+20, r24	; 0x14
    563a:	1e c0       	rjmp	.+60     	; 0x5678 <uip_process+0x9f8>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    563c:	90 91 cb 03 	lds	r25, 0x03CB
    5640:	e9 2f       	mov	r30, r25
    5642:	f0 e0       	ldi	r31, 0x00	; 0
    5644:	e0 50       	subi	r30, 0x00	; 0
    5646:	fa 4f       	sbci	r31, 0xFA	; 250
    5648:	87 a9       	ldd	r24, Z+55	; 0x37
    564a:	88 23       	and	r24, r24
    564c:	a9 f0       	breq	.+42     	; 0x5678 <uip_process+0x9f8>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    564e:	89 0f       	add	r24, r25
    5650:	80 93 cb 03 	sts	0x03CB, r24
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    5654:	40 91 cb 03 	lds	r20, 0x03CB
    5658:	24 2f       	mov	r18, r20
    565a:	30 e0       	ldi	r19, 0x00	; 0
    565c:	80 91 2e 06 	lds	r24, 0x062E
    5660:	82 95       	swap	r24
    5662:	8f 70       	andi	r24, 0x0F	; 15
    5664:	90 e0       	ldi	r25, 0x00	; 0
    5666:	05 97       	sbiw	r24, 0x05	; 5
    5668:	88 0f       	add	r24, r24
    566a:	99 1f       	adc	r25, r25
    566c:	88 0f       	add	r24, r24
    566e:	99 1f       	adc	r25, r25
    5670:	28 17       	cp	r18, r24
    5672:	39 07       	cpc	r19, r25
    5674:	0c f4       	brge	.+2      	; 0x5678 <uip_process+0x9f8>
    5676:	ba cf       	rjmp	.-140    	; 0x55ec <uip_process+0x96c>
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    5678:	83 e0       	ldi	r24, 0x03	; 3
    567a:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    567c:	80 91 26 06 	lds	r24, 0x0626
    5680:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    5682:	80 91 27 06 	lds	r24, 0x0627
    5686:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    5688:	80 91 28 06 	lds	r24, 0x0628
    568c:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    568e:	80 91 29 06 	lds	r24, 0x0629
    5692:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    5694:	81 e0       	ldi	r24, 0x01	; 1
    5696:	90 e0       	ldi	r25, 0x00	; 0
    5698:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    569c:	82 e4       	ldi	r24, 0x42	; 66
    569e:	80 93 65 04 	sts	0x0465, r24
      uip_connr->len = 0;
    56a2:	19 8a       	std	Y+17, r1	; 0x11
    56a4:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    56a6:	10 92 5e 04 	sts	0x045E, r1
    56aa:	10 92 5d 04 	sts	0x045D, r1
    56ae:	92 c0       	rjmp	.+292    	; 0x57d4 <uip_process+0xb54>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    56b0:	80 e2       	ldi	r24, 0x20	; 32
    56b2:	80 93 65 04 	sts	0x0465, r24
    UIP_APPCALL();
    56b6:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    56ba:	e0 91 68 04 	lds	r30, 0x0468
    56be:	f0 91 69 04 	lds	r31, 0x0469
    56c2:	11 8e       	std	Z+25, r1	; 0x19
    56c4:	30 cd       	rjmp	.-1440   	; 0x5126 <uip_process+0x4a6>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    56c6:	80 91 2f 06 	lds	r24, 0x062F
    56ca:	80 ff       	sbrs	r24, 0
    56cc:	2a c0       	rjmp	.+84     	; 0x5722 <uip_process+0xaa2>
    56ce:	24 fd       	sbrc	r18, 4
    56d0:	28 c0       	rjmp	.+80     	; 0x5722 <uip_process+0xaa2>
      if(uip_outstanding(uip_connr)) {
    56d2:	88 89       	ldd	r24, Y+16	; 0x10
    56d4:	99 89       	ldd	r25, Y+17	; 0x11
    56d6:	89 2b       	or	r24, r25
    56d8:	09 f0       	breq	.+2      	; 0x56dc <uip_process+0xa5c>
    56da:	e8 c1       	rjmp	.+976    	; 0x5aac <uip_process+0xe2c>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    56dc:	80 91 5d 04 	lds	r24, 0x045D
    56e0:	90 91 5e 04 	lds	r25, 0x045E
    56e4:	01 96       	adiw	r24, 0x01	; 1
    56e6:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    56ea:	20 91 65 04 	lds	r18, 0x0465
    56ee:	82 2f       	mov	r24, r18
    56f0:	80 61       	ori	r24, 0x10	; 16
    56f2:	80 93 65 04 	sts	0x0465, r24
      if(uip_len > 0) {
    56f6:	80 91 5d 04 	lds	r24, 0x045D
    56fa:	90 91 5e 04 	lds	r25, 0x045E
    56fe:	89 2b       	or	r24, r25
    5700:	19 f0       	breq	.+6      	; 0x5708 <uip_process+0xa88>
	uip_flags |= UIP_NEWDATA;
    5702:	22 61       	ori	r18, 0x12	; 18
    5704:	20 93 65 04 	sts	0x0465, r18
      }
      UIP_APPCALL();
    5708:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>
      uip_connr->len = 1;
    570c:	81 e0       	ldi	r24, 0x01	; 1
    570e:	90 e0       	ldi	r25, 0x00	; 0
    5710:	99 8b       	std	Y+17, r25	; 0x11
    5712:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    5714:	88 e0       	ldi	r24, 0x08	; 8
    5716:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    5718:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    571a:	81 e1       	ldi	r24, 0x11	; 17
    571c:	80 93 2f 06 	sts	0x062F, r24
    5720:	1b c1       	rjmp	.+566    	; 0x5958 <uip_process+0xcd8>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    5722:	85 ff       	sbrs	r24, 5
    5724:	21 c0       	rjmp	.+66     	; 0x5768 <uip_process+0xae8>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    5726:	60 91 34 06 	lds	r22, 0x0634
    572a:	36 2f       	mov	r19, r22
    572c:	20 e0       	ldi	r18, 0x00	; 0
    572e:	40 91 35 06 	lds	r20, 0x0635
    5732:	50 e0       	ldi	r21, 0x00	; 0
    5734:	24 2b       	or	r18, r20
    5736:	35 2b       	or	r19, r21
    5738:	80 91 66 04 	lds	r24, 0x0466
    573c:	90 91 67 04 	lds	r25, 0x0467
    5740:	82 0f       	add	r24, r18
    5742:	93 1f       	adc	r25, r19
    5744:	90 93 67 04 	sts	0x0467, r25
    5748:	80 93 66 04 	sts	0x0466, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    574c:	96 2f       	mov	r25, r22
    574e:	80 e0       	ldi	r24, 0x00	; 0
    5750:	84 2b       	or	r24, r20
    5752:	95 2b       	or	r25, r21
    5754:	20 91 5d 04 	lds	r18, 0x045D
    5758:	30 91 5e 04 	lds	r19, 0x045E
    575c:	28 1b       	sub	r18, r24
    575e:	39 0b       	sbc	r19, r25
    5760:	30 93 5e 04 	sts	0x045E, r19
    5764:	20 93 5d 04 	sts	0x045D, r18
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    5768:	20 91 5d 04 	lds	r18, 0x045D
    576c:	30 91 5e 04 	lds	r19, 0x045E
    5770:	21 15       	cp	r18, r1
    5772:	31 05       	cpc	r19, r1
    5774:	59 f0       	breq	.+22     	; 0x578c <uip_process+0xb0c>
    5776:	89 8d       	ldd	r24, Y+25	; 0x19
    5778:	84 fd       	sbrc	r24, 4
    577a:	08 c0       	rjmp	.+16     	; 0x578c <uip_process+0xb0c>
      uip_flags |= UIP_NEWDATA;
    577c:	80 91 65 04 	lds	r24, 0x0465
    5780:	82 60       	ori	r24, 0x02	; 2
    5782:	80 93 65 04 	sts	0x0465, r24
      uip_add_rcv_nxt(uip_len);
    5786:	c9 01       	movw	r24, r18
    5788:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    578c:	90 91 30 06 	lds	r25, 0x0630
    5790:	80 e0       	ldi	r24, 0x00	; 0
    5792:	20 91 31 06 	lds	r18, 0x0631
    5796:	82 0f       	add	r24, r18
    5798:	91 1d       	adc	r25, r1
    579a:	90 93 ce 03 	sts	0x03CE, r25
    579e:	80 93 cd 03 	sts	0x03CD, r24
    if(tmp16 > uip_connr->initialmss ||
    57a2:	2c 89       	ldd	r18, Y+20	; 0x14
    57a4:	3d 89       	ldd	r19, Y+21	; 0x15
    57a6:	28 17       	cp	r18, r24
    57a8:	39 07       	cpc	r19, r25
    57aa:	10 f0       	brcs	.+4      	; 0x57b0 <uip_process+0xb30>
    57ac:	89 2b       	or	r24, r25
    57ae:	21 f4       	brne	.+8      	; 0x57b8 <uip_process+0xb38>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    57b0:	30 93 ce 03 	sts	0x03CE, r19
    57b4:	20 93 cd 03 	sts	0x03CD, r18
    }
    uip_connr->mss = tmp16;
    57b8:	80 91 cd 03 	lds	r24, 0x03CD
    57bc:	90 91 ce 03 	lds	r25, 0x03CE
    57c0:	9b 8b       	std	Y+19, r25	; 0x13
    57c2:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    57c4:	80 91 65 04 	lds	r24, 0x0465
    57c8:	90 e0       	ldi	r25, 0x00	; 0
    57ca:	83 70       	andi	r24, 0x03	; 3
    57cc:	90 70       	andi	r25, 0x00	; 0
    57ce:	89 2b       	or	r24, r25
    57d0:	09 f4       	brne	.+2      	; 0x57d4 <uip_process+0xb54>
    57d2:	6c c1       	rjmp	.+728    	; 0x5aac <uip_process+0xe2c>
      uip_slen = 0;
    57d4:	10 92 df 0b 	sts	0x0BDF, r1
    57d8:	10 92 de 0b 	sts	0x0BDE, r1
      UIP_APPCALL();
    57dc:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    57e0:	80 91 65 04 	lds	r24, 0x0465
    57e4:	28 2f       	mov	r18, r24
    57e6:	85 ff       	sbrs	r24, 5
    57e8:	07 c0       	rjmp	.+14     	; 0x57f8 <uip_process+0xb78>
	uip_slen = 0;
    57ea:	10 92 df 0b 	sts	0x0BDF, r1
    57ee:	10 92 de 0b 	sts	0x0BDE, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    57f2:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    57f4:	84 e1       	ldi	r24, 0x14	; 20
    57f6:	92 cf       	rjmp	.-220    	; 0x571c <uip_process+0xa9c>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    57f8:	84 ff       	sbrs	r24, 4
    57fa:	0a c0       	rjmp	.+20     	; 0x5810 <uip_process+0xb90>
	uip_slen = 0;
    57fc:	10 92 df 0b 	sts	0x0BDF, r1
    5800:	10 92 de 0b 	sts	0x0BDE, r1
	uip_connr->len = 1;
    5804:	81 e0       	ldi	r24, 0x01	; 1
    5806:	90 e0       	ldi	r25, 0x00	; 0
    5808:	99 8b       	std	Y+17, r25	; 0x11
    580a:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    580c:	84 e0       	ldi	r24, 0x04	; 4
    580e:	83 cf       	rjmp	.-250    	; 0x5716 <uip_process+0xa96>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    5810:	80 91 de 0b 	lds	r24, 0x0BDE
    5814:	90 91 df 0b 	lds	r25, 0x0BDF
    5818:	89 2b       	or	r24, r25
    581a:	01 f1       	breq	.+64     	; 0x585c <uip_process+0xbdc>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    581c:	20 ff       	sbrs	r18, 0
    581e:	02 c0       	rjmp	.+4      	; 0x5824 <uip_process+0xba4>
	  uip_connr->len = 0;
    5820:	19 8a       	std	Y+17, r1	; 0x11
    5822:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    5824:	88 89       	ldd	r24, Y+16	; 0x10
    5826:	99 89       	ldd	r25, Y+17	; 0x11
    5828:	00 97       	sbiw	r24, 0x00	; 0
    582a:	a1 f4       	brne	.+40     	; 0x5854 <uip_process+0xbd4>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    582c:	2a 89       	ldd	r18, Y+18	; 0x12
    582e:	3b 89       	ldd	r19, Y+19	; 0x13
    5830:	80 91 de 0b 	lds	r24, 0x0BDE
    5834:	90 91 df 0b 	lds	r25, 0x0BDF
    5838:	28 17       	cp	r18, r24
    583a:	39 07       	cpc	r19, r25
    583c:	20 f4       	brcc	.+8      	; 0x5846 <uip_process+0xbc6>
	    uip_slen = uip_connr->mss;
    583e:	30 93 df 0b 	sts	0x0BDF, r19
    5842:	20 93 de 0b 	sts	0x0BDE, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    5846:	80 91 de 0b 	lds	r24, 0x0BDE
    584a:	90 91 df 0b 	lds	r25, 0x0BDF
    584e:	99 8b       	std	Y+17, r25	; 0x11
    5850:	88 8b       	std	Y+16, r24	; 0x10
    5852:	04 c0       	rjmp	.+8      	; 0x585c <uip_process+0xbdc>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    5854:	90 93 df 0b 	sts	0x0BDF, r25
    5858:	80 93 de 0b 	sts	0x0BDE, r24
	}
      }
      uip_connr->nrtx = 0;
    585c:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    585e:	80 91 5f 04 	lds	r24, 0x045F
    5862:	90 91 60 04 	lds	r25, 0x0460
    5866:	90 93 67 04 	sts	0x0467, r25
    586a:	80 93 66 04 	sts	0x0466, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    586e:	80 91 de 0b 	lds	r24, 0x0BDE
    5872:	90 91 df 0b 	lds	r25, 0x0BDF
    5876:	89 2b       	or	r24, r25
    5878:	59 f0       	breq	.+22     	; 0x5890 <uip_process+0xc10>
    587a:	88 89       	ldd	r24, Y+16	; 0x10
    587c:	99 89       	ldd	r25, Y+17	; 0x11
    587e:	00 97       	sbiw	r24, 0x00	; 0
    5880:	39 f0       	breq	.+14     	; 0x5890 <uip_process+0xc10>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    5882:	88 96       	adiw	r24, 0x28	; 40
    5884:	90 93 5e 04 	sts	0x045E, r25
    5888:	80 93 5d 04 	sts	0x045D, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    588c:	88 e1       	ldi	r24, 0x18	; 24
    588e:	0b c0       	rjmp	.+22     	; 0x58a6 <uip_process+0xc26>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    5890:	80 91 65 04 	lds	r24, 0x0465
    5894:	81 ff       	sbrs	r24, 1
    5896:	0a c1       	rjmp	.+532    	; 0x5aac <uip_process+0xe2c>
	uip_len = UIP_TCPIP_HLEN;
    5898:	88 e2       	ldi	r24, 0x28	; 40
    589a:	90 e0       	ldi	r25, 0x00	; 0
    589c:	90 93 5e 04 	sts	0x045E, r25
    58a0:	80 93 5d 04 	sts	0x045D, r24
	BUF->flags = TCP_ACK;
    58a4:	80 e1       	ldi	r24, 0x10	; 16
    58a6:	80 93 2f 06 	sts	0x062F, r24
    58aa:	5c c0       	rjmp	.+184    	; 0x5964 <uip_process+0xce4>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    58ac:	80 91 65 04 	lds	r24, 0x0465
    58b0:	80 ff       	sbrs	r24, 0
    58b2:	fc c0       	rjmp	.+504    	; 0x5aac <uip_process+0xe2c>
      uip_connr->tcpstateflags = UIP_CLOSED;
    58b4:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    58b6:	80 e1       	ldi	r24, 0x10	; 16
    58b8:	80 93 65 04 	sts	0x0465, r24
      UIP_APPCALL();
    58bc:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>
    58c0:	f5 c0       	rjmp	.+490    	; 0x5aac <uip_process+0xe2c>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    58c2:	80 91 5d 04 	lds	r24, 0x045D
    58c6:	90 91 5e 04 	lds	r25, 0x045E
    58ca:	00 97       	sbiw	r24, 0x00	; 0
    58cc:	11 f0       	breq	.+4      	; 0x58d2 <uip_process+0xc52>
      uip_add_rcv_nxt(uip_len);
    58ce:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    58d2:	80 91 2f 06 	lds	r24, 0x062F
    58d6:	90 91 65 04 	lds	r25, 0x0465
    58da:	80 ff       	sbrs	r24, 0
    58dc:	0b c0       	rjmp	.+22     	; 0x58f4 <uip_process+0xc74>
      if(uip_flags & UIP_ACKDATA) {
    58de:	90 ff       	sbrs	r25, 0
    58e0:	06 c0       	rjmp	.+12     	; 0x58ee <uip_process+0xc6e>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    58e2:	87 e0       	ldi	r24, 0x07	; 7
    58e4:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    58e6:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    58e8:	19 8a       	std	Y+17, r1	; 0x11
    58ea:	18 8a       	std	Y+16, r1	; 0x10
    58ec:	19 c0       	rjmp	.+50     	; 0x5920 <uip_process+0xca0>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    58ee:	86 e0       	ldi	r24, 0x06	; 6
    58f0:	89 8f       	std	Y+25, r24	; 0x19
    58f2:	16 c0       	rjmp	.+44     	; 0x5920 <uip_process+0xca0>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    58f4:	90 ff       	sbrs	r25, 0
    58f6:	1e c0       	rjmp	.+60     	; 0x5934 <uip_process+0xcb4>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    58f8:	85 e0       	ldi	r24, 0x05	; 5
    58fa:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    58fc:	19 8a       	std	Y+17, r1	; 0x11
    58fe:	18 8a       	std	Y+16, r1	; 0x10
    5900:	d5 c0       	rjmp	.+426    	; 0x5aac <uip_process+0xe2c>
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    5902:	80 91 5d 04 	lds	r24, 0x045D
    5906:	90 91 5e 04 	lds	r25, 0x045E
    590a:	00 97       	sbiw	r24, 0x00	; 0
    590c:	11 f0       	breq	.+4      	; 0x5912 <uip_process+0xc92>
      uip_add_rcv_nxt(uip_len);
    590e:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    5912:	80 91 2f 06 	lds	r24, 0x062F
    5916:	80 ff       	sbrs	r24, 0
    5918:	0d c0       	rjmp	.+26     	; 0x5934 <uip_process+0xcb4>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    591a:	87 e0       	ldi	r24, 0x07	; 7
    591c:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    591e:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    5920:	81 e0       	ldi	r24, 0x01	; 1
    5922:	90 e0       	ldi	r25, 0x00	; 0
    5924:	0e 94 ff 25 	call	0x4bfe	; 0x4bfe <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    5928:	80 e1       	ldi	r24, 0x10	; 16
    592a:	80 93 65 04 	sts	0x0465, r24
      UIP_APPCALL();
    592e:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <httpd_appcall>
    5932:	0f c0       	rjmp	.+30     	; 0x5952 <uip_process+0xcd2>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    5934:	80 91 5d 04 	lds	r24, 0x045D
    5938:	90 91 5e 04 	lds	r25, 0x045E
    593c:	89 2b       	or	r24, r25
    593e:	49 f4       	brne	.+18     	; 0x5952 <uip_process+0xcd2>
    5940:	b5 c0       	rjmp	.+362    	; 0x5aac <uip_process+0xe2c>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    5942:	80 91 65 04 	lds	r24, 0x0465
    5946:	80 ff       	sbrs	r24, 0
    5948:	b1 c0       	rjmp	.+354    	; 0x5aac <uip_process+0xe2c>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    594a:	87 e0       	ldi	r24, 0x07	; 7
    594c:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    594e:	1a 8e       	std	Y+26, r1	; 0x1a
    5950:	ad c0       	rjmp	.+346    	; 0x5aac <uip_process+0xe2c>
  

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    5952:	80 e1       	ldi	r24, 0x10	; 16
    5954:	f8 01       	movw	r30, r16
    5956:	81 a3       	std	Z+33, r24	; 0x21
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    5958:	88 e2       	ldi	r24, 0x28	; 40
    595a:	90 e0       	ldi	r25, 0x00	; 0
    595c:	90 93 5e 04 	sts	0x045E, r25
    5960:	80 93 5d 04 	sts	0x045D, r24
 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    5964:	80 e5       	ldi	r24, 0x50	; 80
    5966:	80 93 2e 06 	sts	0x062E, r24
 tcp_send:
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    596a:	88 85       	ldd	r24, Y+8	; 0x08
    596c:	80 93 2a 06 	sts	0x062A, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    5970:	89 85       	ldd	r24, Y+9	; 0x09
    5972:	80 93 2b 06 	sts	0x062B, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    5976:	8a 85       	ldd	r24, Y+10	; 0x0a
    5978:	80 93 2c 06 	sts	0x062C, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    597c:	8b 85       	ldd	r24, Y+11	; 0x0b
    597e:	80 93 2d 06 	sts	0x062D, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    5982:	8c 85       	ldd	r24, Y+12	; 0x0c
    5984:	80 93 26 06 	sts	0x0626, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    5988:	8d 85       	ldd	r24, Y+13	; 0x0d
    598a:	80 93 27 06 	sts	0x0627, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    598e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5990:	80 93 28 06 	sts	0x0628, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    5994:	8f 85       	ldd	r24, Y+15	; 0x0f
    5996:	80 93 29 06 	sts	0x0629, r24

  BUF->proto = UIP_PROTO_TCP;
    599a:	86 e0       	ldi	r24, 0x06	; 6
    599c:	80 93 17 06 	sts	0x0617, r24
  
  BUF->srcport  = uip_connr->lport;
    59a0:	8c 81       	ldd	r24, Y+4	; 0x04
    59a2:	9d 81       	ldd	r25, Y+5	; 0x05
    59a4:	90 93 23 06 	sts	0x0623, r25
    59a8:	80 93 22 06 	sts	0x0622, r24
  BUF->destport = uip_connr->rport;
    59ac:	8e 81       	ldd	r24, Y+6	; 0x06
    59ae:	9f 81       	ldd	r25, Y+7	; 0x07
    59b0:	90 93 25 06 	sts	0x0625, r25
    59b4:	80 93 24 06 	sts	0x0624, r24

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    59b8:	80 91 fc 05 	lds	r24, 0x05FC
    59bc:	90 91 fd 05 	lds	r25, 0x05FD
    59c0:	90 93 1b 06 	sts	0x061B, r25
    59c4:	80 93 1a 06 	sts	0x061A, r24
    59c8:	80 91 fe 05 	lds	r24, 0x05FE
    59cc:	90 91 ff 05 	lds	r25, 0x05FF
    59d0:	90 93 1d 06 	sts	0x061D, r25
    59d4:	80 93 1c 06 	sts	0x061C, r24
  uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
    59d8:	88 81       	ld	r24, Y
    59da:	99 81       	ldd	r25, Y+1	; 0x01
    59dc:	90 93 1f 06 	sts	0x061F, r25
    59e0:	80 93 1e 06 	sts	0x061E, r24
    59e4:	8a 81       	ldd	r24, Y+2	; 0x02
    59e6:	9b 81       	ldd	r25, Y+3	; 0x03
    59e8:	90 93 21 06 	sts	0x0621, r25
    59ec:	80 93 20 06 	sts	0x0620, r24

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    59f0:	89 8d       	ldd	r24, Y+25	; 0x19
    59f2:	84 ff       	sbrs	r24, 4
    59f4:	05 c0       	rjmp	.+10     	; 0x5a00 <uip_process+0xd80>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    59f6:	10 92 31 06 	sts	0x0631, r1
    59fa:	10 92 30 06 	sts	0x0630, r1
    59fe:	06 c0       	rjmp	.+12     	; 0x5a0c <uip_process+0xd8c>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    5a00:	85 e0       	ldi	r24, 0x05	; 5
    5a02:	80 93 30 06 	sts	0x0630, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    5a06:	86 ea       	ldi	r24, 0xA6	; 166
    5a08:	80 93 31 06 	sts	0x0631, r24
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    5a0c:	80 e4       	ldi	r24, 0x40	; 64
    5a0e:	80 93 16 06 	sts	0x0616, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    5a12:	80 91 5e 04 	lds	r24, 0x045E
    5a16:	80 93 10 06 	sts	0x0610, r24
  BUF->len[1] = (uip_len & 0xff);
    5a1a:	80 91 5d 04 	lds	r24, 0x045D
    5a1e:	80 93 11 06 	sts	0x0611, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    5a22:	10 92 35 06 	sts	0x0635, r1
    5a26:	10 92 34 06 	sts	0x0634, r1
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    5a2a:	10 92 33 06 	sts	0x0633, r1
    5a2e:	10 92 32 06 	sts	0x0632, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    5a32:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <uip_tcpchksum>
    5a36:	80 95       	com	r24
    5a38:	90 95       	com	r25
    5a3a:	90 93 33 06 	sts	0x0633, r25
    5a3e:	80 93 32 06 	sts	0x0632, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    5a42:	85 e4       	ldi	r24, 0x45	; 69
    5a44:	80 93 0e 06 	sts	0x060E, r24
  BUF->tos = 0;
    5a48:	10 92 0f 06 	sts	0x060F, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    5a4c:	10 92 15 06 	sts	0x0615, r1
    5a50:	10 92 14 06 	sts	0x0614, r1
  ++ipid;
    5a54:	80 91 c3 03 	lds	r24, 0x03C3
    5a58:	90 91 c4 03 	lds	r25, 0x03C4
    5a5c:	01 96       	adiw	r24, 0x01	; 1
    5a5e:	90 93 c4 03 	sts	0x03C4, r25
    5a62:	80 93 c3 03 	sts	0x03C3, r24
  BUF->ipid[0] = ipid >> 8;
    5a66:	90 93 12 06 	sts	0x0612, r25
  BUF->ipid[1] = ipid & 0xff;
    5a6a:	80 93 13 06 	sts	0x0613, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    5a6e:	10 92 19 06 	sts	0x0619, r1
    5a72:	10 92 18 06 	sts	0x0618, r1
  BUF->ipchksum = ~(uip_ipchksum());
    5a76:	0e 94 8c 24 	call	0x4918	; 0x4918 <uip_ipchksum>
    5a7a:	80 95       	com	r24
    5a7c:	90 95       	com	r25
    5a7e:	90 93 19 06 	sts	0x0619, r25
    5a82:	80 93 18 06 	sts	0x0618, r24
  DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
#endif /* UIP_CONF_IPV6 */
   
  UIP_STAT(++uip_stat.tcp.sent);
    5a86:	80 91 ea 05 	lds	r24, 0x05EA
    5a8a:	90 91 eb 05 	lds	r25, 0x05EB
    5a8e:	01 96       	adiw	r24, 0x01	; 1
    5a90:	90 93 eb 05 	sts	0x05EB, r25
    5a94:	80 93 ea 05 	sts	0x05EA, r24
 send:
  DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
	       (BUF->len[0] << 8) | BUF->len[1]);
  
  UIP_STAT(++uip_stat.ip.sent);
    5a98:	80 91 d0 05 	lds	r24, 0x05D0
    5a9c:	90 91 d1 05 	lds	r25, 0x05D1
    5aa0:	01 96       	adiw	r24, 0x01	; 1
    5aa2:	90 93 d1 05 	sts	0x05D1, r25
    5aa6:	80 93 d0 05 	sts	0x05D0, r24
    5aaa:	04 c0       	rjmp	.+8      	; 0x5ab4 <uip_process+0xe34>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;
 drop:
  uip_len = 0;
    5aac:	10 92 5e 04 	sts	0x045E, r1
    5ab0:	10 92 5d 04 	sts	0x045D, r1
  uip_flags = 0;
    5ab4:	10 92 65 04 	sts	0x0465, r1
  return;
}
    5ab8:	df 91       	pop	r29
    5aba:	cf 91       	pop	r28
    5abc:	1f 91       	pop	r17
    5abe:	0f 91       	pop	r16
    5ac0:	08 95       	ret

00005ac2 <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    5ac2:	df 92       	push	r13
    5ac4:	ef 92       	push	r14
    5ac6:	ff 92       	push	r15
    5ac8:	0f 93       	push	r16
    5aca:	1f 93       	push	r17
    5acc:	cf 93       	push	r28
    5ace:	df 93       	push	r29
    5ad0:	dc 01       	movw	r26, r24
    5ad2:	06 2f       	mov	r16, r22
    5ad4:	d7 2e       	mov	r13, r23
  register struct arp_entry *tabptr=0;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5ad6:	10 92 ff 03 	sts	0x03FF, r1
    5ada:	e0 e0       	ldi	r30, 0x00	; 0
    5adc:	f0 e0       	ldi	r31, 0x00	; 0
    5ade:	60 e0       	ldi	r22, 0x00	; 0

    tabptr = &arp_table[i];
    5ae0:	1b e0       	ldi	r17, 0x0B	; 11
    5ae2:	2b c0       	rjmp	.+86     	; 0x5b3a <uip_arp_update+0x78>
    5ae4:	61 9f       	mul	r22, r17
    5ae6:	f0 01       	movw	r30, r0
    5ae8:	11 24       	eor	r1, r1
    5aea:	e1 53       	subi	r30, 0x31	; 49
    5aec:	fc 4f       	sbci	r31, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(tabptr->ipaddr[0] != 0 &&
    5aee:	40 81       	ld	r20, Z
    5af0:	51 81       	ldd	r21, Z+1	; 0x01
    5af2:	41 15       	cp	r20, r1
    5af4:	51 05       	cpc	r21, r1
    5af6:	01 f1       	breq	.+64     	; 0x5b38 <uip_arp_update+0x76>
    5af8:	22 81       	ldd	r18, Z+2	; 0x02
    5afa:	33 81       	ldd	r19, Z+3	; 0x03
    5afc:	21 15       	cp	r18, r1
    5afe:	31 05       	cpc	r19, r1
    5b00:	d9 f0       	breq	.+54     	; 0x5b38 <uip_arp_update+0x76>
       tabptr->ipaddr[1] != 0) {

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(ipaddr[0] == tabptr->ipaddr[0] &&
    5b02:	8d 91       	ld	r24, X+
    5b04:	9c 91       	ld	r25, X
    5b06:	11 97       	sbiw	r26, 0x01	; 1
    5b08:	84 17       	cp	r24, r20
    5b0a:	95 07       	cpc	r25, r21
    5b0c:	a9 f4       	brne	.+42     	; 0x5b38 <uip_arp_update+0x76>
    5b0e:	12 96       	adiw	r26, 0x02	; 2
    5b10:	8d 91       	ld	r24, X+
    5b12:	9c 91       	ld	r25, X
    5b14:	13 97       	sbiw	r26, 0x03	; 3
    5b16:	82 17       	cp	r24, r18
    5b18:	93 07       	cpc	r25, r19
    5b1a:	71 f4       	brne	.+28     	; 0x5b38 <uip_arp_update+0x76>
    5b1c:	60 93 ff 03 	sts	0x03FF, r22
	 ipaddr[1] == tabptr->ipaddr[1]) {
	 
	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    5b20:	ef 01       	movw	r28, r30
    5b22:	24 96       	adiw	r28, 0x04	; 4
    5b24:	80 2f       	mov	r24, r16
    5b26:	9d 2d       	mov	r25, r13
    5b28:	9c 01       	movw	r18, r24
    5b2a:	d9 01       	movw	r26, r18
    5b2c:	86 e0       	ldi	r24, 0x06	; 6
    5b2e:	0d 90       	ld	r0, X+
    5b30:	09 92       	st	Y+, r0
    5b32:	81 50       	subi	r24, 0x01	; 1
    5b34:	e1 f7       	brne	.-8      	; 0x5b2e <uip_arp_update+0x6c>
    5b36:	67 c0       	rjmp	.+206    	; 0x5c06 <uip_arp_update+0x144>
	tabptr->time = arptime;

	return;
    5b38:	6f 5f       	subi	r22, 0xFF	; 255
{
  register struct arp_entry *tabptr=0;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5b3a:	64 30       	cpi	r22, 0x04	; 4
    5b3c:	98 f2       	brcs	.-90     	; 0x5ae4 <uip_arp_update+0x22>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5b3e:	10 92 ff 03 	sts	0x03FF, r1
    5b42:	20 e0       	ldi	r18, 0x00	; 0
    tabptr = &arp_table[i];
    5b44:	3b e0       	ldi	r19, 0x0B	; 11
    5b46:	11 c0       	rjmp	.+34     	; 0x5b6a <uip_arp_update+0xa8>
    5b48:	23 9f       	mul	r18, r19
    5b4a:	f0 01       	movw	r30, r0
    5b4c:	11 24       	eor	r1, r1
    5b4e:	e1 53       	subi	r30, 0x31	; 49
    5b50:	fc 4f       	sbci	r31, 0xFC	; 252
    if(tabptr->ipaddr[0] == 0 &&
    5b52:	80 81       	ld	r24, Z
    5b54:	91 81       	ldd	r25, Z+1	; 0x01
    5b56:	89 2b       	or	r24, r25
    5b58:	39 f4       	brne	.+14     	; 0x5b68 <uip_arp_update+0xa6>
    5b5a:	82 81       	ldd	r24, Z+2	; 0x02
    5b5c:	93 81       	ldd	r25, Z+3	; 0x03
    5b5e:	89 2b       	or	r24, r25
    5b60:	19 f4       	brne	.+6      	; 0x5b68 <uip_arp_update+0xa6>
    5b62:	20 93 ff 03 	sts	0x03FF, r18
    5b66:	3c c0       	rjmp	.+120    	; 0x5be0 <uip_arp_update+0x11e>
    5b68:	2f 5f       	subi	r18, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5b6a:	24 30       	cpi	r18, 0x04	; 4
    5b6c:	68 f3       	brcs	.-38     	; 0x5b48 <uip_arp_update+0x86>
    5b6e:	20 93 ff 03 	sts	0x03FF, r18
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    5b72:	24 30       	cpi	r18, 0x04	; 4
    5b74:	a9 f5       	brne	.+106    	; 0x5be0 <uip_arp_update+0x11e>
    tmpage = 0;
    5b76:	10 92 02 04 	sts	0x0402, r1
    c = 0;
    5b7a:	10 92 00 04 	sts	0x0400, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    5b7e:	10 91 01 04 	lds	r17, 0x0401
    5b82:	c1 2f       	mov	r28, r17
    5b84:	d0 e0       	ldi	r29, 0x00	; 0
    5b86:	60 e0       	ldi	r22, 0x00	; 0
    5b88:	70 e0       	ldi	r23, 0x00	; 0
    5b8a:	40 e0       	ldi	r20, 0x00	; 0
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5b8c:	8b e0       	ldi	r24, 0x0B	; 11
    5b8e:	e8 2e       	mov	r14, r24
    5b90:	f1 2c       	mov	r15, r1
    5b92:	18 c0       	rjmp	.+48     	; 0x5bc4 <uip_arp_update+0x102>
    5b94:	84 2f       	mov	r24, r20
    5b96:	90 e0       	ldi	r25, 0x00	; 0
    5b98:	8e 9d       	mul	r24, r14
    5b9a:	f0 01       	movw	r30, r0
    5b9c:	8f 9d       	mul	r24, r15
    5b9e:	f0 0d       	add	r31, r0
    5ba0:	9e 9d       	mul	r25, r14
    5ba2:	f0 0d       	add	r31, r0
    5ba4:	11 24       	eor	r1, r1
    5ba6:	e1 53       	subi	r30, 0x31	; 49
    5ba8:	fc 4f       	sbci	r31, 0xFC	; 252
    5baa:	52 85       	ldd	r21, Z+10	; 0x0a
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    5bac:	9e 01       	movw	r18, r28
    5bae:	25 1b       	sub	r18, r21
    5bb0:	31 09       	sbc	r19, r1
    5bb2:	87 2f       	mov	r24, r23
    5bb4:	90 e0       	ldi	r25, 0x00	; 0
    5bb6:	82 17       	cp	r24, r18
    5bb8:	93 07       	cpc	r25, r19
    5bba:	1c f4       	brge	.+6      	; 0x5bc2 <uip_arp_update+0x100>
	tmpage = arptime - tabptr->time;
    5bbc:	71 2f       	mov	r23, r17
    5bbe:	75 1b       	sub	r23, r21
    5bc0:	64 2f       	mov	r22, r20
    5bc2:	4f 5f       	subi	r20, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5bc4:	44 30       	cpi	r20, 0x04	; 4
    5bc6:	30 f3       	brcs	.-52     	; 0x5b94 <uip_arp_update+0xd2>
    5bc8:	60 93 00 04 	sts	0x0400, r22
    5bcc:	70 93 02 04 	sts	0x0402, r23
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    5bd0:	60 93 ff 03 	sts	0x03FF, r22
    tabptr = &arp_table[i];
    5bd4:	8b e0       	ldi	r24, 0x0B	; 11
    5bd6:	68 9f       	mul	r22, r24
    5bd8:	f0 01       	movw	r30, r0
    5bda:	11 24       	eor	r1, r1
    5bdc:	e1 53       	subi	r30, 0x31	; 49
    5bde:	fc 4f       	sbci	r31, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  memcpy(tabptr->ipaddr, ipaddr, 4);
    5be0:	8d 91       	ld	r24, X+
    5be2:	9d 91       	ld	r25, X+
    5be4:	0d 90       	ld	r0, X+
    5be6:	bc 91       	ld	r27, X
    5be8:	a0 2d       	mov	r26, r0
    5bea:	ef 01       	movw	r28, r30
    5bec:	89 93       	st	Y+, r24
    5bee:	99 93       	st	Y+, r25
    5bf0:	a9 93       	st	Y+, r26
    5bf2:	b9 93       	st	Y+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    5bf4:	20 2f       	mov	r18, r16
    5bf6:	3d 2d       	mov	r19, r13
    5bf8:	c9 01       	movw	r24, r18
    5bfa:	dc 01       	movw	r26, r24
    5bfc:	86 e0       	ldi	r24, 0x06	; 6
    5bfe:	0d 90       	ld	r0, X+
    5c00:	09 92       	st	Y+, r0
    5c02:	81 50       	subi	r24, 0x01	; 1
    5c04:	e1 f7       	brne	.-8      	; 0x5bfe <uip_arp_update+0x13c>
  tabptr->time = arptime;
    5c06:	80 91 01 04 	lds	r24, 0x0401
    5c0a:	82 87       	std	Z+10, r24	; 0x0a
}
    5c0c:	df 91       	pop	r29
    5c0e:	cf 91       	pop	r28
    5c10:	1f 91       	pop	r17
    5c12:	0f 91       	pop	r16
    5c14:	ff 90       	pop	r15
    5c16:	ef 90       	pop	r14
    5c18:	df 90       	pop	r13
    5c1a:	08 95       	ret

00005c1c <uip_arp_ipin>:
 */
/*-----------------------------------------------------------------------------------*/
#if 1
void
uip_arp_ipin(void)
{
    5c1c:	80 91 5d 04 	lds	r24, 0x045D
    5c20:	90 91 5e 04 	lds	r25, 0x045E
    5c24:	0e 97       	sbiw	r24, 0x0e	; 14
    5c26:	90 93 5e 04 	sts	0x045E, r25
    5c2a:	80 93 5d 04 	sts	0x045D, r24
  uip_len -= sizeof(struct uip_eth_hdr);
	
  /* Only insert/update an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  if((IPBUF->srcipaddr[0] & uip_netmask[0]) !=
    5c2e:	80 91 fc 05 	lds	r24, 0x05FC
    5c32:	90 91 fd 05 	lds	r25, 0x05FD
    5c36:	20 91 1a 06 	lds	r18, 0x061A
    5c3a:	30 91 1b 06 	lds	r19, 0x061B
    5c3e:	82 27       	eor	r24, r18
    5c40:	93 27       	eor	r25, r19
    5c42:	20 91 f8 05 	lds	r18, 0x05F8
    5c46:	30 91 f9 05 	lds	r19, 0x05F9
    5c4a:	82 23       	and	r24, r18
    5c4c:	93 23       	and	r25, r19
    5c4e:	89 2b       	or	r24, r25
    5c50:	c1 f4       	brne	.+48     	; 0x5c82 <uip_arp_ipin+0x66>
     (uip_hostaddr[0] & uip_netmask[0])) {
    return;
  }
  if((IPBUF->srcipaddr[1] & uip_netmask[1]) !=
    5c52:	80 91 fe 05 	lds	r24, 0x05FE
    5c56:	90 91 ff 05 	lds	r25, 0x05FF
    5c5a:	20 91 1c 06 	lds	r18, 0x061C
    5c5e:	30 91 1d 06 	lds	r19, 0x061D
    5c62:	82 27       	eor	r24, r18
    5c64:	93 27       	eor	r25, r19
    5c66:	20 91 fa 05 	lds	r18, 0x05FA
    5c6a:	30 91 fb 05 	lds	r19, 0x05FB
    5c6e:	82 23       	and	r24, r18
    5c70:	93 23       	and	r25, r19
    5c72:	89 2b       	or	r24, r25
    5c74:	31 f4       	brne	.+12     	; 0x5c82 <uip_arp_ipin+0x66>
     (uip_hostaddr[1] & uip_netmask[1])) {
    return;
  }
  uip_arp_update(IPBUF->srcipaddr, &(IPBUF->ethhdr.src));
    5c76:	66 e0       	ldi	r22, 0x06	; 6
    5c78:	76 e0       	ldi	r23, 0x06	; 6
    5c7a:	8a e1       	ldi	r24, 0x1A	; 26
    5c7c:	96 e0       	ldi	r25, 0x06	; 6
    5c7e:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <uip_arp_update>
    5c82:	08 95       	ret

00005c84 <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    5c84:	cf 93       	push	r28
    5c86:	df 93       	push	r29
  
  if(uip_len < sizeof(struct arp_hdr)) {
    5c88:	80 91 5d 04 	lds	r24, 0x045D
    5c8c:	90 91 5e 04 	lds	r25, 0x045E
    5c90:	8a 97       	sbiw	r24, 0x2a	; 42
    5c92:	28 f4       	brcc	.+10     	; 0x5c9e <uip_arp_arpin+0x1a>
    uip_len = 0;
    5c94:	10 92 5e 04 	sts	0x045E, r1
    5c98:	10 92 5d 04 	sts	0x045D, r1
    5c9c:	a6 c0       	rjmp	.+332    	; 0x5dea <uip_arp_arpin+0x166>
    return;
  }
  uip_len = 0;
    5c9e:	10 92 5e 04 	sts	0x045E, r1
    5ca2:	10 92 5d 04 	sts	0x045D, r1
  
  switch(BUF->opcode) {
    5ca6:	c0 e0       	ldi	r28, 0x00	; 0
    5ca8:	d6 e0       	ldi	r29, 0x06	; 6
    5caa:	80 91 14 06 	lds	r24, 0x0614
    5cae:	90 91 15 06 	lds	r25, 0x0615
    5cb2:	21 e0       	ldi	r18, 0x01	; 1
    5cb4:	80 30       	cpi	r24, 0x00	; 0
    5cb6:	92 07       	cpc	r25, r18
    5cb8:	29 f0       	breq	.+10     	; 0x5cc4 <uip_arp_arpin+0x40>
    5cba:	80 50       	subi	r24, 0x00	; 0
    5cbc:	92 40       	sbci	r25, 0x02	; 2
    5cbe:	09 f0       	breq	.+2      	; 0x5cc2 <uip_arp_arpin+0x3e>
    5cc0:	94 c0       	rjmp	.+296    	; 0x5dea <uip_arp_arpin+0x166>
    5cc2:	76 c0       	rjmp	.+236    	; 0x5db0 <uip_arp_arpin+0x12c>
  case HTONS(ARP_REQUEST):
    /* ARP request. If it asked for our address, we send out a
       reply. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    5cc4:	20 91 26 06 	lds	r18, 0x0626
    5cc8:	30 91 27 06 	lds	r19, 0x0627
    5ccc:	80 91 fc 05 	lds	r24, 0x05FC
    5cd0:	90 91 fd 05 	lds	r25, 0x05FD
    5cd4:	28 17       	cp	r18, r24
    5cd6:	39 07       	cpc	r19, r25
    5cd8:	09 f0       	breq	.+2      	; 0x5cdc <uip_arp_arpin+0x58>
    5cda:	87 c0       	rjmp	.+270    	; 0x5dea <uip_arp_arpin+0x166>
    5cdc:	20 91 28 06 	lds	r18, 0x0628
    5ce0:	30 91 29 06 	lds	r19, 0x0629
    5ce4:	80 91 fe 05 	lds	r24, 0x05FE
    5ce8:	90 91 ff 05 	lds	r25, 0x05FF
    5cec:	28 17       	cp	r18, r24
    5cee:	39 07       	cpc	r19, r25
    5cf0:	09 f0       	breq	.+2      	; 0x5cf4 <uip_arp_arpin+0x70>
    5cf2:	7b c0       	rjmp	.+246    	; 0x5dea <uip_arp_arpin+0x166>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    5cf4:	be 01       	movw	r22, r28
    5cf6:	6a 5e       	subi	r22, 0xEA	; 234
    5cf8:	7f 4f       	sbci	r23, 0xFF	; 255
    5cfa:	ce 01       	movw	r24, r28
    5cfc:	4c 96       	adiw	r24, 0x1c	; 28
    5cfe:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <uip_arp_update>
      
      /* The reply opcode is 2. */
      BUF->opcode = HTONS(2);
    5d02:	80 e0       	ldi	r24, 0x00	; 0
    5d04:	92 e0       	ldi	r25, 0x02	; 2
    5d06:	90 93 15 06 	sts	0x0615, r25
    5d0a:	80 93 14 06 	sts	0x0614, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    5d0e:	de 01       	movw	r26, r28
    5d10:	90 96       	adiw	r26, 0x20	; 32
    5d12:	fe 01       	movw	r30, r28
    5d14:	76 96       	adiw	r30, 0x16	; 22
    5d16:	86 e0       	ldi	r24, 0x06	; 6
    5d18:	01 90       	ld	r0, Z+
    5d1a:	0d 92       	st	X+, r0
    5d1c:	81 50       	subi	r24, 0x01	; 1
    5d1e:	e1 f7       	brne	.-8      	; 0x5d18 <uip_arp_arpin+0x94>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    5d20:	a6 e1       	ldi	r26, 0x16	; 22
    5d22:	b6 e0       	ldi	r27, 0x06	; 6
    5d24:	ed eb       	ldi	r30, 0xBD	; 189
    5d26:	f3 e0       	ldi	r31, 0x03	; 3
    5d28:	86 e0       	ldi	r24, 0x06	; 6
    5d2a:	01 90       	ld	r0, Z+
    5d2c:	0d 92       	st	X+, r0
    5d2e:	81 50       	subi	r24, 0x01	; 1
    5d30:	e1 f7       	brne	.-8      	; 0x5d2a <uip_arp_arpin+0xa6>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    5d32:	a6 e0       	ldi	r26, 0x06	; 6
    5d34:	b6 e0       	ldi	r27, 0x06	; 6
    5d36:	ed eb       	ldi	r30, 0xBD	; 189
    5d38:	f3 e0       	ldi	r31, 0x03	; 3
    5d3a:	86 e0       	ldi	r24, 0x06	; 6
    5d3c:	01 90       	ld	r0, Z+
    5d3e:	0d 92       	st	X+, r0
    5d40:	81 50       	subi	r24, 0x01	; 1
    5d42:	e1 f7       	brne	.-8      	; 0x5d3c <uip_arp_arpin+0xb8>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    5d44:	e0 e0       	ldi	r30, 0x00	; 0
    5d46:	f6 e0       	ldi	r31, 0x06	; 6
    5d48:	df 01       	movw	r26, r30
    5d4a:	90 96       	adiw	r26, 0x20	; 32
    5d4c:	86 e0       	ldi	r24, 0x06	; 6
    5d4e:	0d 90       	ld	r0, X+
    5d50:	01 92       	st	Z+, r0
    5d52:	81 50       	subi	r24, 0x01	; 1
    5d54:	e1 f7       	brne	.-8      	; 0x5d4e <uip_arp_arpin+0xca>
      
      BUF->dipaddr[0] = BUF->sipaddr[0];
    5d56:	80 91 1c 06 	lds	r24, 0x061C
    5d5a:	90 91 1d 06 	lds	r25, 0x061D
    5d5e:	90 93 27 06 	sts	0x0627, r25
    5d62:	80 93 26 06 	sts	0x0626, r24
      BUF->dipaddr[1] = BUF->sipaddr[1];
    5d66:	80 91 1e 06 	lds	r24, 0x061E
    5d6a:	90 91 1f 06 	lds	r25, 0x061F
    5d6e:	90 93 29 06 	sts	0x0629, r25
    5d72:	80 93 28 06 	sts	0x0628, r24
      BUF->sipaddr[0] = uip_hostaddr[0];
    5d76:	80 91 fc 05 	lds	r24, 0x05FC
    5d7a:	90 91 fd 05 	lds	r25, 0x05FD
    5d7e:	90 93 1d 06 	sts	0x061D, r25
    5d82:	80 93 1c 06 	sts	0x061C, r24
      BUF->sipaddr[1] = uip_hostaddr[1];
    5d86:	80 91 fe 05 	lds	r24, 0x05FE
    5d8a:	90 91 ff 05 	lds	r25, 0x05FF
    5d8e:	90 93 1f 06 	sts	0x061F, r25
    5d92:	80 93 1e 06 	sts	0x061E, r24

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    5d96:	88 e0       	ldi	r24, 0x08	; 8
    5d98:	96 e0       	ldi	r25, 0x06	; 6
    5d9a:	90 93 0d 06 	sts	0x060D, r25
    5d9e:	80 93 0c 06 	sts	0x060C, r24
      uip_len = sizeof(struct arp_hdr);
    5da2:	8a e2       	ldi	r24, 0x2A	; 42
    5da4:	90 e0       	ldi	r25, 0x00	; 0
    5da6:	90 93 5e 04 	sts	0x045E, r25
    5daa:	80 93 5d 04 	sts	0x045D, r24
    5dae:	1d c0       	rjmp	.+58     	; 0x5dea <uip_arp_arpin+0x166>
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    5db0:	20 91 26 06 	lds	r18, 0x0626
    5db4:	30 91 27 06 	lds	r19, 0x0627
    5db8:	80 91 fc 05 	lds	r24, 0x05FC
    5dbc:	90 91 fd 05 	lds	r25, 0x05FD
    5dc0:	28 17       	cp	r18, r24
    5dc2:	39 07       	cpc	r19, r25
    5dc4:	91 f4       	brne	.+36     	; 0x5dea <uip_arp_arpin+0x166>
    5dc6:	20 91 28 06 	lds	r18, 0x0628
    5dca:	30 91 29 06 	lds	r19, 0x0629
    5dce:	80 91 fe 05 	lds	r24, 0x05FE
    5dd2:	90 91 ff 05 	lds	r25, 0x05FF
    5dd6:	28 17       	cp	r18, r24
    5dd8:	39 07       	cpc	r19, r25
    5dda:	39 f4       	brne	.+14     	; 0x5dea <uip_arp_arpin+0x166>
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    5ddc:	be 01       	movw	r22, r28
    5dde:	6a 5e       	subi	r22, 0xEA	; 234
    5de0:	7f 4f       	sbci	r23, 0xFF	; 255
    5de2:	ce 01       	movw	r24, r28
    5de4:	4c 96       	adiw	r24, 0x1c	; 28
    5de6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <uip_arp_update>
    }
    break;
  }

  return;
}
    5dea:	df 91       	pop	r29
    5dec:	cf 91       	pop	r28
    5dee:	08 95       	ret

00005df0 <uip_arp_out>:
 * uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
    5df0:	40 91 1e 06 	lds	r20, 0x061E
    5df4:	50 91 1f 06 	lds	r21, 0x061F
    5df8:	2f ef       	ldi	r18, 0xFF	; 255
    5dfa:	4f 3f       	cpi	r20, 0xFF	; 255
    5dfc:	52 07       	cpc	r21, r18
    5dfe:	89 f4       	brne	.+34     	; 0x5e22 <uip_arp_out+0x32>
    5e00:	80 91 20 06 	lds	r24, 0x0620
    5e04:	90 91 21 06 	lds	r25, 0x0621
    5e08:	8f 5f       	subi	r24, 0xFF	; 255
    5e0a:	9f 4f       	sbci	r25, 0xFF	; 255
    5e0c:	51 f4       	brne	.+20     	; 0x5e22 <uip_arp_out+0x32>
     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    5e0e:	a0 e0       	ldi	r26, 0x00	; 0
    5e10:	b6 e0       	ldi	r27, 0x06	; 6
    5e12:	e6 e9       	ldi	r30, 0x96	; 150
    5e14:	f3 e0       	ldi	r31, 0x03	; 3
    5e16:	86 e0       	ldi	r24, 0x06	; 6
    5e18:	01 90       	ld	r0, Z+
    5e1a:	0d 92       	st	X+, r0
    5e1c:	81 50       	subi	r24, 0x01	; 1
    5e1e:	e1 f7       	brne	.-8      	; 0x5e18 <uip_arp_out+0x28>
    5e20:	cf c0       	rjmp	.+414    	; 0x5fc0 <uip_arp_out+0x1d0>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {
    5e22:	80 91 fc 05 	lds	r24, 0x05FC
    5e26:	90 91 fd 05 	lds	r25, 0x05FD
    5e2a:	84 27       	eor	r24, r20
    5e2c:	95 27       	eor	r25, r21
    5e2e:	20 91 f8 05 	lds	r18, 0x05F8
    5e32:	30 91 f9 05 	lds	r19, 0x05F9
    5e36:	82 23       	and	r24, r18
    5e38:	93 23       	and	r25, r19
    5e3a:	89 2b       	or	r24, r25
    5e3c:	91 f4       	brne	.+36     	; 0x5e62 <uip_arp_out+0x72>
    5e3e:	60 91 20 06 	lds	r22, 0x0620
    5e42:	70 91 21 06 	lds	r23, 0x0621
    5e46:	80 91 fe 05 	lds	r24, 0x05FE
    5e4a:	90 91 ff 05 	lds	r25, 0x05FF
    5e4e:	86 27       	eor	r24, r22
    5e50:	97 27       	eor	r25, r23
    5e52:	20 91 fa 05 	lds	r18, 0x05FA
    5e56:	30 91 fb 05 	lds	r19, 0x05FB
    5e5a:	82 23       	and	r24, r18
    5e5c:	93 23       	and	r25, r19
    5e5e:	89 2b       	or	r24, r25
    5e60:	89 f0       	breq	.+34     	; 0x5e84 <uip_arp_out+0x94>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(ipaddr, uip_draddr);
    5e62:	80 91 c8 05 	lds	r24, 0x05C8
    5e66:	90 91 c9 05 	lds	r25, 0x05C9
    5e6a:	90 93 fc 03 	sts	0x03FC, r25
    5e6e:	80 93 fb 03 	sts	0x03FB, r24
    5e72:	80 91 ca 05 	lds	r24, 0x05CA
    5e76:	90 91 cb 05 	lds	r25, 0x05CB
    5e7a:	90 93 fe 03 	sts	0x03FE, r25
    5e7e:	80 93 fd 03 	sts	0x03FD, r24
    5e82:	08 c0       	rjmp	.+16     	; 0x5e94 <uip_arp_out+0xa4>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    5e84:	50 93 fc 03 	sts	0x03FC, r21
    5e88:	40 93 fb 03 	sts	0x03FB, r20
    5e8c:	70 93 fe 03 	sts	0x03FE, r23
    5e90:	60 93 fd 03 	sts	0x03FD, r22
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5e94:	10 92 ff 03 	sts	0x03FF, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    5e98:	60 91 fb 03 	lds	r22, 0x03FB
    5e9c:	70 91 fc 03 	lds	r23, 0x03FC
    5ea0:	40 91 fd 03 	lds	r20, 0x03FD
    5ea4:	50 91 fe 03 	lds	r21, 0x03FE
    5ea8:	e0 e0       	ldi	r30, 0x00	; 0
    5eaa:	f0 e0       	ldi	r31, 0x00	; 0
    5eac:	20 e0       	ldi	r18, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    5eae:	3b e0       	ldi	r19, 0x0B	; 11
    5eb0:	13 c0       	rjmp	.+38     	; 0x5ed8 <uip_arp_out+0xe8>
    5eb2:	23 9f       	mul	r18, r19
    5eb4:	f0 01       	movw	r30, r0
    5eb6:	11 24       	eor	r1, r1
    5eb8:	e1 53       	subi	r30, 0x31	; 49
    5eba:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    5ebc:	80 81       	ld	r24, Z
    5ebe:	91 81       	ldd	r25, Z+1	; 0x01
    5ec0:	68 17       	cp	r22, r24
    5ec2:	79 07       	cpc	r23, r25
    5ec4:	41 f4       	brne	.+16     	; 0x5ed6 <uip_arp_out+0xe6>
    5ec6:	82 81       	ldd	r24, Z+2	; 0x02
    5ec8:	93 81       	ldd	r25, Z+3	; 0x03
    5eca:	48 17       	cp	r20, r24
    5ecc:	59 07       	cpc	r21, r25
    5ece:	19 f4       	brne	.+6      	; 0x5ed6 <uip_arp_out+0xe6>
    5ed0:	20 93 ff 03 	sts	0x03FF, r18
    5ed4:	6d c0       	rjmp	.+218    	; 0x5fb0 <uip_arp_out+0x1c0>
    5ed6:	2f 5f       	subi	r18, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5ed8:	24 30       	cpi	r18, 0x04	; 4
    5eda:	58 f3       	brcs	.-42     	; 0x5eb2 <uip_arp_out+0xc2>
    5edc:	20 93 ff 03 	sts	0x03FF, r18
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    5ee0:	24 30       	cpi	r18, 0x04	; 4
    5ee2:	09 f0       	breq	.+2      	; 0x5ee6 <uip_arp_out+0xf6>
    5ee4:	65 c0       	rjmp	.+202    	; 0x5fb0 <uip_arp_out+0x1c0>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    5ee6:	46 e0       	ldi	r20, 0x06	; 6
    5ee8:	50 e0       	ldi	r21, 0x00	; 0
    5eea:	6f ef       	ldi	r22, 0xFF	; 255
    5eec:	70 e0       	ldi	r23, 0x00	; 0
    5eee:	80 e0       	ldi	r24, 0x00	; 0
    5ef0:	96 e0       	ldi	r25, 0x06	; 6
    5ef2:	0e 94 a5 32 	call	0x654a	; 0x654a <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    5ef6:	e0 e2       	ldi	r30, 0x20	; 32
    5ef8:	f6 e0       	ldi	r31, 0x06	; 6
    5efa:	86 e0       	ldi	r24, 0x06	; 6
    5efc:	df 01       	movw	r26, r30
    5efe:	1d 92       	st	X+, r1
    5f00:	8a 95       	dec	r24
    5f02:	e9 f7       	brne	.-6      	; 0x5efe <uip_arp_out+0x10e>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    5f04:	7a 97       	sbiw	r30, 0x1a	; 26
    5f06:	ad eb       	ldi	r26, 0xBD	; 189
    5f08:	b3 e0       	ldi	r27, 0x03	; 3
    5f0a:	86 e0       	ldi	r24, 0x06	; 6
    5f0c:	0d 90       	ld	r0, X+
    5f0e:	01 92       	st	Z+, r0
    5f10:	81 50       	subi	r24, 0x01	; 1
    5f12:	e1 f7       	brne	.-8      	; 0x5f0c <uip_arp_out+0x11c>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    5f14:	a6 e1       	ldi	r26, 0x16	; 22
    5f16:	b6 e0       	ldi	r27, 0x06	; 6
    5f18:	ed eb       	ldi	r30, 0xBD	; 189
    5f1a:	f3 e0       	ldi	r31, 0x03	; 3
    5f1c:	86 e0       	ldi	r24, 0x06	; 6
    5f1e:	01 90       	ld	r0, Z+
    5f20:	0d 92       	st	X+, r0
    5f22:	81 50       	subi	r24, 0x01	; 1
    5f24:	e1 f7       	brne	.-8      	; 0x5f1e <uip_arp_out+0x12e>
    
      uip_ipaddr_copy(BUF->dipaddr, ipaddr);
    5f26:	80 91 fb 03 	lds	r24, 0x03FB
    5f2a:	90 91 fc 03 	lds	r25, 0x03FC
    5f2e:	90 93 27 06 	sts	0x0627, r25
    5f32:	80 93 26 06 	sts	0x0626, r24
    5f36:	80 91 fd 03 	lds	r24, 0x03FD
    5f3a:	90 91 fe 03 	lds	r25, 0x03FE
    5f3e:	90 93 29 06 	sts	0x0629, r25
    5f42:	80 93 28 06 	sts	0x0628, r24
      uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);
    5f46:	80 91 fc 05 	lds	r24, 0x05FC
    5f4a:	90 91 fd 05 	lds	r25, 0x05FD
    5f4e:	90 93 1d 06 	sts	0x061D, r25
    5f52:	80 93 1c 06 	sts	0x061C, r24
    5f56:	80 91 fe 05 	lds	r24, 0x05FE
    5f5a:	90 91 ff 05 	lds	r25, 0x05FF
    5f5e:	90 93 1f 06 	sts	0x061F, r25
    5f62:	80 93 1e 06 	sts	0x061E, r24
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    5f66:	80 e0       	ldi	r24, 0x00	; 0
    5f68:	91 e0       	ldi	r25, 0x01	; 1
    5f6a:	90 93 15 06 	sts	0x0615, r25
    5f6e:	80 93 14 06 	sts	0x0614, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    5f72:	90 93 0f 06 	sts	0x060F, r25
    5f76:	80 93 0e 06 	sts	0x060E, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    5f7a:	88 e0       	ldi	r24, 0x08	; 8
    5f7c:	90 e0       	ldi	r25, 0x00	; 0
    5f7e:	90 93 11 06 	sts	0x0611, r25
    5f82:	80 93 10 06 	sts	0x0610, r24
      BUF->hwlen = 6;
    5f86:	86 e0       	ldi	r24, 0x06	; 6
    5f88:	80 93 12 06 	sts	0x0612, r24
      BUF->protolen = 4;
    5f8c:	84 e0       	ldi	r24, 0x04	; 4
    5f8e:	80 93 13 06 	sts	0x0613, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    5f92:	88 e0       	ldi	r24, 0x08	; 8
    5f94:	96 e0       	ldi	r25, 0x06	; 6
    5f96:	90 93 0d 06 	sts	0x060D, r25
    5f9a:	80 93 0c 06 	sts	0x060C, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    5f9e:	86 e3       	ldi	r24, 0x36	; 54
    5fa0:	96 e0       	ldi	r25, 0x06	; 6
    5fa2:	90 93 67 04 	sts	0x0467, r25
    5fa6:	80 93 66 04 	sts	0x0466, r24
    
      uip_len = sizeof(struct arp_hdr);
    5faa:	8a e2       	ldi	r24, 0x2A	; 42
    5fac:	90 e0       	ldi	r25, 0x00	; 0
    5fae:	1c c0       	rjmp	.+56     	; 0x5fe8 <uip_arp_out+0x1f8>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    5fb0:	a0 e0       	ldi	r26, 0x00	; 0
    5fb2:	b6 e0       	ldi	r27, 0x06	; 6
    5fb4:	34 96       	adiw	r30, 0x04	; 4
    5fb6:	86 e0       	ldi	r24, 0x06	; 6
    5fb8:	01 90       	ld	r0, Z+
    5fba:	0d 92       	st	X+, r0
    5fbc:	81 50       	subi	r24, 0x01	; 1
    5fbe:	e1 f7       	brne	.-8      	; 0x5fb8 <uip_arp_out+0x1c8>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    5fc0:	a6 e0       	ldi	r26, 0x06	; 6
    5fc2:	b6 e0       	ldi	r27, 0x06	; 6
    5fc4:	ed eb       	ldi	r30, 0xBD	; 189
    5fc6:	f3 e0       	ldi	r31, 0x03	; 3
    5fc8:	86 e0       	ldi	r24, 0x06	; 6
    5fca:	01 90       	ld	r0, Z+
    5fcc:	0d 92       	st	X+, r0
    5fce:	81 50       	subi	r24, 0x01	; 1
    5fd0:	e1 f7       	brne	.-8      	; 0x5fca <uip_arp_out+0x1da>
  
  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    5fd2:	88 e0       	ldi	r24, 0x08	; 8
    5fd4:	90 e0       	ldi	r25, 0x00	; 0
    5fd6:	90 93 0d 06 	sts	0x060D, r25
    5fda:	80 93 0c 06 	sts	0x060C, r24

  uip_len += sizeof(struct uip_eth_hdr);
    5fde:	80 91 5d 04 	lds	r24, 0x045D
    5fe2:	90 91 5e 04 	lds	r25, 0x045E
    5fe6:	0e 96       	adiw	r24, 0x0e	; 14
    5fe8:	90 93 5e 04 	sts	0x045E, r25
    5fec:	80 93 5d 04 	sts	0x045D, r24
    5ff0:	08 95       	ret

00005ff2 <uip_arp_timer>:
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_timer(void)
{
    5ff2:	80 91 01 04 	lds	r24, 0x0401
    5ff6:	8f 5f       	subi	r24, 0xFF	; 255
    5ff8:	80 93 01 04 	sts	0x0401, r24
  struct arp_entry *tabptr;
  
  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    5ffc:	10 92 ff 03 	sts	0x03FF, r1
    tabptr = &arp_table[i];
    6000:	4b e0       	ldi	r20, 0x0B	; 11
    6002:	1f c0       	rjmp	.+62     	; 0x6042 <uip_arp_timer+0x50>
    6004:	24 9f       	mul	r18, r20
    6006:	f0 01       	movw	r30, r0
    6008:	11 24       	eor	r1, r1
    600a:	e1 53       	subi	r30, 0x31	; 49
    600c:	fc 4f       	sbci	r31, 0xFC	; 252
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
    600e:	82 81       	ldd	r24, Z+2	; 0x02
    6010:	93 81       	ldd	r25, Z+3	; 0x03
    6012:	20 81       	ld	r18, Z
    6014:	31 81       	ldd	r19, Z+1	; 0x01
    6016:	82 2b       	or	r24, r18
    6018:	93 2b       	or	r25, r19
    601a:	89 2b       	or	r24, r25
    601c:	69 f0       	breq	.+26     	; 0x6038 <uip_arp_timer+0x46>
    601e:	80 91 01 04 	lds	r24, 0x0401
    6022:	90 e0       	ldi	r25, 0x00	; 0
    6024:	22 85       	ldd	r18, Z+10	; 0x0a
    6026:	82 1b       	sub	r24, r18
    6028:	91 09       	sbc	r25, r1
    602a:	88 37       	cpi	r24, 0x78	; 120
    602c:	91 05       	cpc	r25, r1
    602e:	24 f0       	brlt	.+8      	; 0x6038 <uip_arp_timer+0x46>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    6030:	10 82       	st	Z, r1
    6032:	11 82       	std	Z+1, r1	; 0x01
    6034:	12 82       	std	Z+2, r1	; 0x02
    6036:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    6038:	80 91 ff 03 	lds	r24, 0x03FF
    603c:	8f 5f       	subi	r24, 0xFF	; 255
    603e:	80 93 ff 03 	sts	0x03FF, r24
    6042:	20 91 ff 03 	lds	r18, 0x03FF
    6046:	24 30       	cpi	r18, 0x04	; 4
    6048:	e8 f2       	brcs	.-70     	; 0x6004 <uip_arp_timer+0x12>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    }
  }

}
    604a:	08 95       	ret

0000604c <uip_arp_init>:
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
    604c:	10 92 ff 03 	sts	0x03FF, r1
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    memset(arp_table[i].ipaddr, 0, 4);
    6050:	9b e0       	ldi	r25, 0x0B	; 11
    6052:	0c c0       	rjmp	.+24     	; 0x606c <uip_arp_init+0x20>
    6054:	89 9f       	mul	r24, r25
    6056:	f0 01       	movw	r30, r0
    6058:	11 24       	eor	r1, r1
    605a:	e1 53       	subi	r30, 0x31	; 49
    605c:	fc 4f       	sbci	r31, 0xFC	; 252
    605e:	10 82       	st	Z, r1
    6060:	11 82       	std	Z+1, r1	; 0x01
    6062:	12 82       	std	Z+2, r1	; 0x02
    6064:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    6066:	8f 5f       	subi	r24, 0xFF	; 255
    6068:	80 93 ff 03 	sts	0x03FF, r24
    606c:	80 91 ff 03 	lds	r24, 0x03FF
    6070:	84 30       	cpi	r24, 0x04	; 4
    6072:	80 f3       	brcs	.-32     	; 0x6054 <uip_arp_init+0x8>
    memset(arp_table[i].ipaddr, 0, 4);
  }
}
    6074:	08 95       	ret

00006076 <uiplib_ipaddrconv>:


/*-----------------------------------------------------------------------------------*/
unsigned char
uiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)
{
    6076:	fc 01       	movw	r30, r24
    6078:	db 01       	movw	r26, r22
    607a:	20 e0       	ldi	r18, 0x00	; 0
    607c:	40 e0       	ldi	r20, 0x00	; 0
      if(c == '.' || c == 0) {
	*ipaddr = tmp;
	++ipaddr;
	tmp = 0;
      } else if(c >= '0' && c <= '9') {
	tmp = (tmp * 10) + (c - '0');
    607e:	5a e0       	ldi	r21, 0x0A	; 10


/*-----------------------------------------------------------------------------------*/
unsigned char
uiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)
{
    6080:	30 e0       	ldi	r19, 0x00	; 0
  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    j = 0;
    do {
      c = *addrstr;
    6082:	80 81       	ld	r24, Z
      ++j;
    6084:	3f 5f       	subi	r19, 0xFF	; 255
      if(j > 4) {
    6086:	35 30       	cpi	r19, 0x05	; 5
    6088:	c9 f0       	breq	.+50     	; 0x60bc <uiplib_ipaddrconv+0x46>
	return 0;
      }
      if(c == '.' || c == 0) {
    608a:	8e 32       	cpi	r24, 0x2E	; 46
    608c:	11 f0       	breq	.+4      	; 0x6092 <uiplib_ipaddrconv+0x1c>
    608e:	88 23       	and	r24, r24
    6090:	19 f4       	brne	.+6      	; 0x6098 <uiplib_ipaddrconv+0x22>
	*ipaddr = tmp;
    6092:	2d 93       	st	X+, r18
	++ipaddr;
    6094:	20 e0       	ldi	r18, 0x00	; 0
    6096:	08 c0       	rjmp	.+16     	; 0x60a8 <uiplib_ipaddrconv+0x32>
	tmp = 0;
      } else if(c >= '0' && c <= '9') {
    6098:	98 2f       	mov	r25, r24
    609a:	90 53       	subi	r25, 0x30	; 48
    609c:	9a 30       	cpi	r25, 0x0A	; 10
    609e:	70 f4       	brcc	.+28     	; 0x60bc <uiplib_ipaddrconv+0x46>
	tmp = (tmp * 10) + (c - '0');
    60a0:	25 9f       	mul	r18, r21
    60a2:	20 2d       	mov	r18, r0
    60a4:	11 24       	eor	r1, r1
    60a6:	29 0f       	add	r18, r25
      } else {
	return 0;
      }
      ++addrstr;
    60a8:	31 96       	adiw	r30, 0x01	; 1
    } while(c != '.' && c != 0);
    60aa:	8e 32       	cpi	r24, 0x2E	; 46
    60ac:	11 f0       	breq	.+4      	; 0x60b2 <uiplib_ipaddrconv+0x3c>
    60ae:	88 23       	and	r24, r24
    60b0:	41 f7       	brne	.-48     	; 0x6082 <uiplib_ipaddrconv+0xc>
  char c;
  unsigned char i, j;

  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    60b2:	4f 5f       	subi	r20, 0xFF	; 255
    60b4:	44 30       	cpi	r20, 0x04	; 4
    60b6:	21 f7       	brne	.-56     	; 0x6080 <uiplib_ipaddrconv+0xa>
    60b8:	81 e0       	ldi	r24, 0x01	; 1
    60ba:	08 95       	ret
    60bc:	80 e0       	ldi	r24, 0x00	; 0
      }
      ++addrstr;
    } while(c != '.' && c != 0);
  }
  return 1;
}
    60be:	08 95       	ret

000060c0 <uip_neighbor_init>:
static struct neighbor_entry entries[ENTRIES];

/*---------------------------------------------------------------------------*/
void
uip_neighbor_init(void)
{
    60c0:	ed e0       	ldi	r30, 0x0D	; 13
    60c2:	f4 e0       	ldi	r31, 0x04	; 4
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    entries[i].time = MAX_TIME;
    60c4:	80 e8       	ldi	r24, 0x80	; 128
    60c6:	80 83       	st	Z, r24
    60c8:	3b 96       	adiw	r30, 0x0b	; 11
void
uip_neighbor_init(void)
{
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    60ca:	94 e0       	ldi	r25, 0x04	; 4
    60cc:	e5 36       	cpi	r30, 0x65	; 101
    60ce:	f9 07       	cpc	r31, r25
    60d0:	d1 f7       	brne	.-12     	; 0x60c6 <uip_neighbor_init+0x6>
    entries[i].time = MAX_TIME;
  }
}
    60d2:	08 95       	ret

000060d4 <uip_neighbor_periodic>:
/*---------------------------------------------------------------------------*/
void
uip_neighbor_periodic(void)
{
    60d4:	ed e0       	ldi	r30, 0x0D	; 13
    60d6:	f4 e0       	ldi	r31, 0x04	; 4
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    if(entries[i].time < MAX_TIME) {
    60d8:	80 81       	ld	r24, Z
    60da:	87 fd       	sbrc	r24, 7
    60dc:	02 c0       	rjmp	.+4      	; 0x60e2 <uip_neighbor_periodic+0xe>
      entries[i].time++;
    60de:	8f 5f       	subi	r24, 0xFF	; 255
    60e0:	80 83       	st	Z, r24
    60e2:	3b 96       	adiw	r30, 0x0b	; 11
void
uip_neighbor_periodic(void)
{
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    60e4:	84 e0       	ldi	r24, 0x04	; 4
    60e6:	e5 36       	cpi	r30, 0x65	; 101
    60e8:	f8 07       	cpc	r31, r24
    60ea:	b1 f7       	brne	.-20     	; 0x60d8 <uip_neighbor_periodic+0x4>
    if(entries[i].time < MAX_TIME) {
      entries[i].time++;
    }
  }
}
    60ec:	08 95       	ret

000060ee <uip_neighbor_update>:
  return NULL;
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_update(uip_ipaddr_t ipaddr)
{
    60ee:	dc 01       	movw	r26, r24
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
    60f0:	6d 91       	ld	r22, X+
    60f2:	7c 91       	ld	r23, X
    60f4:	11 97       	sbiw	r26, 0x01	; 1
    60f6:	e3 e0       	ldi	r30, 0x03	; 3
    60f8:	f4 e0       	ldi	r31, 0x04	; 4
    60fa:	40 e0       	ldi	r20, 0x00	; 0
    60fc:	50 e0       	ldi	r21, 0x00	; 0
    60fe:	80 81       	ld	r24, Z
    6100:	91 81       	ldd	r25, Z+1	; 0x01
    6102:	86 17       	cp	r24, r22
    6104:	97 07       	cpc	r25, r23
    6106:	b1 f4       	brne	.+44     	; 0x6134 <uip_neighbor_update+0x46>
    6108:	22 81       	ldd	r18, Z+2	; 0x02
    610a:	33 81       	ldd	r19, Z+3	; 0x03
    610c:	12 96       	adiw	r26, 0x02	; 2
    610e:	8d 91       	ld	r24, X+
    6110:	9c 91       	ld	r25, X
    6112:	13 97       	sbiw	r26, 0x03	; 3
    6114:	28 17       	cp	r18, r24
    6116:	39 07       	cpc	r19, r25
    6118:	69 f4       	brne	.+26     	; 0x6134 <uip_neighbor_update+0x46>
      return &entries[i];
    611a:	8b e0       	ldi	r24, 0x0B	; 11
    611c:	90 e0       	ldi	r25, 0x00	; 0
    611e:	48 9f       	mul	r20, r24
    6120:	f0 01       	movw	r30, r0
    6122:	49 9f       	mul	r20, r25
    6124:	f0 0d       	add	r31, r0
    6126:	58 9f       	mul	r21, r24
    6128:	f0 0d       	add	r31, r0
    612a:	11 24       	eor	r1, r1
    612c:	ed 5f       	subi	r30, 0xFD	; 253
    612e:	fb 4f       	sbci	r31, 0xFB	; 251
uip_neighbor_update(uip_ipaddr_t ipaddr)
{
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    6130:	41 f4       	brne	.+16     	; 0x6142 <uip_neighbor_update+0x54>
    6132:	08 95       	ret
static struct neighbor_entry *
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    6134:	4f 5f       	subi	r20, 0xFF	; 255
    6136:	5f 4f       	sbci	r21, 0xFF	; 255
    6138:	3b 96       	adiw	r30, 0x0b	; 11
    613a:	48 30       	cpi	r20, 0x08	; 8
    613c:	51 05       	cpc	r21, r1
    613e:	f9 f6       	brne	.-66     	; 0x60fe <uip_neighbor_update+0x10>
    6140:	08 95       	ret
{
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    e->time = 0;
    6142:	12 86       	std	Z+10, r1	; 0x0a
    6144:	08 95       	ret

00006146 <uip_neighbor_lookup>:
  }
}
/*---------------------------------------------------------------------------*/
struct uip_neighbor_addr *
uip_neighbor_lookup(uip_ipaddr_t ipaddr)
{
    6146:	dc 01       	movw	r26, r24
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
    6148:	6d 91       	ld	r22, X+
    614a:	7c 91       	ld	r23, X
    614c:	11 97       	sbiw	r26, 0x01	; 1
    614e:	e3 e0       	ldi	r30, 0x03	; 3
    6150:	f4 e0       	ldi	r31, 0x04	; 4
    6152:	40 e0       	ldi	r20, 0x00	; 0
    6154:	50 e0       	ldi	r21, 0x00	; 0
    6156:	80 81       	ld	r24, Z
    6158:	91 81       	ldd	r25, Z+1	; 0x01
    615a:	86 17       	cp	r24, r22
    615c:	97 07       	cpc	r25, r23
    615e:	b1 f4       	brne	.+44     	; 0x618c <uip_neighbor_lookup+0x46>
    6160:	22 81       	ldd	r18, Z+2	; 0x02
    6162:	33 81       	ldd	r19, Z+3	; 0x03
    6164:	12 96       	adiw	r26, 0x02	; 2
    6166:	8d 91       	ld	r24, X+
    6168:	9c 91       	ld	r25, X
    616a:	13 97       	sbiw	r26, 0x03	; 3
    616c:	28 17       	cp	r18, r24
    616e:	39 07       	cpc	r19, r25
    6170:	69 f4       	brne	.+26     	; 0x618c <uip_neighbor_lookup+0x46>
      return &entries[i];
    6172:	8b e0       	ldi	r24, 0x0B	; 11
    6174:	90 e0       	ldi	r25, 0x00	; 0
    6176:	48 9f       	mul	r20, r24
    6178:	90 01       	movw	r18, r0
    617a:	49 9f       	mul	r20, r25
    617c:	30 0d       	add	r19, r0
    617e:	58 9f       	mul	r21, r24
    6180:	30 0d       	add	r19, r0
    6182:	11 24       	eor	r1, r1
    6184:	2d 5f       	subi	r18, 0xFD	; 253
    6186:	3b 4f       	sbci	r19, 0xFB	; 251
uip_neighbor_lookup(uip_ipaddr_t ipaddr)
{
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    6188:	41 f4       	brne	.+16     	; 0x619a <uip_neighbor_lookup+0x54>
    618a:	0a c0       	rjmp	.+20     	; 0x61a0 <uip_neighbor_lookup+0x5a>
static struct neighbor_entry *
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    618c:	4f 5f       	subi	r20, 0xFF	; 255
    618e:	5f 4f       	sbci	r21, 0xFF	; 255
    6190:	3b 96       	adiw	r30, 0x0b	; 11
    6192:	48 30       	cpi	r20, 0x08	; 8
    6194:	51 05       	cpc	r21, r1
    6196:	f9 f6       	brne	.-66     	; 0x6156 <uip_neighbor_lookup+0x10>
    6198:	03 c0       	rjmp	.+6      	; 0x61a0 <uip_neighbor_lookup+0x5a>
  if(e != NULL) {
    /*    printf("Lookup neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n",
	   e->addr.addr.addr[0], e->addr.addr.addr[1], e->addr.addr.addr[2], e->addr.addr.addr[3],
	   e->addr.addr.addr[4], e->addr.addr.addr[5]);*/

    return &e->addr;
    619a:	2c 5f       	subi	r18, 0xFC	; 252
    619c:	3f 4f       	sbci	r19, 0xFF	; 255
    619e:	02 c0       	rjmp	.+4      	; 0x61a4 <uip_neighbor_lookup+0x5e>
    61a0:	20 e0       	ldi	r18, 0x00	; 0
    61a2:	30 e0       	ldi	r19, 0x00	; 0
  }
  return NULL;
}
    61a4:	c9 01       	movw	r24, r18
    61a6:	08 95       	ret

000061a8 <uip_neighbor_add>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr)
{
    61a8:	ef 92       	push	r14
    61aa:	ff 92       	push	r15
    61ac:	0f 93       	push	r16
    61ae:	1f 93       	push	r17
    61b0:	cf 93       	push	r28
    61b2:	df 93       	push	r29
    61b4:	ec 01       	movw	r28, r24
    61b6:	f6 2e       	mov	r15, r22
    61b8:	e7 2e       	mov	r14, r23
    61ba:	a3 e0       	ldi	r26, 0x03	; 3
    61bc:	b4 e0       	ldi	r27, 0x04	; 4
    61be:	40 e0       	ldi	r20, 0x00	; 0
    61c0:	50 e0       	ldi	r21, 0x00	; 0
    61c2:	60 e0       	ldi	r22, 0x00	; 0
    61c4:	70 e0       	ldi	r23, 0x00	; 0
    61c6:	00 e0       	ldi	r16, 0x00	; 0
  
  /* Find the first unused entry or the oldest used entry. */
  oldest_time = 0;
  oldest = 0;
  for(i = 0; i < ENTRIES; ++i) {
    if(entries[i].time == MAX_TIME) {
    61c8:	1a 96       	adiw	r26, 0x0a	; 10
    61ca:	1c 91       	ld	r17, X
    61cc:	1a 97       	sbiw	r26, 0x0a	; 10
    61ce:	10 38       	cpi	r17, 0x80	; 128
    61d0:	01 f1       	breq	.+64     	; 0x6212 <uip_neighbor_add+0x6a>
      oldest = i;
      break;
    }
    if(uip_ipaddr_cmp(entries[i].ipaddr, addr)) {
    61d2:	ef 2d       	mov	r30, r15
    61d4:	fe 2d       	mov	r31, r14
    61d6:	2d 91       	ld	r18, X+
    61d8:	3c 91       	ld	r19, X
    61da:	11 97       	sbiw	r26, 0x01	; 1
    61dc:	80 81       	ld	r24, Z
    61de:	91 81       	ldd	r25, Z+1	; 0x01
    61e0:	28 17       	cp	r18, r24
    61e2:	39 07       	cpc	r19, r25
    61e4:	49 f4       	brne	.+18     	; 0x61f8 <uip_neighbor_add+0x50>
    61e6:	12 96       	adiw	r26, 0x02	; 2
    61e8:	2d 91       	ld	r18, X+
    61ea:	3c 91       	ld	r19, X
    61ec:	13 97       	sbiw	r26, 0x03	; 3
    61ee:	82 81       	ldd	r24, Z+2	; 0x02
    61f0:	93 81       	ldd	r25, Z+3	; 0x03
    61f2:	28 17       	cp	r18, r24
    61f4:	39 07       	cpc	r19, r25
    61f6:	69 f0       	breq	.+26     	; 0x6212 <uip_neighbor_add+0x6a>
      oldest = i;
      break;
    }
    if(entries[i].time > oldest_time) {
    61f8:	01 17       	cp	r16, r17
    61fa:	10 f0       	brcs	.+4      	; 0x6200 <uip_neighbor_add+0x58>
    61fc:	10 2f       	mov	r17, r16
    61fe:	01 c0       	rjmp	.+2      	; 0x6202 <uip_neighbor_add+0x5a>
    6200:	ba 01       	movw	r22, r20
	 //addr->addr.addr[4], addr->addr.addr[5]);
  
  /* Find the first unused entry or the oldest used entry. */
  oldest_time = 0;
  oldest = 0;
  for(i = 0; i < ENTRIES; ++i) {
    6202:	4f 5f       	subi	r20, 0xFF	; 255
    6204:	5f 4f       	sbci	r21, 0xFF	; 255
    6206:	1b 96       	adiw	r26, 0x0b	; 11
    6208:	48 30       	cpi	r20, 0x08	; 8
    620a:	51 05       	cpc	r21, r1
    620c:	19 f0       	breq	.+6      	; 0x6214 <uip_neighbor_add+0x6c>
    620e:	01 2f       	mov	r16, r17
    6210:	db cf       	rjmp	.-74     	; 0x61c8 <uip_neighbor_add+0x20>
    6212:	ba 01       	movw	r22, r20
    }
  }

  /* Use the oldest or first free entry (either pointed to by the
     "oldest" variable). */
  entries[oldest].time = 0;
    6214:	8b e0       	ldi	r24, 0x0B	; 11
    6216:	90 e0       	ldi	r25, 0x00	; 0
    6218:	68 9f       	mul	r22, r24
    621a:	90 01       	movw	r18, r0
    621c:	69 9f       	mul	r22, r25
    621e:	30 0d       	add	r19, r0
    6220:	78 9f       	mul	r23, r24
    6222:	30 0d       	add	r19, r0
    6224:	11 24       	eor	r1, r1
    6226:	f9 01       	movw	r30, r18
    6228:	ed 5f       	subi	r30, 0xFD	; 253
    622a:	fb 4f       	sbci	r31, 0xFB	; 251
    622c:	12 86       	std	Z+10, r1	; 0x0a
  uip_ipaddr_copy(entries[oldest].ipaddr, ipaddr);
    622e:	88 81       	ld	r24, Y
    6230:	99 81       	ldd	r25, Y+1	; 0x01
    6232:	91 83       	std	Z+1, r25	; 0x01
    6234:	80 83       	st	Z, r24
    6236:	8a 81       	ldd	r24, Y+2	; 0x02
    6238:	9b 81       	ldd	r25, Y+3	; 0x03
    623a:	93 83       	std	Z+3, r25	; 0x03
    623c:	82 83       	std	Z+2, r24	; 0x02
  memcpy(&entries[oldest].addr, addr, sizeof(struct uip_neighbor_addr));
    623e:	d9 01       	movw	r26, r18
    6240:	a9 5f       	subi	r26, 0xF9	; 249
    6242:	bb 4f       	sbci	r27, 0xFB	; 251
    6244:	2f 2d       	mov	r18, r15
    6246:	3e 2d       	mov	r19, r14
    6248:	c9 01       	movw	r24, r18
    624a:	fc 01       	movw	r30, r24
    624c:	86 e0       	ldi	r24, 0x06	; 6
    624e:	01 90       	ld	r0, Z+
    6250:	0d 92       	st	X+, r0
    6252:	81 50       	subi	r24, 0x01	; 1
    6254:	e1 f7       	brne	.-8      	; 0x624e <uip_neighbor_add+0xa6>
}
    6256:	df 91       	pop	r29
    6258:	cf 91       	pop	r28
    625a:	1f 91       	pop	r17
    625c:	0f 91       	pop	r16
    625e:	ff 90       	pop	r15
    6260:	ef 90       	pop	r14
    6262:	08 95       	ret

00006264 <malloc>:
    6264:	cf 93       	push	r28
    6266:	df 93       	push	r29
    6268:	bc 01       	movw	r22, r24
    626a:	82 30       	cpi	r24, 0x02	; 2
    626c:	91 05       	cpc	r25, r1
    626e:	10 f4       	brcc	.+4      	; 0x6274 <malloc+0x10>
    6270:	62 e0       	ldi	r22, 0x02	; 2
    6272:	70 e0       	ldi	r23, 0x00	; 0
    6274:	a0 91 e2 0b 	lds	r26, 0x0BE2
    6278:	b0 91 e3 0b 	lds	r27, 0x0BE3
    627c:	ed 01       	movw	r28, r26
    627e:	e0 e0       	ldi	r30, 0x00	; 0
    6280:	f0 e0       	ldi	r31, 0x00	; 0
    6282:	40 e0       	ldi	r20, 0x00	; 0
    6284:	50 e0       	ldi	r21, 0x00	; 0
    6286:	21 c0       	rjmp	.+66     	; 0x62ca <malloc+0x66>
    6288:	88 81       	ld	r24, Y
    628a:	99 81       	ldd	r25, Y+1	; 0x01
    628c:	86 17       	cp	r24, r22
    628e:	97 07       	cpc	r25, r23
    6290:	69 f4       	brne	.+26     	; 0x62ac <malloc+0x48>
    6292:	8a 81       	ldd	r24, Y+2	; 0x02
    6294:	9b 81       	ldd	r25, Y+3	; 0x03
    6296:	30 97       	sbiw	r30, 0x00	; 0
    6298:	19 f0       	breq	.+6      	; 0x62a0 <malloc+0x3c>
    629a:	93 83       	std	Z+3, r25	; 0x03
    629c:	82 83       	std	Z+2, r24	; 0x02
    629e:	04 c0       	rjmp	.+8      	; 0x62a8 <malloc+0x44>
    62a0:	90 93 e3 0b 	sts	0x0BE3, r25
    62a4:	80 93 e2 0b 	sts	0x0BE2, r24
    62a8:	fe 01       	movw	r30, r28
    62aa:	34 c0       	rjmp	.+104    	; 0x6314 <malloc+0xb0>
    62ac:	68 17       	cp	r22, r24
    62ae:	79 07       	cpc	r23, r25
    62b0:	38 f4       	brcc	.+14     	; 0x62c0 <malloc+0x5c>
    62b2:	41 15       	cp	r20, r1
    62b4:	51 05       	cpc	r21, r1
    62b6:	19 f0       	breq	.+6      	; 0x62be <malloc+0x5a>
    62b8:	84 17       	cp	r24, r20
    62ba:	95 07       	cpc	r25, r21
    62bc:	08 f4       	brcc	.+2      	; 0x62c0 <malloc+0x5c>
    62be:	ac 01       	movw	r20, r24
    62c0:	fe 01       	movw	r30, r28
    62c2:	8a 81       	ldd	r24, Y+2	; 0x02
    62c4:	9b 81       	ldd	r25, Y+3	; 0x03
    62c6:	9c 01       	movw	r18, r24
    62c8:	e9 01       	movw	r28, r18
    62ca:	20 97       	sbiw	r28, 0x00	; 0
    62cc:	e9 f6       	brne	.-70     	; 0x6288 <malloc+0x24>
    62ce:	41 15       	cp	r20, r1
    62d0:	51 05       	cpc	r21, r1
    62d2:	a9 f1       	breq	.+106    	; 0x633e <malloc+0xda>
    62d4:	ca 01       	movw	r24, r20
    62d6:	86 1b       	sub	r24, r22
    62d8:	97 0b       	sbc	r25, r23
    62da:	04 97       	sbiw	r24, 0x04	; 4
    62dc:	08 f4       	brcc	.+2      	; 0x62e0 <malloc+0x7c>
    62de:	ba 01       	movw	r22, r20
    62e0:	e0 e0       	ldi	r30, 0x00	; 0
    62e2:	f0 e0       	ldi	r31, 0x00	; 0
    62e4:	2a c0       	rjmp	.+84     	; 0x633a <malloc+0xd6>
    62e6:	8d 91       	ld	r24, X+
    62e8:	9c 91       	ld	r25, X
    62ea:	11 97       	sbiw	r26, 0x01	; 1
    62ec:	84 17       	cp	r24, r20
    62ee:	95 07       	cpc	r25, r21
    62f0:	f9 f4       	brne	.+62     	; 0x6330 <malloc+0xcc>
    62f2:	64 17       	cp	r22, r20
    62f4:	75 07       	cpc	r23, r21
    62f6:	81 f4       	brne	.+32     	; 0x6318 <malloc+0xb4>
    62f8:	12 96       	adiw	r26, 0x02	; 2
    62fa:	8d 91       	ld	r24, X+
    62fc:	9c 91       	ld	r25, X
    62fe:	13 97       	sbiw	r26, 0x03	; 3
    6300:	30 97       	sbiw	r30, 0x00	; 0
    6302:	19 f0       	breq	.+6      	; 0x630a <malloc+0xa6>
    6304:	93 83       	std	Z+3, r25	; 0x03
    6306:	82 83       	std	Z+2, r24	; 0x02
    6308:	04 c0       	rjmp	.+8      	; 0x6312 <malloc+0xae>
    630a:	90 93 e3 0b 	sts	0x0BE3, r25
    630e:	80 93 e2 0b 	sts	0x0BE2, r24
    6312:	fd 01       	movw	r30, r26
    6314:	32 96       	adiw	r30, 0x02	; 2
    6316:	4c c0       	rjmp	.+152    	; 0x63b0 <malloc+0x14c>
    6318:	ca 01       	movw	r24, r20
    631a:	86 1b       	sub	r24, r22
    631c:	97 0b       	sbc	r25, r23
    631e:	fd 01       	movw	r30, r26
    6320:	e8 0f       	add	r30, r24
    6322:	f9 1f       	adc	r31, r25
    6324:	61 93       	st	Z+, r22
    6326:	71 93       	st	Z+, r23
    6328:	02 97       	sbiw	r24, 0x02	; 2
    632a:	8d 93       	st	X+, r24
    632c:	9c 93       	st	X, r25
    632e:	40 c0       	rjmp	.+128    	; 0x63b0 <malloc+0x14c>
    6330:	fd 01       	movw	r30, r26
    6332:	82 81       	ldd	r24, Z+2	; 0x02
    6334:	93 81       	ldd	r25, Z+3	; 0x03
    6336:	9c 01       	movw	r18, r24
    6338:	d9 01       	movw	r26, r18
    633a:	10 97       	sbiw	r26, 0x00	; 0
    633c:	a1 f6       	brne	.-88     	; 0x62e6 <malloc+0x82>
    633e:	80 91 e0 0b 	lds	r24, 0x0BE0
    6342:	90 91 e1 0b 	lds	r25, 0x0BE1
    6346:	89 2b       	or	r24, r25
    6348:	41 f4       	brne	.+16     	; 0x635a <malloc+0xf6>
    634a:	80 91 9e 03 	lds	r24, 0x039E
    634e:	90 91 9f 03 	lds	r25, 0x039F
    6352:	90 93 e1 0b 	sts	0x0BE1, r25
    6356:	80 93 e0 0b 	sts	0x0BE0, r24
    635a:	40 91 a0 03 	lds	r20, 0x03A0
    635e:	50 91 a1 03 	lds	r21, 0x03A1
    6362:	41 15       	cp	r20, r1
    6364:	51 05       	cpc	r21, r1
    6366:	41 f4       	brne	.+16     	; 0x6378 <malloc+0x114>
    6368:	4d b7       	in	r20, 0x3d	; 61
    636a:	5e b7       	in	r21, 0x3e	; 62
    636c:	80 91 9c 03 	lds	r24, 0x039C
    6370:	90 91 9d 03 	lds	r25, 0x039D
    6374:	48 1b       	sub	r20, r24
    6376:	59 0b       	sbc	r21, r25
    6378:	20 91 e0 0b 	lds	r18, 0x0BE0
    637c:	30 91 e1 0b 	lds	r19, 0x0BE1
    6380:	ca 01       	movw	r24, r20
    6382:	82 1b       	sub	r24, r18
    6384:	93 0b       	sbc	r25, r19
    6386:	86 17       	cp	r24, r22
    6388:	97 07       	cpc	r25, r23
    638a:	80 f0       	brcs	.+32     	; 0x63ac <malloc+0x148>
    638c:	ab 01       	movw	r20, r22
    638e:	4e 5f       	subi	r20, 0xFE	; 254
    6390:	5f 4f       	sbci	r21, 0xFF	; 255
    6392:	84 17       	cp	r24, r20
    6394:	95 07       	cpc	r25, r21
    6396:	50 f0       	brcs	.+20     	; 0x63ac <malloc+0x148>
    6398:	42 0f       	add	r20, r18
    639a:	53 1f       	adc	r21, r19
    639c:	50 93 e1 0b 	sts	0x0BE1, r21
    63a0:	40 93 e0 0b 	sts	0x0BE0, r20
    63a4:	f9 01       	movw	r30, r18
    63a6:	61 93       	st	Z+, r22
    63a8:	71 93       	st	Z+, r23
    63aa:	02 c0       	rjmp	.+4      	; 0x63b0 <malloc+0x14c>
    63ac:	e0 e0       	ldi	r30, 0x00	; 0
    63ae:	f0 e0       	ldi	r31, 0x00	; 0
    63b0:	cf 01       	movw	r24, r30
    63b2:	df 91       	pop	r29
    63b4:	cf 91       	pop	r28
    63b6:	08 95       	ret

000063b8 <free>:
    63b8:	cf 93       	push	r28
    63ba:	df 93       	push	r29
    63bc:	00 97       	sbiw	r24, 0x00	; 0
    63be:	09 f4       	brne	.+2      	; 0x63c2 <free+0xa>
    63c0:	50 c0       	rjmp	.+160    	; 0x6462 <free+0xaa>
    63c2:	ec 01       	movw	r28, r24
    63c4:	22 97       	sbiw	r28, 0x02	; 2
    63c6:	1b 82       	std	Y+3, r1	; 0x03
    63c8:	1a 82       	std	Y+2, r1	; 0x02
    63ca:	a0 91 e2 0b 	lds	r26, 0x0BE2
    63ce:	b0 91 e3 0b 	lds	r27, 0x0BE3
    63d2:	10 97       	sbiw	r26, 0x00	; 0
    63d4:	09 f1       	breq	.+66     	; 0x6418 <free+0x60>
    63d6:	40 e0       	ldi	r20, 0x00	; 0
    63d8:	50 e0       	ldi	r21, 0x00	; 0
    63da:	ac 17       	cp	r26, r28
    63dc:	bd 07       	cpc	r27, r29
    63de:	08 f1       	brcs	.+66     	; 0x6422 <free+0x6a>
    63e0:	bb 83       	std	Y+3, r27	; 0x03
    63e2:	aa 83       	std	Y+2, r26	; 0x02
    63e4:	fe 01       	movw	r30, r28
    63e6:	21 91       	ld	r18, Z+
    63e8:	31 91       	ld	r19, Z+
    63ea:	e2 0f       	add	r30, r18
    63ec:	f3 1f       	adc	r31, r19
    63ee:	ae 17       	cp	r26, r30
    63f0:	bf 07       	cpc	r27, r31
    63f2:	79 f4       	brne	.+30     	; 0x6412 <free+0x5a>
    63f4:	8d 91       	ld	r24, X+
    63f6:	9c 91       	ld	r25, X
    63f8:	11 97       	sbiw	r26, 0x01	; 1
    63fa:	28 0f       	add	r18, r24
    63fc:	39 1f       	adc	r19, r25
    63fe:	2e 5f       	subi	r18, 0xFE	; 254
    6400:	3f 4f       	sbci	r19, 0xFF	; 255
    6402:	39 83       	std	Y+1, r19	; 0x01
    6404:	28 83       	st	Y, r18
    6406:	12 96       	adiw	r26, 0x02	; 2
    6408:	8d 91       	ld	r24, X+
    640a:	9c 91       	ld	r25, X
    640c:	13 97       	sbiw	r26, 0x03	; 3
    640e:	9b 83       	std	Y+3, r25	; 0x03
    6410:	8a 83       	std	Y+2, r24	; 0x02
    6412:	41 15       	cp	r20, r1
    6414:	51 05       	cpc	r21, r1
    6416:	71 f4       	brne	.+28     	; 0x6434 <free+0x7c>
    6418:	d0 93 e3 0b 	sts	0x0BE3, r29
    641c:	c0 93 e2 0b 	sts	0x0BE2, r28
    6420:	20 c0       	rjmp	.+64     	; 0x6462 <free+0xaa>
    6422:	12 96       	adiw	r26, 0x02	; 2
    6424:	8d 91       	ld	r24, X+
    6426:	9c 91       	ld	r25, X
    6428:	13 97       	sbiw	r26, 0x03	; 3
    642a:	ad 01       	movw	r20, r26
    642c:	00 97       	sbiw	r24, 0x00	; 0
    642e:	11 f0       	breq	.+4      	; 0x6434 <free+0x7c>
    6430:	dc 01       	movw	r26, r24
    6432:	d3 cf       	rjmp	.-90     	; 0x63da <free+0x22>
    6434:	fa 01       	movw	r30, r20
    6436:	d3 83       	std	Z+3, r29	; 0x03
    6438:	c2 83       	std	Z+2, r28	; 0x02
    643a:	21 91       	ld	r18, Z+
    643c:	31 91       	ld	r19, Z+
    643e:	e2 0f       	add	r30, r18
    6440:	f3 1f       	adc	r31, r19
    6442:	ce 17       	cp	r28, r30
    6444:	df 07       	cpc	r29, r31
    6446:	69 f4       	brne	.+26     	; 0x6462 <free+0xaa>
    6448:	88 81       	ld	r24, Y
    644a:	99 81       	ldd	r25, Y+1	; 0x01
    644c:	28 0f       	add	r18, r24
    644e:	39 1f       	adc	r19, r25
    6450:	2e 5f       	subi	r18, 0xFE	; 254
    6452:	3f 4f       	sbci	r19, 0xFF	; 255
    6454:	fa 01       	movw	r30, r20
    6456:	31 83       	std	Z+1, r19	; 0x01
    6458:	20 83       	st	Z, r18
    645a:	8a 81       	ldd	r24, Y+2	; 0x02
    645c:	9b 81       	ldd	r25, Y+3	; 0x03
    645e:	93 83       	std	Z+3, r25	; 0x03
    6460:	82 83       	std	Z+2, r24	; 0x02
    6462:	df 91       	pop	r29
    6464:	cf 91       	pop	r28
    6466:	08 95       	ret

00006468 <atoi>:
    6468:	fc 01       	movw	r30, r24
    646a:	88 27       	eor	r24, r24
    646c:	99 27       	eor	r25, r25
    646e:	e8 94       	clt
    6470:	21 91       	ld	r18, Z+
    6472:	20 32       	cpi	r18, 0x20	; 32
    6474:	e9 f3       	breq	.-6      	; 0x6470 <atoi+0x8>
    6476:	29 30       	cpi	r18, 0x09	; 9
    6478:	10 f0       	brcs	.+4      	; 0x647e <atoi+0x16>
    647a:	2e 30       	cpi	r18, 0x0E	; 14
    647c:	c8 f3       	brcs	.-14     	; 0x6470 <atoi+0x8>
    647e:	2b 32       	cpi	r18, 0x2B	; 43
    6480:	41 f0       	breq	.+16     	; 0x6492 <atoi+0x2a>
    6482:	2d 32       	cpi	r18, 0x2D	; 45
    6484:	39 f4       	brne	.+14     	; 0x6494 <atoi+0x2c>
    6486:	68 94       	set
    6488:	04 c0       	rjmp	.+8      	; 0x6492 <atoi+0x2a>
    648a:	0e 94 0a 33 	call	0x6614	; 0x6614 <__mulhi_const_10>
    648e:	82 0f       	add	r24, r18
    6490:	91 1d       	adc	r25, r1
    6492:	21 91       	ld	r18, Z+
    6494:	20 53       	subi	r18, 0x30	; 48
    6496:	2a 30       	cpi	r18, 0x0A	; 10
    6498:	c0 f3       	brcs	.-16     	; 0x648a <atoi+0x22>
    649a:	1e f4       	brtc	.+6      	; 0x64a2 <atoi+0x3a>
    649c:	90 95       	com	r25
    649e:	81 95       	neg	r24
    64a0:	9f 4f       	sbci	r25, 0xFF	; 255
    64a2:	08 95       	ret

000064a4 <memcpy_P>:
    64a4:	fb 01       	movw	r30, r22
    64a6:	dc 01       	movw	r26, r24
    64a8:	02 c0       	rjmp	.+4      	; 0x64ae <memcpy_P+0xa>
    64aa:	05 90       	lpm	r0, Z+
    64ac:	0d 92       	st	X+, r0
    64ae:	41 50       	subi	r20, 0x01	; 1
    64b0:	50 40       	sbci	r21, 0x00	; 0
    64b2:	d8 f7       	brcc	.-10     	; 0x64aa <memcpy_P+0x6>
    64b4:	08 95       	ret

000064b6 <strchr_P>:
    64b6:	fc 01       	movw	r30, r24
    64b8:	05 90       	lpm	r0, Z+
    64ba:	06 16       	cp	r0, r22
    64bc:	21 f0       	breq	.+8      	; 0x64c6 <strchr_P+0x10>
    64be:	00 20       	and	r0, r0
    64c0:	d9 f7       	brne	.-10     	; 0x64b8 <strchr_P+0x2>
    64c2:	c0 01       	movw	r24, r0
    64c4:	08 95       	ret
    64c6:	31 97       	sbiw	r30, 0x01	; 1
    64c8:	cf 01       	movw	r24, r30
    64ca:	08 95       	ret

000064cc <strcmp_P>:
    64cc:	fb 01       	movw	r30, r22
    64ce:	dc 01       	movw	r26, r24
    64d0:	8d 91       	ld	r24, X+
    64d2:	05 90       	lpm	r0, Z+
    64d4:	80 19       	sub	r24, r0
    64d6:	01 10       	cpse	r0, r1
    64d8:	d9 f3       	breq	.-10     	; 0x64d0 <strcmp_P+0x4>
    64da:	99 0b       	sbc	r25, r25
    64dc:	08 95       	ret

000064de <strcpy_P>:
    64de:	fb 01       	movw	r30, r22
    64e0:	dc 01       	movw	r26, r24
    64e2:	05 90       	lpm	r0, Z+
    64e4:	0d 92       	st	X+, r0
    64e6:	00 20       	and	r0, r0
    64e8:	e1 f7       	brne	.-8      	; 0x64e2 <strcpy_P+0x4>
    64ea:	08 95       	ret

000064ec <strlen_P>:
    64ec:	fc 01       	movw	r30, r24
    64ee:	05 90       	lpm	r0, Z+
    64f0:	00 20       	and	r0, r0
    64f2:	e9 f7       	brne	.-6      	; 0x64ee <strlen_P+0x2>
    64f4:	80 95       	com	r24
    64f6:	90 95       	com	r25
    64f8:	8e 0f       	add	r24, r30
    64fa:	9f 1f       	adc	r25, r31
    64fc:	08 95       	ret

000064fe <strncmp_P>:
    64fe:	fb 01       	movw	r30, r22
    6500:	dc 01       	movw	r26, r24
    6502:	41 50       	subi	r20, 0x01	; 1
    6504:	50 40       	sbci	r21, 0x00	; 0
    6506:	30 f0       	brcs	.+12     	; 0x6514 <strncmp_P+0x16>
    6508:	8d 91       	ld	r24, X+
    650a:	05 90       	lpm	r0, Z+
    650c:	80 19       	sub	r24, r0
    650e:	19 f4       	brne	.+6      	; 0x6516 <strncmp_P+0x18>
    6510:	00 20       	and	r0, r0
    6512:	b9 f7       	brne	.-18     	; 0x6502 <strncmp_P+0x4>
    6514:	88 1b       	sub	r24, r24
    6516:	99 0b       	sbc	r25, r25
    6518:	08 95       	ret

0000651a <strncpy_P>:
    651a:	fb 01       	movw	r30, r22
    651c:	dc 01       	movw	r26, r24
    651e:	41 50       	subi	r20, 0x01	; 1
    6520:	50 40       	sbci	r21, 0x00	; 0
    6522:	48 f0       	brcs	.+18     	; 0x6536 <strncpy_P+0x1c>
    6524:	05 90       	lpm	r0, Z+
    6526:	0d 92       	st	X+, r0
    6528:	00 20       	and	r0, r0
    652a:	c9 f7       	brne	.-14     	; 0x651e <strncpy_P+0x4>
    652c:	01 c0       	rjmp	.+2      	; 0x6530 <strncpy_P+0x16>
    652e:	1d 92       	st	X+, r1
    6530:	41 50       	subi	r20, 0x01	; 1
    6532:	50 40       	sbci	r21, 0x00	; 0
    6534:	e0 f7       	brcc	.-8      	; 0x652e <strncpy_P+0x14>
    6536:	08 95       	ret

00006538 <memcpy>:
    6538:	fb 01       	movw	r30, r22
    653a:	dc 01       	movw	r26, r24
    653c:	02 c0       	rjmp	.+4      	; 0x6542 <memcpy+0xa>
    653e:	01 90       	ld	r0, Z+
    6540:	0d 92       	st	X+, r0
    6542:	41 50       	subi	r20, 0x01	; 1
    6544:	50 40       	sbci	r21, 0x00	; 0
    6546:	d8 f7       	brcc	.-10     	; 0x653e <memcpy+0x6>
    6548:	08 95       	ret

0000654a <memset>:
    654a:	dc 01       	movw	r26, r24
    654c:	01 c0       	rjmp	.+2      	; 0x6550 <memset+0x6>
    654e:	6d 93       	st	X+, r22
    6550:	41 50       	subi	r20, 0x01	; 1
    6552:	50 40       	sbci	r21, 0x00	; 0
    6554:	e0 f7       	brcc	.-8      	; 0x654e <memset+0x4>
    6556:	08 95       	ret

00006558 <strchr>:
    6558:	fc 01       	movw	r30, r24
    655a:	81 91       	ld	r24, Z+
    655c:	86 17       	cp	r24, r22
    655e:	21 f0       	breq	.+8      	; 0x6568 <strchr+0x10>
    6560:	88 23       	and	r24, r24
    6562:	d9 f7       	brne	.-10     	; 0x655a <strchr+0x2>
    6564:	99 27       	eor	r25, r25
    6566:	08 95       	ret
    6568:	31 97       	sbiw	r30, 0x01	; 1
    656a:	cf 01       	movw	r24, r30
    656c:	08 95       	ret

0000656e <strncmp>:
    656e:	fb 01       	movw	r30, r22
    6570:	dc 01       	movw	r26, r24
    6572:	41 50       	subi	r20, 0x01	; 1
    6574:	50 40       	sbci	r21, 0x00	; 0
    6576:	30 f0       	brcs	.+12     	; 0x6584 <strncmp+0x16>
    6578:	8d 91       	ld	r24, X+
    657a:	01 90       	ld	r0, Z+
    657c:	80 19       	sub	r24, r0
    657e:	19 f4       	brne	.+6      	; 0x6586 <strncmp+0x18>
    6580:	00 20       	and	r0, r0
    6582:	b9 f7       	brne	.-18     	; 0x6572 <strncmp+0x4>
    6584:	88 1b       	sub	r24, r24
    6586:	99 0b       	sbc	r25, r25
    6588:	08 95       	ret

0000658a <strncpy>:
    658a:	fb 01       	movw	r30, r22
    658c:	dc 01       	movw	r26, r24
    658e:	41 50       	subi	r20, 0x01	; 1
    6590:	50 40       	sbci	r21, 0x00	; 0
    6592:	48 f0       	brcs	.+18     	; 0x65a6 <strncpy+0x1c>
    6594:	01 90       	ld	r0, Z+
    6596:	0d 92       	st	X+, r0
    6598:	00 20       	and	r0, r0
    659a:	c9 f7       	brne	.-14     	; 0x658e <strncpy+0x4>
    659c:	01 c0       	rjmp	.+2      	; 0x65a0 <strncpy+0x16>
    659e:	1d 92       	st	X+, r1
    65a0:	41 50       	subi	r20, 0x01	; 1
    65a2:	50 40       	sbci	r21, 0x00	; 0
    65a4:	e0 f7       	brcc	.-8      	; 0x659e <strncpy+0x14>
    65a6:	08 95       	ret

000065a8 <strrchr>:
    65a8:	fc 01       	movw	r30, r24
    65aa:	81 e0       	ldi	r24, 0x01	; 1
    65ac:	90 e0       	ldi	r25, 0x00	; 0
    65ae:	01 90       	ld	r0, Z+
    65b0:	06 16       	cp	r0, r22
    65b2:	09 f4       	brne	.+2      	; 0x65b6 <strrchr+0xe>
    65b4:	cf 01       	movw	r24, r30
    65b6:	00 20       	and	r0, r0
    65b8:	d1 f7       	brne	.-12     	; 0x65ae <strrchr+0x6>
    65ba:	01 97       	sbiw	r24, 0x01	; 1
    65bc:	08 95       	ret

000065be <strupr>:
    65be:	dc 01       	movw	r26, r24
    65c0:	6c 91       	ld	r22, X
    65c2:	61 56       	subi	r22, 0x61	; 97
    65c4:	6a 31       	cpi	r22, 0x1A	; 26
    65c6:	08 f0       	brcs	.+2      	; 0x65ca <strupr+0xc>
    65c8:	60 5e       	subi	r22, 0xE0	; 224
    65ca:	6f 5b       	subi	r22, 0xBF	; 191
    65cc:	6d 93       	st	X+, r22
    65ce:	c1 f7       	brne	.-16     	; 0x65c0 <strupr+0x2>
    65d0:	08 95       	ret

000065d2 <itoa>:
    65d2:	fb 01       	movw	r30, r22
    65d4:	9f 01       	movw	r18, r30
    65d6:	e8 94       	clt
    65d8:	42 30       	cpi	r20, 0x02	; 2
    65da:	c4 f0       	brlt	.+48     	; 0x660c <itoa+0x3a>
    65dc:	45 32       	cpi	r20, 0x25	; 37
    65de:	b4 f4       	brge	.+44     	; 0x660c <itoa+0x3a>
    65e0:	4a 30       	cpi	r20, 0x0A	; 10
    65e2:	29 f4       	brne	.+10     	; 0x65ee <itoa+0x1c>
    65e4:	97 fb       	bst	r25, 7
    65e6:	1e f4       	brtc	.+6      	; 0x65ee <itoa+0x1c>
    65e8:	90 95       	com	r25
    65ea:	81 95       	neg	r24
    65ec:	9f 4f       	sbci	r25, 0xFF	; 255
    65ee:	64 2f       	mov	r22, r20
    65f0:	77 27       	eor	r23, r23
    65f2:	0e 94 d1 35 	call	0x6ba2	; 0x6ba2 <__udivmodhi4>
    65f6:	80 5d       	subi	r24, 0xD0	; 208
    65f8:	8a 33       	cpi	r24, 0x3A	; 58
    65fa:	0c f0       	brlt	.+2      	; 0x65fe <itoa+0x2c>
    65fc:	89 5d       	subi	r24, 0xD9	; 217
    65fe:	81 93       	st	Z+, r24
    6600:	cb 01       	movw	r24, r22
    6602:	00 97       	sbiw	r24, 0x00	; 0
    6604:	a1 f7       	brne	.-24     	; 0x65ee <itoa+0x1c>
    6606:	16 f4       	brtc	.+4      	; 0x660c <itoa+0x3a>
    6608:	5d e2       	ldi	r21, 0x2D	; 45
    660a:	51 93       	st	Z+, r21
    660c:	10 82       	st	Z, r1
    660e:	c9 01       	movw	r24, r18
    6610:	0c 94 37 35 	jmp	0x6a6e	; 0x6a6e <strrev>

00006614 <__mulhi_const_10>:
    6614:	7a e0       	ldi	r23, 0x0A	; 10
    6616:	97 9f       	mul	r25, r23
    6618:	90 2d       	mov	r25, r0
    661a:	87 9f       	mul	r24, r23
    661c:	80 2d       	mov	r24, r0
    661e:	91 0d       	add	r25, r1
    6620:	11 24       	eor	r1, r1
    6622:	08 95       	ret

00006624 <snprintf>:
    6624:	ae e0       	ldi	r26, 0x0E	; 14
    6626:	b0 e0       	ldi	r27, 0x00	; 0
    6628:	e8 e1       	ldi	r30, 0x18	; 24
    662a:	f3 e3       	ldi	r31, 0x33	; 51
    662c:	0c 94 f3 35 	jmp	0x6be6	; 0x6be6 <__prologue_saves__+0x1c>
    6630:	0d 89       	ldd	r16, Y+21	; 0x15
    6632:	1e 89       	ldd	r17, Y+22	; 0x16
    6634:	8f 89       	ldd	r24, Y+23	; 0x17
    6636:	98 8d       	ldd	r25, Y+24	; 0x18
    6638:	97 ff       	sbrs	r25, 7
    663a:	02 c0       	rjmp	.+4      	; 0x6640 <snprintf+0x1c>
    663c:	80 e0       	ldi	r24, 0x00	; 0
    663e:	90 e8       	ldi	r25, 0x80	; 128
    6640:	01 97       	sbiw	r24, 0x01	; 1
    6642:	9e 83       	std	Y+6, r25	; 0x06
    6644:	8d 83       	std	Y+5, r24	; 0x05
    6646:	1a 83       	std	Y+2, r17	; 0x02
    6648:	09 83       	std	Y+1, r16	; 0x01
    664a:	86 e0       	ldi	r24, 0x06	; 6
    664c:	8c 83       	std	Y+4, r24	; 0x04
    664e:	ce 01       	movw	r24, r28
    6650:	4b 96       	adiw	r24, 0x1b	; 27
    6652:	ac 01       	movw	r20, r24
    6654:	69 8d       	ldd	r22, Y+25	; 0x19
    6656:	7a 8d       	ldd	r23, Y+26	; 0x1a
    6658:	ce 01       	movw	r24, r28
    665a:	01 96       	adiw	r24, 0x01	; 1
    665c:	0e 94 42 33 	call	0x6684	; 0x6684 <vfprintf>
    6660:	4d 81       	ldd	r20, Y+5	; 0x05
    6662:	5e 81       	ldd	r21, Y+6	; 0x06
    6664:	57 fd       	sbrc	r21, 7
    6666:	0a c0       	rjmp	.+20     	; 0x667c <snprintf+0x58>
    6668:	2f 81       	ldd	r18, Y+7	; 0x07
    666a:	38 85       	ldd	r19, Y+8	; 0x08
    666c:	42 17       	cp	r20, r18
    666e:	53 07       	cpc	r21, r19
    6670:	0c f4       	brge	.+2      	; 0x6674 <snprintf+0x50>
    6672:	9a 01       	movw	r18, r20
    6674:	02 0f       	add	r16, r18
    6676:	13 1f       	adc	r17, r19
    6678:	f8 01       	movw	r30, r16
    667a:	10 82       	st	Z, r1
    667c:	2e 96       	adiw	r28, 0x0e	; 14
    667e:	e4 e0       	ldi	r30, 0x04	; 4
    6680:	0c 94 0f 36 	jmp	0x6c1e	; 0x6c1e <__epilogue_restores__+0x1c>

00006684 <vfprintf>:
    6684:	ab e0       	ldi	r26, 0x0B	; 11
    6686:	b0 e0       	ldi	r27, 0x00	; 0
    6688:	e8 e4       	ldi	r30, 0x48	; 72
    668a:	f3 e3       	ldi	r31, 0x33	; 51
    668c:	0c 94 e5 35 	jmp	0x6bca	; 0x6bca <__prologue_saves__>
    6690:	3c 01       	movw	r6, r24
    6692:	2b 01       	movw	r4, r22
    6694:	5a 01       	movw	r10, r20
    6696:	fc 01       	movw	r30, r24
    6698:	17 82       	std	Z+7, r1	; 0x07
    669a:	16 82       	std	Z+6, r1	; 0x06
    669c:	83 81       	ldd	r24, Z+3	; 0x03
    669e:	81 fd       	sbrc	r24, 1
    66a0:	03 c0       	rjmp	.+6      	; 0x66a8 <vfprintf+0x24>
    66a2:	6f ef       	ldi	r22, 0xFF	; 255
    66a4:	7f ef       	ldi	r23, 0xFF	; 255
    66a6:	c8 c1       	rjmp	.+912    	; 0x6a38 <vfprintf+0x3b4>
    66a8:	9a e0       	ldi	r25, 0x0A	; 10
    66aa:	89 2e       	mov	r8, r25
    66ac:	1e 01       	movw	r2, r28
    66ae:	08 94       	sec
    66b0:	21 1c       	adc	r2, r1
    66b2:	31 1c       	adc	r3, r1
    66b4:	f3 01       	movw	r30, r6
    66b6:	23 81       	ldd	r18, Z+3	; 0x03
    66b8:	f2 01       	movw	r30, r4
    66ba:	23 fd       	sbrc	r18, 3
    66bc:	85 91       	lpm	r24, Z+
    66be:	23 ff       	sbrs	r18, 3
    66c0:	81 91       	ld	r24, Z+
    66c2:	2f 01       	movw	r4, r30
    66c4:	88 23       	and	r24, r24
    66c6:	09 f4       	brne	.+2      	; 0x66ca <vfprintf+0x46>
    66c8:	b4 c1       	rjmp	.+872    	; 0x6a32 <vfprintf+0x3ae>
    66ca:	85 32       	cpi	r24, 0x25	; 37
    66cc:	39 f4       	brne	.+14     	; 0x66dc <vfprintf+0x58>
    66ce:	23 fd       	sbrc	r18, 3
    66d0:	85 91       	lpm	r24, Z+
    66d2:	23 ff       	sbrs	r18, 3
    66d4:	81 91       	ld	r24, Z+
    66d6:	2f 01       	movw	r4, r30
    66d8:	85 32       	cpi	r24, 0x25	; 37
    66da:	29 f4       	brne	.+10     	; 0x66e6 <vfprintf+0x62>
    66dc:	b3 01       	movw	r22, r6
    66de:	90 e0       	ldi	r25, 0x00	; 0
    66e0:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    66e4:	e7 cf       	rjmp	.-50     	; 0x66b4 <vfprintf+0x30>
    66e6:	98 2f       	mov	r25, r24
    66e8:	dd 24       	eor	r13, r13
    66ea:	cc 24       	eor	r12, r12
    66ec:	99 24       	eor	r9, r9
    66ee:	ff e1       	ldi	r31, 0x1F	; 31
    66f0:	fd 15       	cp	r31, r13
    66f2:	d0 f0       	brcs	.+52     	; 0x6728 <vfprintf+0xa4>
    66f4:	9b 32       	cpi	r25, 0x2B	; 43
    66f6:	69 f0       	breq	.+26     	; 0x6712 <vfprintf+0x8e>
    66f8:	9c 32       	cpi	r25, 0x2C	; 44
    66fa:	28 f4       	brcc	.+10     	; 0x6706 <vfprintf+0x82>
    66fc:	90 32       	cpi	r25, 0x20	; 32
    66fe:	59 f0       	breq	.+22     	; 0x6716 <vfprintf+0x92>
    6700:	93 32       	cpi	r25, 0x23	; 35
    6702:	91 f4       	brne	.+36     	; 0x6728 <vfprintf+0xa4>
    6704:	0e c0       	rjmp	.+28     	; 0x6722 <vfprintf+0x9e>
    6706:	9d 32       	cpi	r25, 0x2D	; 45
    6708:	49 f0       	breq	.+18     	; 0x671c <vfprintf+0x98>
    670a:	90 33       	cpi	r25, 0x30	; 48
    670c:	69 f4       	brne	.+26     	; 0x6728 <vfprintf+0xa4>
    670e:	41 e0       	ldi	r20, 0x01	; 1
    6710:	24 c0       	rjmp	.+72     	; 0x675a <vfprintf+0xd6>
    6712:	52 e0       	ldi	r21, 0x02	; 2
    6714:	d5 2a       	or	r13, r21
    6716:	84 e0       	ldi	r24, 0x04	; 4
    6718:	d8 2a       	or	r13, r24
    671a:	28 c0       	rjmp	.+80     	; 0x676c <vfprintf+0xe8>
    671c:	98 e0       	ldi	r25, 0x08	; 8
    671e:	d9 2a       	or	r13, r25
    6720:	25 c0       	rjmp	.+74     	; 0x676c <vfprintf+0xe8>
    6722:	e0 e1       	ldi	r30, 0x10	; 16
    6724:	de 2a       	or	r13, r30
    6726:	22 c0       	rjmp	.+68     	; 0x676c <vfprintf+0xe8>
    6728:	d7 fc       	sbrc	r13, 7
    672a:	29 c0       	rjmp	.+82     	; 0x677e <vfprintf+0xfa>
    672c:	89 2f       	mov	r24, r25
    672e:	80 53       	subi	r24, 0x30	; 48
    6730:	8a 30       	cpi	r24, 0x0A	; 10
    6732:	70 f4       	brcc	.+28     	; 0x6750 <vfprintf+0xcc>
    6734:	d6 fe       	sbrs	r13, 6
    6736:	05 c0       	rjmp	.+10     	; 0x6742 <vfprintf+0xbe>
    6738:	98 9c       	mul	r9, r8
    673a:	90 2c       	mov	r9, r0
    673c:	11 24       	eor	r1, r1
    673e:	98 0e       	add	r9, r24
    6740:	15 c0       	rjmp	.+42     	; 0x676c <vfprintf+0xe8>
    6742:	c8 9c       	mul	r12, r8
    6744:	c0 2c       	mov	r12, r0
    6746:	11 24       	eor	r1, r1
    6748:	c8 0e       	add	r12, r24
    674a:	f0 e2       	ldi	r31, 0x20	; 32
    674c:	df 2a       	or	r13, r31
    674e:	0e c0       	rjmp	.+28     	; 0x676c <vfprintf+0xe8>
    6750:	9e 32       	cpi	r25, 0x2E	; 46
    6752:	29 f4       	brne	.+10     	; 0x675e <vfprintf+0xda>
    6754:	d6 fc       	sbrc	r13, 6
    6756:	6d c1       	rjmp	.+730    	; 0x6a32 <vfprintf+0x3ae>
    6758:	40 e4       	ldi	r20, 0x40	; 64
    675a:	d4 2a       	or	r13, r20
    675c:	07 c0       	rjmp	.+14     	; 0x676c <vfprintf+0xe8>
    675e:	9c 36       	cpi	r25, 0x6C	; 108
    6760:	19 f4       	brne	.+6      	; 0x6768 <vfprintf+0xe4>
    6762:	50 e8       	ldi	r21, 0x80	; 128
    6764:	d5 2a       	or	r13, r21
    6766:	02 c0       	rjmp	.+4      	; 0x676c <vfprintf+0xe8>
    6768:	98 36       	cpi	r25, 0x68	; 104
    676a:	49 f4       	brne	.+18     	; 0x677e <vfprintf+0xfa>
    676c:	f2 01       	movw	r30, r4
    676e:	23 fd       	sbrc	r18, 3
    6770:	95 91       	lpm	r25, Z+
    6772:	23 ff       	sbrs	r18, 3
    6774:	91 91       	ld	r25, Z+
    6776:	2f 01       	movw	r4, r30
    6778:	99 23       	and	r25, r25
    677a:	09 f0       	breq	.+2      	; 0x677e <vfprintf+0xfa>
    677c:	b8 cf       	rjmp	.-144    	; 0x66ee <vfprintf+0x6a>
    677e:	89 2f       	mov	r24, r25
    6780:	85 54       	subi	r24, 0x45	; 69
    6782:	83 30       	cpi	r24, 0x03	; 3
    6784:	18 f0       	brcs	.+6      	; 0x678c <vfprintf+0x108>
    6786:	80 52       	subi	r24, 0x20	; 32
    6788:	83 30       	cpi	r24, 0x03	; 3
    678a:	38 f4       	brcc	.+14     	; 0x679a <vfprintf+0x116>
    678c:	44 e0       	ldi	r20, 0x04	; 4
    678e:	50 e0       	ldi	r21, 0x00	; 0
    6790:	a4 0e       	add	r10, r20
    6792:	b5 1e       	adc	r11, r21
    6794:	5f e3       	ldi	r21, 0x3F	; 63
    6796:	59 83       	std	Y+1, r21	; 0x01
    6798:	0f c0       	rjmp	.+30     	; 0x67b8 <vfprintf+0x134>
    679a:	93 36       	cpi	r25, 0x63	; 99
    679c:	31 f0       	breq	.+12     	; 0x67aa <vfprintf+0x126>
    679e:	93 37       	cpi	r25, 0x73	; 115
    67a0:	79 f0       	breq	.+30     	; 0x67c0 <vfprintf+0x13c>
    67a2:	93 35       	cpi	r25, 0x53	; 83
    67a4:	09 f0       	breq	.+2      	; 0x67a8 <vfprintf+0x124>
    67a6:	56 c0       	rjmp	.+172    	; 0x6854 <vfprintf+0x1d0>
    67a8:	20 c0       	rjmp	.+64     	; 0x67ea <vfprintf+0x166>
    67aa:	f5 01       	movw	r30, r10
    67ac:	80 81       	ld	r24, Z
    67ae:	89 83       	std	Y+1, r24	; 0x01
    67b0:	42 e0       	ldi	r20, 0x02	; 2
    67b2:	50 e0       	ldi	r21, 0x00	; 0
    67b4:	a4 0e       	add	r10, r20
    67b6:	b5 1e       	adc	r11, r21
    67b8:	71 01       	movw	r14, r2
    67ba:	01 e0       	ldi	r16, 0x01	; 1
    67bc:	10 e0       	ldi	r17, 0x00	; 0
    67be:	12 c0       	rjmp	.+36     	; 0x67e4 <vfprintf+0x160>
    67c0:	f5 01       	movw	r30, r10
    67c2:	e0 80       	ld	r14, Z
    67c4:	f1 80       	ldd	r15, Z+1	; 0x01
    67c6:	d6 fc       	sbrc	r13, 6
    67c8:	03 c0       	rjmp	.+6      	; 0x67d0 <vfprintf+0x14c>
    67ca:	6f ef       	ldi	r22, 0xFF	; 255
    67cc:	7f ef       	ldi	r23, 0xFF	; 255
    67ce:	02 c0       	rjmp	.+4      	; 0x67d4 <vfprintf+0x150>
    67d0:	69 2d       	mov	r22, r9
    67d2:	70 e0       	ldi	r23, 0x00	; 0
    67d4:	42 e0       	ldi	r20, 0x02	; 2
    67d6:	50 e0       	ldi	r21, 0x00	; 0
    67d8:	a4 0e       	add	r10, r20
    67da:	b5 1e       	adc	r11, r21
    67dc:	c7 01       	movw	r24, r14
    67de:	0e 94 2c 35 	call	0x6a58	; 0x6a58 <strnlen>
    67e2:	8c 01       	movw	r16, r24
    67e4:	5f e7       	ldi	r21, 0x7F	; 127
    67e6:	d5 22       	and	r13, r21
    67e8:	14 c0       	rjmp	.+40     	; 0x6812 <vfprintf+0x18e>
    67ea:	f5 01       	movw	r30, r10
    67ec:	e0 80       	ld	r14, Z
    67ee:	f1 80       	ldd	r15, Z+1	; 0x01
    67f0:	d6 fc       	sbrc	r13, 6
    67f2:	03 c0       	rjmp	.+6      	; 0x67fa <vfprintf+0x176>
    67f4:	6f ef       	ldi	r22, 0xFF	; 255
    67f6:	7f ef       	ldi	r23, 0xFF	; 255
    67f8:	02 c0       	rjmp	.+4      	; 0x67fe <vfprintf+0x17a>
    67fa:	69 2d       	mov	r22, r9
    67fc:	70 e0       	ldi	r23, 0x00	; 0
    67fe:	42 e0       	ldi	r20, 0x02	; 2
    6800:	50 e0       	ldi	r21, 0x00	; 0
    6802:	a4 0e       	add	r10, r20
    6804:	b5 1e       	adc	r11, r21
    6806:	c7 01       	movw	r24, r14
    6808:	0e 94 21 35 	call	0x6a42	; 0x6a42 <strnlen_P>
    680c:	8c 01       	movw	r16, r24
    680e:	50 e8       	ldi	r21, 0x80	; 128
    6810:	d5 2a       	or	r13, r21
    6812:	d3 fe       	sbrs	r13, 3
    6814:	07 c0       	rjmp	.+14     	; 0x6824 <vfprintf+0x1a0>
    6816:	1a c0       	rjmp	.+52     	; 0x684c <vfprintf+0x1c8>
    6818:	b3 01       	movw	r22, r6
    681a:	80 e2       	ldi	r24, 0x20	; 32
    681c:	90 e0       	ldi	r25, 0x00	; 0
    681e:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    6822:	ca 94       	dec	r12
    6824:	8c 2d       	mov	r24, r12
    6826:	90 e0       	ldi	r25, 0x00	; 0
    6828:	08 17       	cp	r16, r24
    682a:	19 07       	cpc	r17, r25
    682c:	a8 f3       	brcs	.-22     	; 0x6818 <vfprintf+0x194>
    682e:	0e c0       	rjmp	.+28     	; 0x684c <vfprintf+0x1c8>
    6830:	f7 01       	movw	r30, r14
    6832:	d7 fc       	sbrc	r13, 7
    6834:	85 91       	lpm	r24, Z+
    6836:	d7 fe       	sbrs	r13, 7
    6838:	81 91       	ld	r24, Z+
    683a:	7f 01       	movw	r14, r30
    683c:	b3 01       	movw	r22, r6
    683e:	90 e0       	ldi	r25, 0x00	; 0
    6840:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    6844:	c1 10       	cpse	r12, r1
    6846:	ca 94       	dec	r12
    6848:	01 50       	subi	r16, 0x01	; 1
    684a:	10 40       	sbci	r17, 0x00	; 0
    684c:	01 15       	cp	r16, r1
    684e:	11 05       	cpc	r17, r1
    6850:	79 f7       	brne	.-34     	; 0x6830 <vfprintf+0x1ac>
    6852:	ec c0       	rjmp	.+472    	; 0x6a2c <vfprintf+0x3a8>
    6854:	94 36       	cpi	r25, 0x64	; 100
    6856:	11 f0       	breq	.+4      	; 0x685c <vfprintf+0x1d8>
    6858:	99 36       	cpi	r25, 0x69	; 105
    685a:	71 f5       	brne	.+92     	; 0x68b8 <vfprintf+0x234>
    685c:	d7 fe       	sbrs	r13, 7
    685e:	08 c0       	rjmp	.+16     	; 0x6870 <vfprintf+0x1ec>
    6860:	f5 01       	movw	r30, r10
    6862:	e0 80       	ld	r14, Z
    6864:	f1 80       	ldd	r15, Z+1	; 0x01
    6866:	02 81       	ldd	r16, Z+2	; 0x02
    6868:	13 81       	ldd	r17, Z+3	; 0x03
    686a:	44 e0       	ldi	r20, 0x04	; 4
    686c:	50 e0       	ldi	r21, 0x00	; 0
    686e:	0a c0       	rjmp	.+20     	; 0x6884 <vfprintf+0x200>
    6870:	f5 01       	movw	r30, r10
    6872:	80 81       	ld	r24, Z
    6874:	91 81       	ldd	r25, Z+1	; 0x01
    6876:	7c 01       	movw	r14, r24
    6878:	00 27       	eor	r16, r16
    687a:	f7 fc       	sbrc	r15, 7
    687c:	00 95       	com	r16
    687e:	10 2f       	mov	r17, r16
    6880:	42 e0       	ldi	r20, 0x02	; 2
    6882:	50 e0       	ldi	r21, 0x00	; 0
    6884:	a4 0e       	add	r10, r20
    6886:	b5 1e       	adc	r11, r21
    6888:	5f e6       	ldi	r21, 0x6F	; 111
    688a:	d5 22       	and	r13, r21
    688c:	17 ff       	sbrs	r17, 7
    688e:	0a c0       	rjmp	.+20     	; 0x68a4 <vfprintf+0x220>
    6890:	10 95       	com	r17
    6892:	00 95       	com	r16
    6894:	f0 94       	com	r15
    6896:	e0 94       	com	r14
    6898:	e1 1c       	adc	r14, r1
    689a:	f1 1c       	adc	r15, r1
    689c:	01 1d       	adc	r16, r1
    689e:	11 1d       	adc	r17, r1
    68a0:	80 e8       	ldi	r24, 0x80	; 128
    68a2:	d8 2a       	or	r13, r24
    68a4:	2a e0       	ldi	r18, 0x0A	; 10
    68a6:	30 e0       	ldi	r19, 0x00	; 0
    68a8:	a1 01       	movw	r20, r2
    68aa:	c8 01       	movw	r24, r16
    68ac:	b7 01       	movw	r22, r14
    68ae:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <__ultoa_invert>
    68b2:	f8 2e       	mov	r15, r24
    68b4:	f2 18       	sub	r15, r2
    68b6:	40 c0       	rjmp	.+128    	; 0x6938 <vfprintf+0x2b4>
    68b8:	95 37       	cpi	r25, 0x75	; 117
    68ba:	29 f4       	brne	.+10     	; 0x68c6 <vfprintf+0x242>
    68bc:	1d 2d       	mov	r17, r13
    68be:	1f 7e       	andi	r17, 0xEF	; 239
    68c0:	2a e0       	ldi	r18, 0x0A	; 10
    68c2:	30 e0       	ldi	r19, 0x00	; 0
    68c4:	1d c0       	rjmp	.+58     	; 0x6900 <vfprintf+0x27c>
    68c6:	1d 2d       	mov	r17, r13
    68c8:	19 7f       	andi	r17, 0xF9	; 249
    68ca:	9f 36       	cpi	r25, 0x6F	; 111
    68cc:	61 f0       	breq	.+24     	; 0x68e6 <vfprintf+0x262>
    68ce:	90 37       	cpi	r25, 0x70	; 112
    68d0:	20 f4       	brcc	.+8      	; 0x68da <vfprintf+0x256>
    68d2:	98 35       	cpi	r25, 0x58	; 88
    68d4:	09 f0       	breq	.+2      	; 0x68d8 <vfprintf+0x254>
    68d6:	ad c0       	rjmp	.+346    	; 0x6a32 <vfprintf+0x3ae>
    68d8:	0f c0       	rjmp	.+30     	; 0x68f8 <vfprintf+0x274>
    68da:	90 37       	cpi	r25, 0x70	; 112
    68dc:	39 f0       	breq	.+14     	; 0x68ec <vfprintf+0x268>
    68de:	98 37       	cpi	r25, 0x78	; 120
    68e0:	09 f0       	breq	.+2      	; 0x68e4 <vfprintf+0x260>
    68e2:	a7 c0       	rjmp	.+334    	; 0x6a32 <vfprintf+0x3ae>
    68e4:	04 c0       	rjmp	.+8      	; 0x68ee <vfprintf+0x26a>
    68e6:	28 e0       	ldi	r18, 0x08	; 8
    68e8:	30 e0       	ldi	r19, 0x00	; 0
    68ea:	0a c0       	rjmp	.+20     	; 0x6900 <vfprintf+0x27c>
    68ec:	10 61       	ori	r17, 0x10	; 16
    68ee:	14 fd       	sbrc	r17, 4
    68f0:	14 60       	ori	r17, 0x04	; 4
    68f2:	20 e1       	ldi	r18, 0x10	; 16
    68f4:	30 e0       	ldi	r19, 0x00	; 0
    68f6:	04 c0       	rjmp	.+8      	; 0x6900 <vfprintf+0x27c>
    68f8:	14 fd       	sbrc	r17, 4
    68fa:	16 60       	ori	r17, 0x06	; 6
    68fc:	20 e1       	ldi	r18, 0x10	; 16
    68fe:	32 e0       	ldi	r19, 0x02	; 2
    6900:	17 ff       	sbrs	r17, 7
    6902:	08 c0       	rjmp	.+16     	; 0x6914 <vfprintf+0x290>
    6904:	f5 01       	movw	r30, r10
    6906:	60 81       	ld	r22, Z
    6908:	71 81       	ldd	r23, Z+1	; 0x01
    690a:	82 81       	ldd	r24, Z+2	; 0x02
    690c:	93 81       	ldd	r25, Z+3	; 0x03
    690e:	44 e0       	ldi	r20, 0x04	; 4
    6910:	50 e0       	ldi	r21, 0x00	; 0
    6912:	08 c0       	rjmp	.+16     	; 0x6924 <vfprintf+0x2a0>
    6914:	f5 01       	movw	r30, r10
    6916:	80 81       	ld	r24, Z
    6918:	91 81       	ldd	r25, Z+1	; 0x01
    691a:	bc 01       	movw	r22, r24
    691c:	80 e0       	ldi	r24, 0x00	; 0
    691e:	90 e0       	ldi	r25, 0x00	; 0
    6920:	42 e0       	ldi	r20, 0x02	; 2
    6922:	50 e0       	ldi	r21, 0x00	; 0
    6924:	a4 0e       	add	r10, r20
    6926:	b5 1e       	adc	r11, r21
    6928:	a1 01       	movw	r20, r2
    692a:	0e 94 73 35 	call	0x6ae6	; 0x6ae6 <__ultoa_invert>
    692e:	f8 2e       	mov	r15, r24
    6930:	f2 18       	sub	r15, r2
    6932:	8f e7       	ldi	r24, 0x7F	; 127
    6934:	d8 2e       	mov	r13, r24
    6936:	d1 22       	and	r13, r17
    6938:	d6 fe       	sbrs	r13, 6
    693a:	0b c0       	rjmp	.+22     	; 0x6952 <vfprintf+0x2ce>
    693c:	5e ef       	ldi	r21, 0xFE	; 254
    693e:	d5 22       	and	r13, r21
    6940:	f9 14       	cp	r15, r9
    6942:	38 f4       	brcc	.+14     	; 0x6952 <vfprintf+0x2ce>
    6944:	d4 fe       	sbrs	r13, 4
    6946:	07 c0       	rjmp	.+14     	; 0x6956 <vfprintf+0x2d2>
    6948:	d2 fc       	sbrc	r13, 2
    694a:	05 c0       	rjmp	.+10     	; 0x6956 <vfprintf+0x2d2>
    694c:	8f ee       	ldi	r24, 0xEF	; 239
    694e:	d8 22       	and	r13, r24
    6950:	02 c0       	rjmp	.+4      	; 0x6956 <vfprintf+0x2d2>
    6952:	1f 2d       	mov	r17, r15
    6954:	01 c0       	rjmp	.+2      	; 0x6958 <vfprintf+0x2d4>
    6956:	19 2d       	mov	r17, r9
    6958:	d4 fe       	sbrs	r13, 4
    695a:	0d c0       	rjmp	.+26     	; 0x6976 <vfprintf+0x2f2>
    695c:	fe 01       	movw	r30, r28
    695e:	ef 0d       	add	r30, r15
    6960:	f1 1d       	adc	r31, r1
    6962:	80 81       	ld	r24, Z
    6964:	80 33       	cpi	r24, 0x30	; 48
    6966:	19 f4       	brne	.+6      	; 0x696e <vfprintf+0x2ea>
    6968:	99 ee       	ldi	r25, 0xE9	; 233
    696a:	d9 22       	and	r13, r25
    696c:	08 c0       	rjmp	.+16     	; 0x697e <vfprintf+0x2fa>
    696e:	1f 5f       	subi	r17, 0xFF	; 255
    6970:	d2 fe       	sbrs	r13, 2
    6972:	05 c0       	rjmp	.+10     	; 0x697e <vfprintf+0x2fa>
    6974:	03 c0       	rjmp	.+6      	; 0x697c <vfprintf+0x2f8>
    6976:	8d 2d       	mov	r24, r13
    6978:	86 78       	andi	r24, 0x86	; 134
    697a:	09 f0       	breq	.+2      	; 0x697e <vfprintf+0x2fa>
    697c:	1f 5f       	subi	r17, 0xFF	; 255
    697e:	0d 2d       	mov	r16, r13
    6980:	d3 fc       	sbrc	r13, 3
    6982:	14 c0       	rjmp	.+40     	; 0x69ac <vfprintf+0x328>
    6984:	d0 fe       	sbrs	r13, 0
    6986:	0f c0       	rjmp	.+30     	; 0x69a6 <vfprintf+0x322>
    6988:	1c 15       	cp	r17, r12
    698a:	10 f0       	brcs	.+4      	; 0x6990 <vfprintf+0x30c>
    698c:	9f 2c       	mov	r9, r15
    698e:	0b c0       	rjmp	.+22     	; 0x69a6 <vfprintf+0x322>
    6990:	9f 2c       	mov	r9, r15
    6992:	9c 0c       	add	r9, r12
    6994:	91 1a       	sub	r9, r17
    6996:	1c 2d       	mov	r17, r12
    6998:	06 c0       	rjmp	.+12     	; 0x69a6 <vfprintf+0x322>
    699a:	b3 01       	movw	r22, r6
    699c:	80 e2       	ldi	r24, 0x20	; 32
    699e:	90 e0       	ldi	r25, 0x00	; 0
    69a0:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    69a4:	1f 5f       	subi	r17, 0xFF	; 255
    69a6:	1c 15       	cp	r17, r12
    69a8:	c0 f3       	brcs	.-16     	; 0x699a <vfprintf+0x316>
    69aa:	04 c0       	rjmp	.+8      	; 0x69b4 <vfprintf+0x330>
    69ac:	1c 15       	cp	r17, r12
    69ae:	10 f4       	brcc	.+4      	; 0x69b4 <vfprintf+0x330>
    69b0:	c1 1a       	sub	r12, r17
    69b2:	01 c0       	rjmp	.+2      	; 0x69b6 <vfprintf+0x332>
    69b4:	cc 24       	eor	r12, r12
    69b6:	04 ff       	sbrs	r16, 4
    69b8:	10 c0       	rjmp	.+32     	; 0x69da <vfprintf+0x356>
    69ba:	b3 01       	movw	r22, r6
    69bc:	80 e3       	ldi	r24, 0x30	; 48
    69be:	90 e0       	ldi	r25, 0x00	; 0
    69c0:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    69c4:	02 ff       	sbrs	r16, 2
    69c6:	1e c0       	rjmp	.+60     	; 0x6a04 <vfprintf+0x380>
    69c8:	01 fd       	sbrc	r16, 1
    69ca:	03 c0       	rjmp	.+6      	; 0x69d2 <vfprintf+0x34e>
    69cc:	88 e7       	ldi	r24, 0x78	; 120
    69ce:	90 e0       	ldi	r25, 0x00	; 0
    69d0:	02 c0       	rjmp	.+4      	; 0x69d6 <vfprintf+0x352>
    69d2:	88 e5       	ldi	r24, 0x58	; 88
    69d4:	90 e0       	ldi	r25, 0x00	; 0
    69d6:	b3 01       	movw	r22, r6
    69d8:	0c c0       	rjmp	.+24     	; 0x69f2 <vfprintf+0x36e>
    69da:	80 2f       	mov	r24, r16
    69dc:	86 78       	andi	r24, 0x86	; 134
    69de:	91 f0       	breq	.+36     	; 0x6a04 <vfprintf+0x380>
    69e0:	01 ff       	sbrs	r16, 1
    69e2:	02 c0       	rjmp	.+4      	; 0x69e8 <vfprintf+0x364>
    69e4:	8b e2       	ldi	r24, 0x2B	; 43
    69e6:	01 c0       	rjmp	.+2      	; 0x69ea <vfprintf+0x366>
    69e8:	80 e2       	ldi	r24, 0x20	; 32
    69ea:	d7 fc       	sbrc	r13, 7
    69ec:	8d e2       	ldi	r24, 0x2D	; 45
    69ee:	b3 01       	movw	r22, r6
    69f0:	90 e0       	ldi	r25, 0x00	; 0
    69f2:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    69f6:	06 c0       	rjmp	.+12     	; 0x6a04 <vfprintf+0x380>
    69f8:	b3 01       	movw	r22, r6
    69fa:	80 e3       	ldi	r24, 0x30	; 48
    69fc:	90 e0       	ldi	r25, 0x00	; 0
    69fe:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    6a02:	9a 94       	dec	r9
    6a04:	f9 14       	cp	r15, r9
    6a06:	c0 f3       	brcs	.-16     	; 0x69f8 <vfprintf+0x374>
    6a08:	fa 94       	dec	r15
    6a0a:	f1 01       	movw	r30, r2
    6a0c:	ef 0d       	add	r30, r15
    6a0e:	f1 1d       	adc	r31, r1
    6a10:	b3 01       	movw	r22, r6
    6a12:	80 81       	ld	r24, Z
    6a14:	90 e0       	ldi	r25, 0x00	; 0
    6a16:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    6a1a:	ff 20       	and	r15, r15
    6a1c:	a9 f7       	brne	.-22     	; 0x6a08 <vfprintf+0x384>
    6a1e:	06 c0       	rjmp	.+12     	; 0x6a2c <vfprintf+0x3a8>
    6a20:	b3 01       	movw	r22, r6
    6a22:	80 e2       	ldi	r24, 0x20	; 32
    6a24:	90 e0       	ldi	r25, 0x00	; 0
    6a26:	0e 94 47 35 	call	0x6a8e	; 0x6a8e <fputc>
    6a2a:	ca 94       	dec	r12
    6a2c:	cc 20       	and	r12, r12
    6a2e:	c1 f7       	brne	.-16     	; 0x6a20 <vfprintf+0x39c>
    6a30:	41 ce       	rjmp	.-894    	; 0x66b4 <vfprintf+0x30>
    6a32:	f3 01       	movw	r30, r6
    6a34:	66 81       	ldd	r22, Z+6	; 0x06
    6a36:	77 81       	ldd	r23, Z+7	; 0x07
    6a38:	cb 01       	movw	r24, r22
    6a3a:	2b 96       	adiw	r28, 0x0b	; 11
    6a3c:	e2 e1       	ldi	r30, 0x12	; 18
    6a3e:	0c 94 01 36 	jmp	0x6c02	; 0x6c02 <__epilogue_restores__>

00006a42 <strnlen_P>:
    6a42:	fc 01       	movw	r30, r24
    6a44:	05 90       	lpm	r0, Z+
    6a46:	61 50       	subi	r22, 0x01	; 1
    6a48:	70 40       	sbci	r23, 0x00	; 0
    6a4a:	01 10       	cpse	r0, r1
    6a4c:	d8 f7       	brcc	.-10     	; 0x6a44 <strnlen_P+0x2>
    6a4e:	80 95       	com	r24
    6a50:	90 95       	com	r25
    6a52:	8e 0f       	add	r24, r30
    6a54:	9f 1f       	adc	r25, r31
    6a56:	08 95       	ret

00006a58 <strnlen>:
    6a58:	fc 01       	movw	r30, r24
    6a5a:	61 50       	subi	r22, 0x01	; 1
    6a5c:	70 40       	sbci	r23, 0x00	; 0
    6a5e:	01 90       	ld	r0, Z+
    6a60:	01 10       	cpse	r0, r1
    6a62:	d8 f7       	brcc	.-10     	; 0x6a5a <strnlen+0x2>
    6a64:	80 95       	com	r24
    6a66:	90 95       	com	r25
    6a68:	8e 0f       	add	r24, r30
    6a6a:	9f 1f       	adc	r25, r31
    6a6c:	08 95       	ret

00006a6e <strrev>:
    6a6e:	dc 01       	movw	r26, r24
    6a70:	fc 01       	movw	r30, r24
    6a72:	67 2f       	mov	r22, r23
    6a74:	71 91       	ld	r23, Z+
    6a76:	77 23       	and	r23, r23
    6a78:	e1 f7       	brne	.-8      	; 0x6a72 <strrev+0x4>
    6a7a:	32 97       	sbiw	r30, 0x02	; 2
    6a7c:	04 c0       	rjmp	.+8      	; 0x6a86 <strrev+0x18>
    6a7e:	7c 91       	ld	r23, X
    6a80:	6d 93       	st	X+, r22
    6a82:	70 83       	st	Z, r23
    6a84:	62 91       	ld	r22, -Z
    6a86:	ae 17       	cp	r26, r30
    6a88:	bf 07       	cpc	r27, r31
    6a8a:	c8 f3       	brcs	.-14     	; 0x6a7e <strrev+0x10>
    6a8c:	08 95       	ret

00006a8e <fputc>:
    6a8e:	0f 93       	push	r16
    6a90:	1f 93       	push	r17
    6a92:	cf 93       	push	r28
    6a94:	df 93       	push	r29
    6a96:	8c 01       	movw	r16, r24
    6a98:	eb 01       	movw	r28, r22
    6a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a9c:	81 ff       	sbrs	r24, 1
    6a9e:	1b c0       	rjmp	.+54     	; 0x6ad6 <fputc+0x48>
    6aa0:	82 ff       	sbrs	r24, 2
    6aa2:	0d c0       	rjmp	.+26     	; 0x6abe <fputc+0x30>
    6aa4:	2e 81       	ldd	r18, Y+6	; 0x06
    6aa6:	3f 81       	ldd	r19, Y+7	; 0x07
    6aa8:	8c 81       	ldd	r24, Y+4	; 0x04
    6aaa:	9d 81       	ldd	r25, Y+5	; 0x05
    6aac:	28 17       	cp	r18, r24
    6aae:	39 07       	cpc	r19, r25
    6ab0:	64 f4       	brge	.+24     	; 0x6aca <fputc+0x3c>
    6ab2:	e8 81       	ld	r30, Y
    6ab4:	f9 81       	ldd	r31, Y+1	; 0x01
    6ab6:	01 93       	st	Z+, r16
    6ab8:	f9 83       	std	Y+1, r31	; 0x01
    6aba:	e8 83       	st	Y, r30
    6abc:	06 c0       	rjmp	.+12     	; 0x6aca <fputc+0x3c>
    6abe:	e8 85       	ldd	r30, Y+8	; 0x08
    6ac0:	f9 85       	ldd	r31, Y+9	; 0x09
    6ac2:	80 2f       	mov	r24, r16
    6ac4:	09 95       	icall
    6ac6:	89 2b       	or	r24, r25
    6ac8:	31 f4       	brne	.+12     	; 0x6ad6 <fputc+0x48>
    6aca:	8e 81       	ldd	r24, Y+6	; 0x06
    6acc:	9f 81       	ldd	r25, Y+7	; 0x07
    6ace:	01 96       	adiw	r24, 0x01	; 1
    6ad0:	9f 83       	std	Y+7, r25	; 0x07
    6ad2:	8e 83       	std	Y+6, r24	; 0x06
    6ad4:	02 c0       	rjmp	.+4      	; 0x6ada <fputc+0x4c>
    6ad6:	0f ef       	ldi	r16, 0xFF	; 255
    6ad8:	1f ef       	ldi	r17, 0xFF	; 255
    6ada:	c8 01       	movw	r24, r16
    6adc:	df 91       	pop	r29
    6ade:	cf 91       	pop	r28
    6ae0:	1f 91       	pop	r17
    6ae2:	0f 91       	pop	r16
    6ae4:	08 95       	ret

00006ae6 <__ultoa_invert>:
    6ae6:	fa 01       	movw	r30, r20
    6ae8:	aa 27       	eor	r26, r26
    6aea:	28 30       	cpi	r18, 0x08	; 8
    6aec:	51 f1       	breq	.+84     	; 0x6b42 <__ultoa_invert+0x5c>
    6aee:	20 31       	cpi	r18, 0x10	; 16
    6af0:	81 f1       	breq	.+96     	; 0x6b52 <__ultoa_invert+0x6c>
    6af2:	e8 94       	clt
    6af4:	6f 93       	push	r22
    6af6:	6e 7f       	andi	r22, 0xFE	; 254
    6af8:	6e 5f       	subi	r22, 0xFE	; 254
    6afa:	7f 4f       	sbci	r23, 0xFF	; 255
    6afc:	8f 4f       	sbci	r24, 0xFF	; 255
    6afe:	9f 4f       	sbci	r25, 0xFF	; 255
    6b00:	af 4f       	sbci	r26, 0xFF	; 255
    6b02:	b1 e0       	ldi	r27, 0x01	; 1
    6b04:	3e d0       	rcall	.+124    	; 0x6b82 <__ultoa_invert+0x9c>
    6b06:	b4 e0       	ldi	r27, 0x04	; 4
    6b08:	3c d0       	rcall	.+120    	; 0x6b82 <__ultoa_invert+0x9c>
    6b0a:	67 0f       	add	r22, r23
    6b0c:	78 1f       	adc	r23, r24
    6b0e:	89 1f       	adc	r24, r25
    6b10:	9a 1f       	adc	r25, r26
    6b12:	a1 1d       	adc	r26, r1
    6b14:	68 0f       	add	r22, r24
    6b16:	79 1f       	adc	r23, r25
    6b18:	8a 1f       	adc	r24, r26
    6b1a:	91 1d       	adc	r25, r1
    6b1c:	a1 1d       	adc	r26, r1
    6b1e:	6a 0f       	add	r22, r26
    6b20:	71 1d       	adc	r23, r1
    6b22:	81 1d       	adc	r24, r1
    6b24:	91 1d       	adc	r25, r1
    6b26:	a1 1d       	adc	r26, r1
    6b28:	20 d0       	rcall	.+64     	; 0x6b6a <__ultoa_invert+0x84>
    6b2a:	09 f4       	brne	.+2      	; 0x6b2e <__ultoa_invert+0x48>
    6b2c:	68 94       	set
    6b2e:	3f 91       	pop	r19
    6b30:	2a e0       	ldi	r18, 0x0A	; 10
    6b32:	26 9f       	mul	r18, r22
    6b34:	11 24       	eor	r1, r1
    6b36:	30 19       	sub	r19, r0
    6b38:	30 5d       	subi	r19, 0xD0	; 208
    6b3a:	31 93       	st	Z+, r19
    6b3c:	de f6       	brtc	.-74     	; 0x6af4 <__ultoa_invert+0xe>
    6b3e:	cf 01       	movw	r24, r30
    6b40:	08 95       	ret
    6b42:	46 2f       	mov	r20, r22
    6b44:	47 70       	andi	r20, 0x07	; 7
    6b46:	40 5d       	subi	r20, 0xD0	; 208
    6b48:	41 93       	st	Z+, r20
    6b4a:	b3 e0       	ldi	r27, 0x03	; 3
    6b4c:	0f d0       	rcall	.+30     	; 0x6b6c <__ultoa_invert+0x86>
    6b4e:	c9 f7       	brne	.-14     	; 0x6b42 <__ultoa_invert+0x5c>
    6b50:	f6 cf       	rjmp	.-20     	; 0x6b3e <__ultoa_invert+0x58>
    6b52:	46 2f       	mov	r20, r22
    6b54:	4f 70       	andi	r20, 0x0F	; 15
    6b56:	40 5d       	subi	r20, 0xD0	; 208
    6b58:	4a 33       	cpi	r20, 0x3A	; 58
    6b5a:	18 f0       	brcs	.+6      	; 0x6b62 <__ultoa_invert+0x7c>
    6b5c:	49 5d       	subi	r20, 0xD9	; 217
    6b5e:	31 fd       	sbrc	r19, 1
    6b60:	40 52       	subi	r20, 0x20	; 32
    6b62:	41 93       	st	Z+, r20
    6b64:	02 d0       	rcall	.+4      	; 0x6b6a <__ultoa_invert+0x84>
    6b66:	a9 f7       	brne	.-22     	; 0x6b52 <__ultoa_invert+0x6c>
    6b68:	ea cf       	rjmp	.-44     	; 0x6b3e <__ultoa_invert+0x58>
    6b6a:	b4 e0       	ldi	r27, 0x04	; 4
    6b6c:	a6 95       	lsr	r26
    6b6e:	97 95       	ror	r25
    6b70:	87 95       	ror	r24
    6b72:	77 95       	ror	r23
    6b74:	67 95       	ror	r22
    6b76:	ba 95       	dec	r27
    6b78:	c9 f7       	brne	.-14     	; 0x6b6c <__ultoa_invert+0x86>
    6b7a:	00 97       	sbiw	r24, 0x00	; 0
    6b7c:	61 05       	cpc	r22, r1
    6b7e:	71 05       	cpc	r23, r1
    6b80:	08 95       	ret
    6b82:	9b 01       	movw	r18, r22
    6b84:	ac 01       	movw	r20, r24
    6b86:	0a 2e       	mov	r0, r26
    6b88:	06 94       	lsr	r0
    6b8a:	57 95       	ror	r21
    6b8c:	47 95       	ror	r20
    6b8e:	37 95       	ror	r19
    6b90:	27 95       	ror	r18
    6b92:	ba 95       	dec	r27
    6b94:	c9 f7       	brne	.-14     	; 0x6b88 <__ultoa_invert+0xa2>
    6b96:	62 0f       	add	r22, r18
    6b98:	73 1f       	adc	r23, r19
    6b9a:	84 1f       	adc	r24, r20
    6b9c:	95 1f       	adc	r25, r21
    6b9e:	a0 1d       	adc	r26, r0
    6ba0:	08 95       	ret

00006ba2 <__udivmodhi4>:
    6ba2:	aa 1b       	sub	r26, r26
    6ba4:	bb 1b       	sub	r27, r27
    6ba6:	51 e1       	ldi	r21, 0x11	; 17
    6ba8:	07 c0       	rjmp	.+14     	; 0x6bb8 <__udivmodhi4_ep>

00006baa <__udivmodhi4_loop>:
    6baa:	aa 1f       	adc	r26, r26
    6bac:	bb 1f       	adc	r27, r27
    6bae:	a6 17       	cp	r26, r22
    6bb0:	b7 07       	cpc	r27, r23
    6bb2:	10 f0       	brcs	.+4      	; 0x6bb8 <__udivmodhi4_ep>
    6bb4:	a6 1b       	sub	r26, r22
    6bb6:	b7 0b       	sbc	r27, r23

00006bb8 <__udivmodhi4_ep>:
    6bb8:	88 1f       	adc	r24, r24
    6bba:	99 1f       	adc	r25, r25
    6bbc:	5a 95       	dec	r21
    6bbe:	a9 f7       	brne	.-22     	; 0x6baa <__udivmodhi4_loop>
    6bc0:	80 95       	com	r24
    6bc2:	90 95       	com	r25
    6bc4:	bc 01       	movw	r22, r24
    6bc6:	cd 01       	movw	r24, r26
    6bc8:	08 95       	ret

00006bca <__prologue_saves__>:
    6bca:	2f 92       	push	r2
    6bcc:	3f 92       	push	r3
    6bce:	4f 92       	push	r4
    6bd0:	5f 92       	push	r5
    6bd2:	6f 92       	push	r6
    6bd4:	7f 92       	push	r7
    6bd6:	8f 92       	push	r8
    6bd8:	9f 92       	push	r9
    6bda:	af 92       	push	r10
    6bdc:	bf 92       	push	r11
    6bde:	cf 92       	push	r12
    6be0:	df 92       	push	r13
    6be2:	ef 92       	push	r14
    6be4:	ff 92       	push	r15
    6be6:	0f 93       	push	r16
    6be8:	1f 93       	push	r17
    6bea:	cf 93       	push	r28
    6bec:	df 93       	push	r29
    6bee:	cd b7       	in	r28, 0x3d	; 61
    6bf0:	de b7       	in	r29, 0x3e	; 62
    6bf2:	ca 1b       	sub	r28, r26
    6bf4:	db 0b       	sbc	r29, r27
    6bf6:	0f b6       	in	r0, 0x3f	; 63
    6bf8:	f8 94       	cli
    6bfa:	de bf       	out	0x3e, r29	; 62
    6bfc:	0f be       	out	0x3f, r0	; 63
    6bfe:	cd bf       	out	0x3d, r28	; 61
    6c00:	09 94       	ijmp

00006c02 <__epilogue_restores__>:
    6c02:	2a 88       	ldd	r2, Y+18	; 0x12
    6c04:	39 88       	ldd	r3, Y+17	; 0x11
    6c06:	48 88       	ldd	r4, Y+16	; 0x10
    6c08:	5f 84       	ldd	r5, Y+15	; 0x0f
    6c0a:	6e 84       	ldd	r6, Y+14	; 0x0e
    6c0c:	7d 84       	ldd	r7, Y+13	; 0x0d
    6c0e:	8c 84       	ldd	r8, Y+12	; 0x0c
    6c10:	9b 84       	ldd	r9, Y+11	; 0x0b
    6c12:	aa 84       	ldd	r10, Y+10	; 0x0a
    6c14:	b9 84       	ldd	r11, Y+9	; 0x09
    6c16:	c8 84       	ldd	r12, Y+8	; 0x08
    6c18:	df 80       	ldd	r13, Y+7	; 0x07
    6c1a:	ee 80       	ldd	r14, Y+6	; 0x06
    6c1c:	fd 80       	ldd	r15, Y+5	; 0x05
    6c1e:	0c 81       	ldd	r16, Y+4	; 0x04
    6c20:	1b 81       	ldd	r17, Y+3	; 0x03
    6c22:	aa 81       	ldd	r26, Y+2	; 0x02
    6c24:	b9 81       	ldd	r27, Y+1	; 0x01
    6c26:	ce 0f       	add	r28, r30
    6c28:	d1 1d       	adc	r29, r1
    6c2a:	0f b6       	in	r0, 0x3f	; 63
    6c2c:	f8 94       	cli
    6c2e:	de bf       	out	0x3e, r29	; 62
    6c30:	0f be       	out	0x3f, r0	; 63
    6c32:	cd bf       	out	0x3d, r28	; 61
    6c34:	ed 01       	movw	r28, r26
    6c36:	08 95       	ret

00006c38 <_exit>:
    6c38:	f8 94       	cli

00006c3a <__stop_program>:
    6c3a:	ff cf       	rjmp	.-2      	; 0x6c3a <__stop_program>
